"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[3655],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return m}});var o=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=o.createContext({}),c=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=c(e.components);return o.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},h=o.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,l=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),h=c(n),m=r,d=h["".concat(l,".").concat(m)]||h[m]||u[m]||a;return n?o.createElement(d,s(s({ref:t},p),{},{components:n})):o.createElement(d,s({ref:t},p))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,s=new Array(a);s[0]=h;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:r,s[1]=i;for(var c=2;c<a;c++)s[c]=n[c];return o.createElement.apply(null,s)}return o.createElement.apply(null,n)}h.displayName="MDXCreateElement"},1962:function(e,t,n){n.r(t),n.d(t,{assets:function(){return p},contentTitle:function(){return l},default:function(){return m},frontMatter:function(){return i},metadata:function(){return c},toc:function(){return u}});var o=n(7462),r=n(3366),a=(n(7294),n(3905)),s=["components"],i={title:"Promise",sidebar_label:"Promise",pagination_next:null,pagination_prev:null,hide_table_of_contents:!1,sidebar_position:1},l="Promise",c={unversionedId:"extra/promise",id:"extra/promise",title:"Promise",description:"Combining multiple promises",source:"@site/docs/extra/promise.md",sourceDirName:"extra",slug:"/extra/promise",permalink:"/sp2022/extra/promise",tags:[],version:"current",sidebarPosition:1,frontMatter:{title:"Promise",sidebar_label:"Promise",pagination_next:null,pagination_prev:null,hide_table_of_contents:!1,sidebar_position:1},sidebar:"docs"},p={},u=[{value:"Combining multiple promises",id:"combining-multiple-promises",level:3},{value:"async and await",id:"async-and-await",level:3},{value:"Conclusion",id:"conclusion",level:3},{value:"Ref",id:"ref",level:2}],h={toc:u};function m(e){var t=e.components,n=(0,r.Z)(e,s);return(0,a.kt)("wrapper",(0,o.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"promise"},"Promise"),(0,a.kt)("h3",{id:"combining-multiple-promises"},"Combining multiple promises"),(0,a.kt)("p",null,"The promise chain is what you need when your operation consists of several asynchronous functions, and you need each one to complete before starting the next one. But there are other ways you might need to combine asynchronous function calls, and the ",(0,a.kt)("inlineCode",{parentName:"p"},"Promise")," API provides some helpers for them."),(0,a.kt)("p",null,"Sometimes you need all the promises to be fulfilled, but they don't depend on each other. In a case like that it's much more efficient to start them all off together, then be notified when they have all fulfilled. ThePromise.all() method is what you need here. It takes an array of promises, and returns a single promise."),(0,a.kt)("p",null,"The promise returned by ",(0,a.kt)("inlineCode",{parentName:"p"},"Promise.all()")," is:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"fulfilled when and if ",(0,a.kt)("em",{parentName:"li"},"all")," the promises in the array are fulfilled. In this case the ",(0,a.kt)("inlineCode",{parentName:"li"},"then()")," handler is called with an array of all the responses, in the same order that the promises were passed into ",(0,a.kt)("inlineCode",{parentName:"li"},"all()")),(0,a.kt)("li",{parentName:"ul"},"rejected when and if ",(0,a.kt)("em",{parentName:"li"},"any")," of the promises in the array are rejected. In this case the ",(0,a.kt)("inlineCode",{parentName:"li"},"catch()")," handler is called with the error thrown by the promise that rejected.")),(0,a.kt)("p",null,"For example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"const fetchPromise1 = fetch('https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json');\nconst fetchPromise2 = fetch('https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/not-found');\nconst fetchPromise3 = fetch('https://mdn.github.io/learning-area/javascript/oojs/json/superheroes.json');\n\nPromise.all([fetchPromise1, fetchPromise2, fetchPromise3])\n  .then( responses => {\n    for (const response of responses) {\n      console.log(`${response.url}: ${response.statusText}`);\n    }\n  })\n  .catch( error => {\n    console.error(`Failed to fetch: ${error}`)\n  });\n")),(0,a.kt)("p",null,"Here we're making three ",(0,a.kt)("inlineCode",{parentName:"p"},"fetch()")," requests to three different URLs. If they all succeed, we will log the response status of each one. If any of them fail, we're logging the failure."),(0,a.kt)("p",null,'With the URLs we\'ve provided, all the requests should be fulfilled, although for the second, the server will return 404 "Not Found". So the output should be:'),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json: OK\nhttps://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/not-found: Not Found\nhttps://mdn.github.io/learning-area/javascript/oojs/json/superheroes.json: OK\n")),(0,a.kt)("p",null,"If we try the same code with a badly formed URL, like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"const fetchPromise1 = fetch('https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json');\nconst fetchPromise2 = fetch('https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/not-found');\nconst fetchPromise3 = fetch('bad-scheme://mdn.github.io/learning-area/javascript/oojs/json/superheroes.json');\n\nPromise.all([fetchPromise1, fetchPromise2, fetchPromise3])\n  .then( responses => {\n    for (const response of responses) {\n      console.log(`${response.url}: ${response.statusText}`);\n    }\n  })\n  .catch( error => {\n    console.error(`Failed to fetch: ${error}`)\n  });\n")),(0,a.kt)("p",null,"...then we can expect the ",(0,a.kt)("inlineCode",{parentName:"p"},"catch()")," handler to run, and we should see something like:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Failed to fetch: TypeError: Failed to fetch\n")),(0,a.kt)("p",null,'Sometimes you might need any one of a set of promises to be fulfilled, and don\'t care which one. In that case you want {{jsxref("Promise/any", "Promise.any()")}}. This is like ',(0,a.kt)("inlineCode",{parentName:"p"},"Promise.all()"),", except that it is fulfilled as soon as any of the array of promises is fulfilled, or rejected if all of them are rejected:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"const fetchPromise1 = fetch('https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json');\nconst fetchPromise2 = fetch('https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/not-found');\nconst fetchPromise3 = fetch('https://mdn.github.io/learning-area/javascript/oojs/json/superheroes.json');\n\nPromise.any([fetchPromise1, fetchPromise2, fetchPromise3])\n  .then( response => {\n    console.log(`${response.url}: ${response.statusText}`);\n  })\n  .catch( error => {\n    console.error(`Failed to fetch: ${error}`)\n  });\n")),(0,a.kt)("p",null,"Note that in this case we can't predict which fetch request will complete first."),(0,a.kt)("p",null,"These are just two of the extra ",(0,a.kt)("inlineCode",{parentName:"p"},"Promise"),' functions for combining multiple promises. To learn about the rest, see the {{jsxref("Promise")}} reference documentation.'),(0,a.kt)("h3",{id:"async-and-await"},"async and await"),(0,a.kt)("p",null,"The async keyword gives you a simpler way to work with asynchronous promise-based code. Adding ",(0,a.kt)("inlineCode",{parentName:"p"},"async")," at the start of a function makes it an async function:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"async function myFunction() {\n  // This is an async function\n}\n")),(0,a.kt)("p",null,"Inside an async function you can use the ",(0,a.kt)("inlineCode",{parentName:"p"},"await")," keyword before a call to a function that returns a promise. This makes the code wait at that point until the promise is settled, at which point the fulfilled value of the promise is treated as a return value, or the rejected value is thrown."),(0,a.kt)("p",null,"This enables you to write code that uses asynchronous functions but looks like synchronous code. For example, we could use it to rewrite our fetch example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"async function fetchProducts() {\n  try {\n    // after this line, our function will wait for the `fetch()` call to be settled\n    // the `fetch()` call will either return a Response or throw an error\n    const response = await fetch('https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json');\n    if (!response.ok) {\n      throw new Error(`HTTP error: ${response.status}`);\n    }\n    // after this line, our function will wait for the `response.json()` call to be settled\n    // the `response.json()` call will either return the JSON object or throw an error\n    const json = await response.json();\n    console.log(json[0].name);\n  }\n  catch(error) {\n    console.error(`Could not get products: ${error}`);\n  }\n}\n\nfetchProducts();\n")),(0,a.kt)("p",null,"Here we are calling ",(0,a.kt)("inlineCode",{parentName:"p"},"await fetch()"),", and instead of getting a ",(0,a.kt)("inlineCode",{parentName:"p"},"Promise"),", our caller gets back a fully complete ",(0,a.kt)("inlineCode",{parentName:"p"},"Response")," object, just as if ",(0,a.kt)("inlineCode",{parentName:"p"},"fetch()")," were a synchronous function!"),(0,a.kt)("p",null,"We can even use a ",(0,a.kt)("inlineCode",{parentName:"p"},"try...catch")," block for error handling, exactly as we would if the code were synchronous."),(0,a.kt)("p",null,"Note though that this magic only works inside the async function. Async functions always return a promise, so you can't do something like:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js",metastring:"example-bad","example-bad":!0},"async function fetchProducts() {\n  try {\n    const response = await fetch('https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json');\n    if (!response.ok) {\n      throw new Error(`HTTP error: ${response.status}`);\n    }\n    const json = await response.json();\n    return json;\n  }\n  catch(error) {\n    console.error(`Could not get products: ${error}`);\n  }\n}\n\nconst json = fetchProducts();\nconsole.log(json[0].name);   // json is a Promise object, so this will not work\n")),(0,a.kt)("p",null,"Instead, you'd need to do something like:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"async function fetchProducts() {\n  try {\n    const response = await fetch('https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json');\n    if (!response.ok) {\n      throw new Error(`HTTP error: ${response.status}`);\n    }\n    const json = await response.json();\n    return json;\n  }\n  catch(error) {\n    console.error(`Could not get products: ${error}`);\n  }\n}\n\nconst jsonPromise = fetchProducts();\njsonPromise.then((json) => console.log(json[0].name));\n")),(0,a.kt)("p",null,"You'll probably use ",(0,a.kt)("inlineCode",{parentName:"p"},"async")," functions a lot where you might otherwise use promise chains, and they make working with promises much more intuitive."),(0,a.kt)("p",null,"Keep in mind that just like a promise chain, ",(0,a.kt)("inlineCode",{parentName:"p"},"await")," forces asynchronous operations to be completed in series. This is necessary if the result of the next operation depends on the result of the last one, but if that's not the case something like ",(0,a.kt)("inlineCode",{parentName:"p"},"Promise.all()")," will be more performant."),(0,a.kt)("h3",{id:"conclusion"},"Conclusion"),(0,a.kt)("p",null,"Promises are the foundation of asynchronous programming in modern JavaScript. They make it easier to express and reason about sequences of asynchronous operations without deeply nested callbacks, and they support a style of error handling that is similar to the synchronous ",(0,a.kt)("inlineCode",{parentName:"p"},"try...catch")," statement."),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"async")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"await")," keywords make it easier to build an operation from a series of consecutive asynchronous function calls, avoiding the need to create explicit promise chains, and allowing you to write code that looks just like synchronous code."),(0,a.kt)("p",null,"Promises work in the latest versions of all modern browsers; the only place where promise support will be a problem is in Opera Mini and IE11 and earlier versions."),(0,a.kt)("p",null,"We didn't touch on all promise features in this article, just the most interesting and useful ones. As you start to learn more about promises, you'll come across more features and techniques."),(0,a.kt)("h2",{id:"ref"},"Ref"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Introducing"},"developer.mozilla.org")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Promises"},"developer.mozilla.org"))))}m.isMDXComponent=!0}}]);