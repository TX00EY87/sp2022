"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[5238],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return d}});var a=n(7294);function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){s(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,s=function(e,t){if(null==e)return{};var n,a,s={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(s[n]=e[n]);return s}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,s=e.mdxType,o=e.originalType,l=e.parentName,p=r(e,["components","mdxType","originalType","parentName"]),u=c(n),d=s,m=u["".concat(l,".").concat(d)]||u[d]||h[d]||o;return n?a.createElement(m,i(i({ref:t},p),{},{components:n})):a.createElement(m,i({ref:t},p))}));function d(e,t){var n=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var o=n.length,i=new Array(o);i[0]=u;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r.mdxType="string"==typeof e?e:s,i[1]=r;for(var c=2;c<o;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},2384:function(e,t,n){n.r(t),n.d(t,{assets:function(){return p},contentTitle:function(){return l},default:function(){return d},frontMatter:function(){return r},metadata:function(){return c},toc:function(){return h}});var a=n(7462),s=n(3366),o=(n(7294),n(3905)),i=["components"],r={title:"Post Lecture Reading",sidebar_label:"Post Lecture",pagination_next:null,pagination_prev:null,hide_table_of_contents:!1,sidebar_position:5},l="After Lecture",c={unversionedId:"lecture-16/post-lecture",id:"lecture-16/post-lecture",title:"Post Lecture Reading",description:"Credits: The post lecture material has been written by Matti Luukkainen from University of Helsinki. The material is licensed under the Creative Commons BY-NC-SA 3.0 License.",source:"@site/docs/lecture-16/post-lecture.md",sourceDirName:"lecture-16",slug:"/lecture-16/post-lecture",permalink:"/sp2022/lecture-16/post-lecture",tags:[],version:"current",sidebarPosition:5,frontMatter:{title:"Post Lecture Reading",sidebar_label:"Post Lecture",pagination_next:null,pagination_prev:null,hide_table_of_contents:!1,sidebar_position:5},sidebar:"docs"},p={},h=[{value:"Unit Testing",id:"unit-testing",level:2},{value:"Testing the backend",id:"testing-the-backend",level:2},{value:"Test environment",id:"test-environment",level:3},{value:"supertest",id:"supertest",level:3},{value:"Initializing the database before tests",id:"initializing-the-database-before-tests",level:3},{value:"Running tests one by one",id:"running-tests-one-by-one",level:3},{value:"Optimizing the beforeEach function",id:"optimizing-the-beforeeach-function",level:3},{value:"Refactoring tests",id:"refactoring-tests",level:3},{value:"Testing React apps",id:"testing-react-apps",level:2},{value:"Rendering the component for tests",id:"rendering-the-component-for-tests",level:3},{value:"Running tests",id:"running-tests",level:3},{value:"Test file location",id:"test-file-location",level:3},{value:"Searching for content in a component",id:"searching-for-content-in-a-component",level:3},{value:"Debugging tests",id:"debugging-tests",level:3},{value:"Clicking buttons in tests",id:"clicking-buttons-in-tests",level:3},{value:"Tests for the <i>Togglable</i> component",id:"tests-for-the-togglable-component",level:3},{value:"Testing the forms",id:"testing-the-forms",level:3},{value:"About finding the elements",id:"about-finding-the-elements",level:3},{value:"Test coverage",id:"test-coverage",level:3},{value:"Frontend integration tests",id:"frontend-integration-tests",level:3},{value:"Snapshot testing",id:"snapshot-testing",level:3},{value:"End to end -testing",id:"end-to-end--testing",level:2},{value:"Cypress",id:"cypress",level:3},{value:"Writing to a form",id:"writing-to-a-form",level:3},{value:"Some things to note",id:"some-things-to-note",level:3},{value:"Testing new note form",id:"testing-new-note-form",level:3},{value:"Controlling the state of the database",id:"controlling-the-state-of-the-database",level:3},{value:"Failed login test",id:"failed-login-test",level:3},{value:"Bypassing the UI",id:"bypassing-the-ui",level:3},{value:"Changing the importance of a note",id:"changing-the-importance-of-a-note",level:3},{value:"Running and debugging the tests",id:"running-and-debugging-the-tests",level:3},{value:"Reference",id:"reference",level:2}],u={toc:h};function d(e){var t=e.components,r=(0,s.Z)(e,i);return(0,o.kt)("wrapper",(0,a.Z)({},u,r,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"after-lecture"},"After Lecture"),(0,o.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,o.kt)("div",{parentName:"div",className:"admonition-heading"},(0,o.kt)("h5",{parentName:"div"},(0,o.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,o.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,o.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,o.kt)("div",{parentName:"div",className:"admonition-content"},(0,o.kt)("p",{parentName:"div"}," ",(0,o.kt)("strong",{parentName:"p"},"Credits"),": The post lecture material has been written by ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/mluukkai"},"Matti Luukkainen")," from ",(0,o.kt)("a",{parentName:"p",href:"https://fullstackopen.com/en/"},"University of Helsinki"),". The material is licensed under the Creative Commons BY-NC-SA 3.0 License."))),(0,o.kt)("h2",{id:"unit-testing"},"Unit Testing"),(0,o.kt)("p",null,"Let's start our testing journey by looking at unit tests. The logic of our application is so simple, that there is not much that makes sense to test with unit tests. Let's create a new file ",(0,o.kt)("i",null,"utils/for_testing.js")," and write a couple of simple functions that we can use for test writing practice:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const reverse = (string) => {\n  return string\n    .split('')\n    .reverse()\n    .join('')\n}\n\nconst average = (array) => {\n  const reducer = (sum, item) => {\n    return sum + item\n  }\n\n  return array.reduce(reducer, 0) / array.length\n}\n\nmodule.exports = {\n  reverse,\n  average,\n}\n")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"The ",(0,o.kt)("em",{parentName:"p"},"average")," function uses the array ",(0,o.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce"},"reduce")," method. If the method is not familiar to you yet, then now is a good time to watch the first three videos from the ",(0,o.kt)("a",{parentName:"p",href:"https://www.youtube.com/watch?v=BMUiFMZr7vk&list=PL0zVEGEvSaeEd9hlmCXrk5yUyqUag-n84"},"Functional Javascript")," series on Youtube.")),(0,o.kt)("p",null,"There are many different testing libraries or ",(0,o.kt)("i",null,"test runners")," available for JavaScript. In this course we will be using a testing library developed and used internally by Facebook called ",(0,o.kt)("a",{parentName:"p",href:"https://jestjs.io/"},"jest"),", that resembles the previous king of JavaScript testing libraries ",(0,o.kt)("a",{parentName:"p",href:"https://mochajs.org/"},"Mocha"),". "),(0,o.kt)("p",null,"Jest is a natural choice, as it works well for testing backends, and it shines when it comes to testing React applications. "),(0,o.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,o.kt)("div",{parentName:"div",className:"admonition-heading"},(0,o.kt)("h5",{parentName:"div"},(0,o.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,o.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,o.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"Windows users: ")),(0,o.kt)("div",{parentName:"div",className:"admonition-content"},(0,o.kt)("p",{parentName:"div"},"Jest may not work if the path of the project directory contains a directory that has spaces in its name."))),(0,o.kt)("p",null,"Since tests are only executed during the development of our application, we will install ",(0,o.kt)("i",null,"jest")," as a development dependency with the command:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"npm install --save-dev jest\n")),(0,o.kt)("p",null,"Let's define the ",(0,o.kt)("i",null,"npm script ",(0,o.kt)("em",{parentName:"p"},"test"))," to execute tests with Jest and to report about the test execution with the ",(0,o.kt)("i",null,"verbose")," style:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},'{\n  //...\n  "scripts": {\n    "start": "node index.js",\n    "dev": "nodemon index.js",\n    "build:ui": "rm -rf build && cd ../../../2/luento/notes && npm run build && cp -r build ../../../3/luento/notes-backend",\n    "deploy": "git push heroku master",\n    "deploy:full": "npm run build:ui && git add . && git commit -m uibuild && git push && npm run deploy",\n    "logs:prod": "heroku logs --tail",\n    "lint": "eslint .",\n    "test": "jest --verbose" // highlight-line\n  },\n  //...\n}\n')),(0,o.kt)("p",null,"Jest requires one to specify that the execution environment is Node. This can be done by adding the following to the end of ",(0,o.kt)("i",null,"package.json"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'{\n //...\n "jest": {\n   "testEnvironment": "node"\n }\n}\n')),(0,o.kt)("p",null,"Alternatively, Jest can look for a configuration file with the default name ",(0,o.kt)("i",null,"jest.config.js"),", where we can define the execution environment like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"module.exports = {\n  testEnvironment: 'node',\n}\n")),(0,o.kt)("p",null,"Let's create a separate directory for our tests called ",(0,o.kt)("i",null,"tests")," and create a new file called ",(0,o.kt)("i",null,"reverse.test.js")," with the following contents:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const reverse = require('../utils/for_testing').reverse\n\ntest('reverse of a', () => {\n  const result = reverse('a')\n\n  expect(result).toBe('a')\n})\n\ntest('reverse of react', () => {\n  const result = reverse('react')\n\n  expect(result).toBe('tcaer')\n})\n\ntest('reverse of releveler', () => {\n  const result = reverse('releveler')\n\n  expect(result).toBe('releveler')\n})\n")),(0,o.kt)("p",null,"The ESLint configuration complains about the ",(0,o.kt)("em",{parentName:"p"},"test")," and ",(0,o.kt)("em",{parentName:"p"},"expect")," commands in our test file, since the configuration does not allow ",(0,o.kt)("i",null,"globals"),". Let's get rid of the complaints by adding ",(0,o.kt)("i",null,'"jest": true')," to the ",(0,o.kt)("i",null,"env")," property in the ",(0,o.kt)("i",null,".eslintrc.js")," file."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"module.exports = {\n  'env': {\n    'commonjs': true,\n    'es2021': true,\n    'node': true,\n    'jest': true, // highlight-line\n  },\n  'extends': 'eslint:recommended',\n  'parserOptions': {\n    'ecmaVersion': 12\n  },\n  \"rules\": {\n    // ...\n  },\n}\n")),(0,o.kt)("p",null,"In the first row, the test file imports the function to be tested and assigns it to a variable called ",(0,o.kt)("em",{parentName:"p"},"reverse"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const reverse = require('../utils/for_testing').reverse\n")),(0,o.kt)("p",null,"Individual test cases are defined with the ",(0,o.kt)("em",{parentName:"p"},"test")," function. The first parameter of the function is the test description as a string. The second parameter is a ",(0,o.kt)("i",null,"function"),", that defines the functionality for the test case. The functionality for the second test case looks like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"() => {\n  const result = reverse('react')\n\n  expect(result).toBe('tcaer')\n}\n")),(0,o.kt)("p",null,"First we execute the code to be tested, meaning that we generate a reverse for the string ",(0,o.kt)("i",null,"react"),". Next we verify the results with the ",(0,o.kt)("a",{parentName:"p",href:"https://jestjs.io/docs/expect#expectvalue"},"expect")," function. Expect wraps the resulting value into an object that offers a collection of ",(0,o.kt)("i",null,"matcher")," functions, that can be used for verifying the correctness of the result. Since in this test case we are comparing two strings, we can use the ",(0,o.kt)("a",{parentName:"p",href:"https://jestjs.io/docs/expect#tobevalue"},"toBe")," matcher."),(0,o.kt)("p",null,"As expected, all of the tests pass:"),(0,o.kt)("p",null,(0,o.kt)("img",{loading:"lazy",src:n(6895).Z,width:"1322",height:"506"})),(0,o.kt)("p",null,"Jest expects by default that the names of test files contain ",(0,o.kt)("i",null,".test"),". In this course, we will follow the convention of naming our tests files with the extension ",(0,o.kt)("i",null,".test.js"),"."),(0,o.kt)("p",null,"Jest has excellent error messages, let's break the test to demonstrate this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"test('palindrom of react', () => {\n  const result = reverse('react')\n\n  expect(result).toBe('tkaer')\n})\n")),(0,o.kt)("p",null,"Running the tests above results in the following error message:"),(0,o.kt)("p",null,(0,o.kt)("img",{loading:"lazy",src:n(6501).Z,width:"1340",height:"840"})),(0,o.kt)("p",null,"Let's add a few tests for the ",(0,o.kt)("em",{parentName:"p"},"average")," function, into a new file ",(0,o.kt)("i",null,"tests/average.test.js"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const average = require('../utils/for_testing').average\n\ndescribe('average', () => {\n  test('of one value is the value itself', () => {\n    expect(average([1])).toBe(1)\n  })\n\n  test('of many is calculated right', () => {\n    expect(average([1, 2, 3, 4, 5, 6])).toBe(3.5)\n  })\n\n  test('of empty array is zero', () => {\n    expect(average([])).toBe(0)\n  })\n})\n")),(0,o.kt)("p",null,"The test reveals that the function does not work correctly with an empty array (this is because in JavaScript dividing by zero results in ",(0,o.kt)("i",null,"NaN"),"):"),(0,o.kt)("p",null,(0,o.kt)("img",{loading:"lazy",src:n(6867).Z,width:"1548",height:"934"})),(0,o.kt)("p",null,"Fixing the function is quite easy:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const average = array => {\n  const reducer = (sum, item) => {\n    return sum + item\n  }\n\n  return array.length === 0\n    ? 0\n    : array.reduce(reducer, 0) / array.length\n}\n")),(0,o.kt)("p",null,"If the length of the array is 0 then we return 0, and in all other cases we use the ",(0,o.kt)("em",{parentName:"p"},"reduce")," method to calculate the average."),(0,o.kt)("p",null,"There are a few things to notice about the tests that we just wrote. We defined a ",(0,o.kt)("i",null,"describe")," block around the tests that was given the name ",(0,o.kt)("em",{parentName:"p"},"average"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"describe('average', () => {\n  // tests\n})\n")),(0,o.kt)("p",null,"Describe blocks can be used for grouping tests into logical collections. The test output of Jest also uses the name of the describe block:"),(0,o.kt)("p",null,(0,o.kt)("img",{loading:"lazy",src:n(7442).Z,width:"1328",height:"542"})),(0,o.kt)("p",null,"As we will see later on ",(0,o.kt)("i",null,"describe")," blocks are necessary when we want to run some shared setup or teardown operations for a group of tests."),(0,o.kt)("p",null,"Another thing to notice is that we wrote the tests in quite a compact way, without assigning the output of the function being tested to a variable:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"test('of empty array is zero', () => {\n  expect(average([])).toBe(0)\n})\n")),(0,o.kt)("h2",{id:"testing-the-backend"},"Testing the backend"),(0,o.kt)("p",null,"We will now start writing tests for the backend. Since the backend does not contain any complicated logic, it doesn't make sense to write ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Unit_testing"},"unit tests")," for it. The only potential thing we could unit test is the ",(0,o.kt)("em",{parentName:"p"},"toJSON")," method that is used for formatting notes."),(0,o.kt)("p",null,"In some situations, it can be beneficial to implement some of the backend tests by mocking the database instead of using a real database. One library that could be used for this is ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/nodkz/mongodb-memory-server"},"mongodb-memory-server"),"."),(0,o.kt)("p",null,"Since our application's backend is still relatively simple, we will make the decision to test the entire application through its REST API, so that the database is also included. This kind of testing where multiple components of the system are being tested as a group, is called ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Integration_testing"},"integration testing"),"."),(0,o.kt)("h3",{id:"test-environment"},"Test environment"),(0,o.kt)("p",null,"The convention in Node is to define the execution mode of the application with the ",(0,o.kt)("i",null,"NODE","_","ENV")," environment variable. In our current application, we only load the environment variables defined in the ",(0,o.kt)("i",null,".env")," file if the application is ",(0,o.kt)("i",null,"not")," in production mode."),(0,o.kt)("p",null,"It is common practice to define separate modes for development and testing."),(0,o.kt)("p",null,"Next, let's change the scripts in our ",(0,o.kt)("i",null,"package.json")," so that when tests are run, ",(0,o.kt)("i",null,"NODE","_","ENV")," gets the value ",(0,o.kt)("i",null,"test"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{\n  // ...\n  "scripts": {\n    "start": "NODE_ENV=production node index.js",// highlight-line\n    "dev": "NODE_ENV=development nodemon index.js",// highlight-line\n    "build:ui": "rm -rf build && cd ../../../2/luento/notes && npm run build && cp -r build ../../../3/luento/notes-backend",\n    "deploy": "git push heroku master",\n    "deploy:full": "npm run build:ui && git add . && git commit -m uibuild && git push && npm run deploy",\n    "logs:prod": "heroku logs --tail",\n    "lint": "eslint .",\n    "test": "NODE_ENV=test jest --verbose --runInBand"// highlight-line\n  },\n  // ...\n}\n')),(0,o.kt)("p",null,"We also added the ",(0,o.kt)("a",{parentName:"p",href:"https://jestjs.io/docs/cli#--runinband"},"runInBand")," option to the npm script that executes the tests. This option will prevent Jest from running tests in parallel; we will discuss its significance once our tests start using the database."),(0,o.kt)("p",null,"We specified the mode of the application to be ",(0,o.kt)("i",null,"development")," in the ",(0,o.kt)("em",{parentName:"p"},"npm run dev")," script that uses nodemon. We also specified that the default ",(0,o.kt)("em",{parentName:"p"},"npm start")," command will define the mode as ",(0,o.kt)("i",null,"production"),"."),(0,o.kt)("p",null,"There is a slight issue in the way that we have specified the mode of the application in our scripts: it will not work on Windows. We can correct this by installing the ",(0,o.kt)("a",{parentName:"p",href:"https://www.npmjs.com/package/cross-env"},"cross-env")," package as a development dependency with the command:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"npm install --save-dev cross-env\n")),(0,o.kt)("p",null,"We can then achieve cross-platform compatibility by using the cross-env library in our npm scripts defined in ",(0,o.kt)("i",null,"package.json"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{\n  // ...\n  "scripts": {\n    "start": "cross-env NODE_ENV=production node index.js",\n    "dev": "cross-env NODE_ENV=development nodemon index.js",\n    // ...\n    "test": "cross-env NODE_ENV=test jest --verbose --runInBand",\n  },\n  // ...\n}\n')),(0,o.kt)("p",null,"Now we can modify the way that our application runs in different modes. As an example of this, we could define the application to use a separate test database when it is running tests."),(0,o.kt)("p",null,"We can create our separate test database in Mongo DB Atlas. This is not an optimal solution in situations where there are many people developing the same application. Test execution in particular typically requires that a single database instance is not used by tests that are running concurrently."),(0,o.kt)("p",null,'It would be better to run our tests using a database that is installed and running in the developer\'s local machine. The optimal solution would be to have every test execution use its own separate database. This is "relatively simple" to achieve by ',(0,o.kt)("a",{parentName:"p",href:"https://docs.mongodb.com/manual/core/inmemory/"},"running Mongo in-memory")," or by using ",(0,o.kt)("a",{parentName:"p",href:"https://www.docker.com"},"Docker")," containers. We will not complicate things and will instead continue to use the MongoDB Atlas database."),(0,o.kt)("p",null,"Let's make some changes to the module that defines the application's configuration:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"require('dotenv').config()\n\nconst PORT = process.env.PORT\n\n// highlight-start\nconst MONGODB_URI = process.env.NODE_ENV === 'test' \n  ? process.env.TEST_MONGODB_URI\n  : process.env.MONGODB_URI\n// highlight-end\n\nmodule.exports = {\n  MONGODB_URI,\n  PORT\n}\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("i",null,".env")," file has ",(0,o.kt)("i",null,"separate variables")," for the database addresses of the development and test databases:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"MONGODB_URI=mongodb+srv://fullstack:<password>@cluster0.o1opl.mongodb.net/noteApp?retryWrites=true&w=majority\nPORT=3001\n\n// highlight-start\nTEST_MONGODB_URI=mongodb+srv://fullstack:<password>@cluster0.o1opl.mongodb.net/testNoteApp?retryWrites=true&w=majority\n// highlight-end\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("em",{parentName:"p"},"config")," module that we have implemented slightly resembles the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/lorenwest/node-config"},"node-config")," package. Writing our own implementation is justified since our application is simple, and also because it teaches us valuable lessons."),(0,o.kt)("p",null,"These are the only changes we need to make to our application's code."),(0,o.kt)("p",null,"You can find the code for our current application in its entirety in the ",(0,o.kt)("i",null,"part4-2")," branch of ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/fullstack-hy/part3-notes-backend/tree/part4-2"},"this github repository"),"."),(0,o.kt)("h3",{id:"supertest"},"supertest"),(0,o.kt)("p",null,"Let's use the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/visionmedia/supertest"},"supertest")," package to help us write our tests for testing the API."),(0,o.kt)("p",null,"We will install the package as a development dependency:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"npm install --save-dev supertest\n")),(0,o.kt)("p",null,"Let's write our first test in the ",(0,o.kt)("i",null,"tests/note_api.test.js")," file:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const mongoose = require('mongoose')\nconst supertest = require('supertest')\nconst app = require('../app')\n\nconst api = supertest(app)\n\ntest('notes are returned as json', async () => {\n  await api\n    .get('/api/notes')\n    .expect(200)\n    .expect('Content-Type', /application\\/json/)\n})\n\nafterAll(() => {\n  mongoose.connection.close()\n})\n")),(0,o.kt)("p",null,"The test imports the Express application from the ",(0,o.kt)("i",null,"app.js")," module and wraps it with the ",(0,o.kt)("i",null,"supertest")," function into a so-called ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/visionmedia/superagent"},"superagent")," object. This object is assigned to the ",(0,o.kt)("i",null,"api")," variable and tests can use it for making HTTP requests to the backend."),(0,o.kt)("p",null,"Our test makes an HTTP GET request to the ",(0,o.kt)("i",null,"api/notes")," url and verifies that the request is responded to with the status code 200. The test also verifies that the ",(0,o.kt)("i",null,"Content-Type")," header is set to ",(0,o.kt)("i",null,"application/json"),", indicating that the data is in the desired format. (If you're not familiar with the RegEx syntax of ",(0,o.kt)("i",null,"/application\\/json/"),", you can learn more ",(0,o.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions"},"here"),".)"),(0,o.kt)("p",null,"The test contains some details that we will explore a bit later on. The arrow function that defines the test is preceded by the ",(0,o.kt)("i",null,"async")," keyword and the method call for the ",(0,o.kt)("i",null,"api")," object is preceded by the ",(0,o.kt)("i",null,"await")," keyword. "),(0,o.kt)("p",null,"The async/await syntax is related to the fact that making a request to the API is an ",(0,o.kt)("i",null,"asynchronous")," operation. The ",(0,o.kt)("a",{parentName:"p",href:"https://jestjs.io/docs/asynchronous"},"Async/await syntax")," can be used for writing asynchronous code with the appearance of synchronous code."),(0,o.kt)("p",null,"Once all the tests (there is currently only one) have finished running we have to close the database connection used by Mongoose. This can be easily achieved with the ",(0,o.kt)("a",{parentName:"p",href:"https://jestjs.io/docs/api#afterallfn-timeout"},"afterAll")," method:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"afterAll(() => {\n  mongoose.connection.close()\n})\n")),(0,o.kt)("p",null,"When running your tests you may run across the following console warning:"),(0,o.kt)("p",null,(0,o.kt)("img",{loading:"lazy",src:n(4376).Z,width:"1614",height:"156"})),(0,o.kt)("p",null,"The problem is quite likely caused by the Mongoose version 6.x, the problem does not appear when the version 5.x is used. Actually ",(0,o.kt)("a",{parentName:"p",href:"https://mongoosejs.com/docs/jest.html"},"Mongoose documentation")," does not recommend testing Mongoose applications with Jest."),(0,o.kt)("p",null,"One way to get rid of this is to run tests with option ",(0,o.kt)("i",null,"--forceExit"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{\n  // ..\n  "scripts": {\n    "start": "cross-env NODE_ENV=production node index.js",\n    "dev": "cross-env NODE_ENV=development nodemon index.js",\n    "lint": "eslint .",\n    "test": "cross-env NODE_ENV=test jest --verbose --runInBand --forceExit" // highlight-line\n  },\n  // ...\n}\n')),(0,o.kt)("p",null,"Another error you may come across is your test takes longer than the default Jest test timeout of 5000 ms. This can be solved by adding a third parameter to the test function:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"test('notes are returned as json', async () => {\n  await api\n    .get('/api/notes')\n    .expect(200)\n    .expect('Content-Type', /application\\/json/)\n}, 100000)\n")),(0,o.kt)("p",null,"This third parameter sets the timeout to be 100000 ms. A long timeout ensures that our test won't fail due to the time it takes to run. (A long timeout may not be what you want for tests based on performance or speed, but this is fine for our example tests)."),(0,o.kt)("p",null,"One tiny but important detail: at the beginning we extracted the Express application into the ",(0,o.kt)("i",null,"app.js")," file, and the role of the ",(0,o.kt)("i",null,"index.js")," file was changed to launch the application at the specified port with Node's built-in ",(0,o.kt)("i",null,"http")," object:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const app = require('./app') // the actual Express app\nconst http = require('http')\nconst config = require('./utils/config')\nconst logger = require('./utils/logger')\n\nconst server = http.createServer(app)\n\nserver.listen(config.PORT, () => {\n  logger.info(`Server running on port ${config.PORT}`)\n})\n")),(0,o.kt)("p",null,"The tests only use the express application defined in the ",(0,o.kt)("i",null,"app.js")," file:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const mongoose = require('mongoose')\nconst supertest = require('supertest')\nconst app = require('../app') // highlight-line\n\nconst api = supertest(app) // highlight-line\n\n// ...\n")),(0,o.kt)("p",null,"The documentation for supertest says the following:"),(0,o.kt)("blockquote",null,(0,o.kt)("i",null,"if the server is not already listening for connections then it is bound to an ephemeral port for you so there is no need to keep track of ports.")),(0,o.kt)("p",null,"In other words, supertest takes care that the application being tested is started at the port that it uses internally."),(0,o.kt)("p",null,"Let's write a few more tests:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"test('there are two notes', async () => {\n  const response = await api.get('/api/notes')\n\n  expect(response.body).toHaveLength(2)\n})\n\ntest('the first note is about HTTP methods', async () => {\n  const response = await api.get('/api/notes')\n\n  expect(response.body[0].content).toBe('HTML is easy')\n})\n")),(0,o.kt)("p",null,"Both tests store the response of the request to the ",(0,o.kt)("em",{parentName:"p"},"response")," variable, and unlike the previous test that used the methods provided by ",(0,o.kt)("em",{parentName:"p"},"supertest")," for verifying the status code and headers, this time we are inspecting the response data stored in ",(0,o.kt)("i",null,"response.body")," property. Our tests verify the format and content of the response data with the ",(0,o.kt)("a",{parentName:"p",href:"https://jestjs.io/docs/expect#expectvalue"},"expect")," method of Jest."),(0,o.kt)("p",null,"The benefit of using the async/await syntax is starting to become evident. Normally we would have to use callback functions to access the data returned by promises, but with the new syntax things are a lot more comfortable:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const response = await api.get('/api/notes')\n\n// execution gets here only after the HTTP request is complete\n// the result of HTTP request is saved in variable response\nexpect(response.body).toHaveLength(2)\n")),(0,o.kt)("p",null,"The middleware that outputs information about the HTTP requests is obstructing the test execution output. Let us modify the logger so that it does not print to console in test mode:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const info = (...params) => {\n  // highlight-start\n  if (process.env.NODE_ENV !== 'test') { \n    console.log(...params)\n  }\n  // highlight-end\n}\n\nconst error = (...params) => {\n  // highlight-start\n  if (process.env.NODE_ENV !== 'test') { \n    console.error(...params)\n  }\n  // highlight-end  \n}\n\nmodule.exports = {\n  info, error\n}\n")),(0,o.kt)("h3",{id:"initializing-the-database-before-tests"},"Initializing the database before tests"),(0,o.kt)("p",null,"Testing appears to be easy and our tests are currently passing. However, our tests are bad as they are dependent on the state of the database (that happens to be correct in my test database). In order to make our tests more robust, we have to reset the database and generate the needed test data in a controlled manner before we run the tests."),(0,o.kt)("p",null,"Our tests are already using the ",(0,o.kt)("a",{parentName:"p",href:"https://jestjs.io/docs/api#afterallfn-timeout"},"afterAll")," function of Jest to close the connection to the database after the tests are finished executing. Jest offers many other ",(0,o.kt)("a",{parentName:"p",href:"https://jestjs.io/docs/setup-teardown"},"functions")," that can be used for executing operations once before any test is run, or every time before a test is run."),(0,o.kt)("p",null,"Let's initialize the database ",(0,o.kt)("i",null,"before every test")," with the ",(0,o.kt)("a",{parentName:"p",href:"https://jestjs.io/docs/en/api.html#beforeeachfn-timeout"},"beforeEach")," function:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const mongoose = require('mongoose')\nconst supertest = require('supertest')\nconst app = require('../app')\nconst api = supertest(app)\n// highlight-start\nconst Note = require('../models/note')\n// highlight-end\n\n// highlight-start\nconst initialNotes = [\n  {\n    content: 'HTML is easy',\n    date: new Date(),\n    important: false,\n  },\n  {\n    content: 'Browser can execute only Javascript',\n    date: new Date(),\n    important: true,\n  },\n]\n// highlight-end\n\n// highlight-start\nbeforeEach(async () => {\n  await Note.deleteMany({})\n\n  let noteObject = new Note(initialNotes[0])\n  await noteObject.save()\n\n  noteObject = new Note(initialNotes[1])\n  await noteObject.save()\n})\n// highlight-end\n// ...\n")),(0,o.kt)("p",null,"The database is cleared out at the beginning, and after that we save the two notes stored in the ",(0,o.kt)("em",{parentName:"p"},"initialNotes")," array to the database. Doing this, we ensure that the database is in the same state before every test is run."),(0,o.kt)("p",null,"Let's also make the following changes to the last two tests:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"test('all notes are returned', async () => {\n  const response = await api.get('/api/notes')\n\n  expect(response.body).toHaveLength(initialNotes.length) // highlight-line\n})\n\ntest('a specific note is within the returned notes', async () => {\n  const response = await api.get('/api/notes')\n\n  // highlight-start\n  const contents = response.body.map(r => r.content)\n\n  expect(contents).toContain(\n    'Browser can execute only Javascript'\n  )\n  // highlight-end\n})\n")),(0,o.kt)("p",null,"Pay special attention to the expect in the latter test. The ",(0,o.kt)("code",null,"response.body.map(r => r.content)")," command is used to create an array containing the content of every note returned by the API. The ",(0,o.kt)("a",{parentName:"p",href:"https://jestjs.io/docs/expect#tocontainitem"},"toContain")," method is used for checking that the note given to it as a parameter is in the list of notes returned by the API."),(0,o.kt)("h3",{id:"running-tests-one-by-one"},"Running tests one by one"),(0,o.kt)("p",null,"The ",(0,o.kt)("em",{parentName:"p"},"npm test")," command executes all of the tests of the application. When we are writing tests, it is usually wise to only execute one or two tests. Jest offers a few different ways of accomplishing this, one of which is the ",(0,o.kt)("a",{parentName:"p",href:"https://jestjs.io/docs/en/api#testonlyname-fn-timeout"},"only")," method. If tests are written across many files, this method is not great."),(0,o.kt)("p",null,"A better option is to specify the tests that need to be run as parameter of the  ",(0,o.kt)("i",null,"npm test")," command."),(0,o.kt)("p",null,"The following command only runs the tests found in the ",(0,o.kt)("i",null,"tests/note_api.test.js")," file:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"npm test -- tests/note_api.test.js\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("i",null,"-t")," option can be used for running tests with a specific name:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'npm test -- -t "a specific note is within the returned notes"\n')),(0,o.kt)("p",null,"The provided parameter can refer to the name of the test or the describe block. The parameter can also contain just a part of the name. The following command will run all of the tests that contain ",(0,o.kt)("i",null,"notes")," in their name:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"npm test -- -t 'notes'\n")),(0,o.kt)("p",null,"Let's also write a test that verifies that a note without content will not be saved into the database."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"test('note without content is not added', async () => {\n  const newNote = {\n    important: true\n  }\n\n  await api\n    .post('/api/notes')\n    .send(newNote)\n    .expect(400)\n\n  const response = await api.get('/api/notes')\n\n  expect(response.body).toHaveLength(initialNotes.length)\n})\n")),(0,o.kt)("p",null,"Both tests check the state stored in the database after the saving operation, by fetching all the notes of the application.  "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const response = await api.get('/api/notes')\n")),(0,o.kt)("p",null,"The same verification steps will repeat in other tests later on, and it is a good idea to extract these steps into helper functions. Let's add the function into a new file called ",(0,o.kt)("i",null,"tests/test_helper.js")," that is in the same directory as the test file."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const Note = require('../models/note')\n\nconst initialNotes = [\n  {\n    content: 'HTML is easy',\n    date: new Date(),\n    important: false\n  },\n  {\n    content: 'Browser can execute only Javascript',\n    date: new Date(),\n    important: true\n  }\n]\n\nconst nonExistingId = async () => {\n  const note = new Note({ content: 'willremovethissoon', date: new Date() })\n  await note.save()\n  await note.remove()\n\n  return note._id.toString()\n}\n\nconst notesInDb = async () => {\n  const notes = await Note.find({})\n  return notes.map(note => note.toJSON())\n}\n\nmodule.exports = {\n  initialNotes, nonExistingId, notesInDb\n}\n")),(0,o.kt)("p",null,"The module defines the ",(0,o.kt)("em",{parentName:"p"},"notesInDb")," function that can be used for checking the notes stored in the database. The ",(0,o.kt)("em",{parentName:"p"},"initialNotes")," array containing the initial database state is also in the module. We also define the ",(0,o.kt)("em",{parentName:"p"},"nonExistingId")," function ahead of time, that can be used for creating a database object ID that does not belong to any note object in the database."),(0,o.kt)("p",null,"Our tests can now use helper module and be changed like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const supertest = require('supertest')\nconst mongoose = require('mongoose')\nconst helper = require('./test_helper') // highlight-line\nconst app = require('../app')\nconst api = supertest(app)\n\nconst Note = require('../models/note')\n\nbeforeEach(async () => {\n  await Note.deleteMany({})\n\n  let noteObject = new Note(helper.initialNotes[0]) // highlight-line\n  await noteObject.save()\n\n  noteObject = new Note(helper.initialNotes[1]) // highlight-line\n  await noteObject.save()\n})\n\ntest('notes are returned as json', async () => {\n  await api\n    .get('/api/notes')\n    .expect(200)\n    .expect('Content-Type', /application\\/json/)\n})\n\ntest('all notes are returned', async () => {\n  const response = await api.get('/api/notes')\n\n  expect(response.body).toHaveLength(helper.initialNotes.length) // highlight-line\n})\n\ntest('a specific note is within the returned notes', async () => {\n  const response = await api.get('/api/notes')\n\n  const contents = response.body.map(r => r.content)\n\n  expect(contents).toContain(\n    'Browser can execute only Javascript'\n  )\n})\n\ntest('a valid note can be added ', async () => {\n  const newNote = {\n    content: 'async/await simplifies making async calls',\n    important: true,\n  }\n\n  await api\n    .post('/api/notes')\n    .send(newNote)\n    .expect(201)\n    .expect('Content-Type', /application\\/json/)\n\n  const notesAtEnd = await helper.notesInDb() // highlight-line\n  expect(notesAtEnd).toHaveLength(helper.initialNotes.length + 1) // highlight-line\n\n  const contents = notesAtEnd.map(n => n.content) // highlight-line\n  expect(contents).toContain(\n    'async/await simplifies making async calls'\n  )\n})\n\ntest('note without content is not added', async () => {\n  const newNote = {\n    important: true\n  }\n\n  await api\n    .post('/api/notes')\n    .send(newNote)\n    .expect(400)\n\n  const notesAtEnd = await helper.notesInDb() // highlight-line\n\n  expect(notesAtEnd).toHaveLength(helper.initialNotes.length) // highlight-line\n})\n\nafterAll(() => {\n  mongoose.connection.close()\n}) \n")),(0,o.kt)("p",null,"The code using promises works and the tests pass. We are ready to refactor our code to use the async/await syntax."),(0,o.kt)("p",null,"After making the change, all of our tests will pass once again."),(0,o.kt)("p",null,"Next, let's write tests for fetching and removing an individual note:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"test('a specific note can be viewed', async () => {\n  const notesAtStart = await helper.notesInDb()\n\n  const noteToView = notesAtStart[0]\n\n// highlight-start\n  const resultNote = await api\n    .get(`/api/notes/${noteToView.id}`)\n    .expect(200)\n    .expect('Content-Type', /application\\/json/)\n// highlight-end\n\n  const processedNoteToView = JSON.parse(JSON.stringify(noteToView))\n\n  expect(resultNote.body).toEqual(processedNoteToView)\n})\n\ntest('a note can be deleted', async () => {\n  const notesAtStart = await helper.notesInDb()\n  const noteToDelete = notesAtStart[0]\n\n// highlight-start\n  await api\n    .delete(`/api/notes/${noteToDelete.id}`)\n    .expect(204)\n// highlight-end\n\n  const notesAtEnd = await helper.notesInDb()\n\n  expect(notesAtEnd).toHaveLength(\n    helper.initialNotes.length - 1\n  )\n\n  const contents = notesAtEnd.map(r => r.content)\n\n  expect(contents).not.toContain(noteToDelete.content)\n})\n")),(0,o.kt)("p",null,"Both tests share a similar structure. In the initialization phase they fetch a note from the database. After this, the tests call the actual operation being tested, which is highlighted in the code block. Lastly, the tests verify that the outcome of the operation is as expected."),(0,o.kt)("p",null,"In the first test, the note object we receive as the response body goes through JSON serialization and parsing. This processing will turn the note object's ",(0,o.kt)("em",null,"date")," property value's type from ",(0,o.kt)("em",null,"Date")," object into a string. Because of this we can't directly compare equality of the ",(0,o.kt)("em",null,"resultNote.body")," and ",(0,o.kt)("em",null,"noteToView")," that is read from the database. Instead, we must first perform similar JSON serialization and parsing for the ",(0,o.kt)("em",null,"noteToView")," as the server is performing for the note object."),(0,o.kt)("p",null,"The tests pass and we can safely refactor the tested routes to use async/await:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"notesRouter.get('/:id', async (request, response, next) => {\n  try {\n    const note = await Note.findById(request.params.id)\n    if (note) {\n      response.json(note)\n    } else {\n      response.status(404).end()\n    }\n  } catch(exception) {\n    next(exception)\n  }\n})\n\nnotesRouter.delete('/:id', async (request, response, next) => {\n  try {\n    await Note.findByIdAndRemove(request.params.id)\n    response.status(204).end()\n  } catch (exception) {\n    next(exception)\n  }\n})\n")),(0,o.kt)("p",null,"You can find the code for our current application in its entirety in the ",(0,o.kt)("i",null,"part4-4")," branch of ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/fullstack-hy/part3-notes-backend/tree/part4-4"},"this Github repository"),"."),(0,o.kt)("h3",{id:"optimizing-the-beforeeach-function"},"Optimizing the beforeEach function"),(0,o.kt)("p",null,"Let's take a closer look at the ",(0,o.kt)("em",{parentName:"p"},"beforeEach")," function that sets up the tests:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"beforeEach(async () => {\n  await Note.deleteMany({})\n\n  let noteObject = new Note(helper.initialNotes[0])\n  await noteObject.save()\n\n  noteObject = new Note(helper.initialNotes[1])\n  await noteObject.save()\n})\n")),(0,o.kt)("p",null,"The function saves the first two notes from the   ",(0,o.kt)("em",{parentName:"p"},"helper.initialNotes")," array into the database with two separate operations. The solution is alright, but there's a better way of saving multiple objects to the database:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"beforeEach(async () => {\n  await Note.deleteMany({})\n  console.log('cleared')\n\n  helper.initialNotes.forEach(async (note) => {\n    let noteObject = new Note(note)\n    await noteObject.save()\n    console.log('saved')\n  })\n  console.log('done')\n})\n\ntest('notes are returned as json', async () => {\n  console.log('entered test')\n  // ...\n}\n")),(0,o.kt)("p",null,"We save the notes stored in the array into the database inside of a ",(0,o.kt)("em",{parentName:"p"},"forEach")," loop. The tests don't quite seem to work however, so we have added some console logs to help us find the problem. "),(0,o.kt)("p",null,"The console displays the following output:"),(0,o.kt)("pre",null,"cleared done entered test saved saved"),(0,o.kt)("p",null,"Despite our use of the async/await syntax, our solution does not work like we expected it to. The test execution begins before the database is initialized!"),(0,o.kt)("p",null,"The problem is that every iteration of the forEach loop generates its own asynchronous operation, and ",(0,o.kt)("em",{parentName:"p"},"beforeEach")," won't wait for them to finish executing. In other words, the ",(0,o.kt)("em",{parentName:"p"},"await")," commands defined inside of the ",(0,o.kt)("em",{parentName:"p"},"forEach")," loop are not in the ",(0,o.kt)("em",{parentName:"p"},"beforeEach")," function, but in separate functions that ",(0,o.kt)("em",{parentName:"p"},"beforeEach")," will not wait for."),(0,o.kt)("p",null,"Since the execution of tests begins immediately after ",(0,o.kt)("em",{parentName:"p"},"beforeEach")," has finished executing, the execution of tests begins before the database state is initialized."),(0,o.kt)("p",null,"One way of fixing this is to wait for all of the asynchronous operations to finish executing with the ",(0,o.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all"},"Promise.all")," method:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"beforeEach(async () => {\n  await Note.deleteMany({})\n\n  const noteObjects = helper.initialNotes\n    .map(note => new Note(note))\n  const promiseArray = noteObjects.map(note => note.save())\n  await Promise.all(promiseArray)\n})\n")),(0,o.kt)("p",null,"The solution is quite advanced despite its compact appearance. The ",(0,o.kt)("em",{parentName:"p"},"noteObjects")," variable is assigned to an array of Mongoose objects that are created with the ",(0,o.kt)("em",{parentName:"p"},"Note")," constructor for each of the notes in the ",(0,o.kt)("em",{parentName:"p"},"helper.initialNotes")," array. The next line of code creates a new array that ",(0,o.kt)("i",null,"consists of promises"),", that are created by calling the ",(0,o.kt)("em",{parentName:"p"},"save")," method of each item in the ",(0,o.kt)("em",{parentName:"p"},"noteObjects")," array. In other words, it is an array of promises for saving each of the items to the database."),(0,o.kt)("p",null,"The ",(0,o.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all"},"Promise.all")," method can be used for transforming an array of promises into a single promise, that will be ",(0,o.kt)("i",null,"fulfilled")," once every promise in the array passed to it as a parameter is resolved. The last line of code ",(0,o.kt)("em",null,"await Promise.all(promiseArray)")," waits that every promise for saving a note is finished, meaning that the database has been initialized."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"The returned values of each promise in the array can still be accessed when using the Promise.all method. If we wait for the promises to be resolved with the ",(0,o.kt)("em",{parentName:"p"},"await")," syntax ",(0,o.kt)("em",null,"const results = await Promise.all(promiseArray)"),", the operation will return an array that contains the resolved values for each promise in the ",(0,o.kt)("em",{parentName:"p"},"promiseArray"),", and they appear in the same order as the promises in the array.")),(0,o.kt)("p",null,"Promise.all executes the promises it receives in parallel. If the promises need to be executed in a particular order, this will be problematic. In situations like this, the operations can be executed inside of a ",(0,o.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of"},"for...of")," block, that guarantees a specific execution order."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"beforeEach(async () => {\n  await Note.deleteMany({})\n\n  for (let note of helper.initialNotes) {\n    let noteObject = new Note(note)\n    await noteObject.save()\n  }\n})\n")),(0,o.kt)("p",null,"The asynchronous nature of JavaScript can lead to surprising behavior, and for this reason, it is important to pay careful attention when using the async/await syntax. Even though the syntax makes it easier to deal with promises, it is still necessary to understand how promises work!"),(0,o.kt)("p",null,"The code for our application can be found from ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/fullstack-hy/part3-notes-backend/tree/part4-5"},"github"),", branch ",(0,o.kt)("i",null,"part4-5"),"."),(0,o.kt)("h3",{id:"refactoring-tests"},"Refactoring tests"),(0,o.kt)("p",null,"Our test coverage is currently lacking. Some requests like ",(0,o.kt)("i",null,"GET /api/notes/:id")," and ",(0,o.kt)("i",null,"DELETE /api/notes/:id"),' aren\'t tested when the request is sent with an invalid id. The grouping and organization of tests could also use some improvement, as all tests exist on the same "top level" in the test file. The readability of the test would improve if we group related tests with ',(0,o.kt)("i",null,"describe")," blocks."),(0,o.kt)("p",null,"Below is an example of the test file after making some minor improvements:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const supertest = require('supertest')\nconst mongoose = require('mongoose')\nconst helper = require('./test_helper')\nconst app = require('../app')\nconst api = supertest(app)\n\nconst Note = require('../models/note')\n\nbeforeEach(async () => {\n  await Note.deleteMany({})\n  await Note.insertMany(helper.initialNotes)\n})\n\ndescribe('when there is initially some notes saved', () => {\n  test('notes are returned as json', async () => {\n    await api\n      .get('/api/notes')\n      .expect(200)\n      .expect('Content-Type', /application\\/json/)\n  })\n\n  test('all notes are returned', async () => {\n    const response = await api.get('/api/notes')\n\n    expect(response.body).toHaveLength(helper.initialNotes.length)\n  })\n\n  test('a specific note is within the returned notes', async () => {\n    const response = await api.get('/api/notes')\n\n    const contents = response.body.map(r => r.content)\n\n    expect(contents).toContain(\n      'Browser can execute only Javascript'\n    )\n  })\n})\n\ndescribe('viewing a specific note', () => {\n  test('succeeds with a valid id', async () => {\n    const notesAtStart = await helper.notesInDb()\n\n    const noteToView = notesAtStart[0]\n\n    const resultNote = await api\n      .get(`/api/notes/${noteToView.id}`)\n      .expect(200)\n      .expect('Content-Type', /application\\/json/)\n      \n    const processedNoteToView = JSON.parse(JSON.stringify(noteToView))\n\n    expect(resultNote.body).toEqual(processedNoteToView)\n  })\n\n  test('fails with statuscode 404 if note does not exist', async () => {\n    const validNonexistingId = await helper.nonExistingId()\n\n    console.log(validNonexistingId)\n\n    await api\n      .get(`/api/notes/${validNonexistingId}`)\n      .expect(404)\n  })\n\n  test('fails with statuscode 400 id is invalid', async () => {\n    const invalidId = '5a3d5da59070081a82a3445'\n\n    await api\n      .get(`/api/notes/${invalidId}`)\n      .expect(400)\n  })\n})\n\ndescribe('addition of a new note', () => {\n  test('succeeds with valid data', async () => {\n    const newNote = {\n      content: 'async/await simplifies making async calls',\n      important: true,\n    }\n\n    await api\n      .post('/api/notes')\n      .send(newNote)\n      .expect(201)\n      .expect('Content-Type', /application\\/json/)\n\n    const notesAtEnd = await helper.notesInDb()\n    expect(notesAtEnd).toHaveLength(helper.initialNotes.length + 1)\n\n    const contents = notesAtEnd.map(n => n.content)\n    expect(contents).toContain(\n      'async/await simplifies making async calls'\n    )\n  })\n\n  test('fails with status code 400 if data invaild', async () => {\n    const newNote = {\n      important: true\n    }\n\n    await api\n      .post('/api/notes')\n      .send(newNote)\n      .expect(400)\n\n    const notesAtEnd = await helper.notesInDb()\n\n    expect(notesAtEnd).toHaveLength(helper.initialNotes.length)\n  })\n})\n\ndescribe('deletion of a note', () => {\n  test('succeeds with status code 204 if id is valid', async () => {\n    const notesAtStart = await helper.notesInDb()\n    const noteToDelete = notesAtStart[0]\n\n    await api\n      .delete(`/api/notes/${noteToDelete.id}`)\n      .expect(204)\n\n    const notesAtEnd = await helper.notesInDb()\n\n    expect(notesAtEnd).toHaveLength(\n      helper.initialNotes.length - 1\n    )\n\n    const contents = notesAtEnd.map(r => r.content)\n\n    expect(contents).not.toContain(noteToDelete.content)\n  })\n})\n\nafterAll(() => {\n  mongoose.connection.close()\n})\n")),(0,o.kt)("p",null,"The test output is grouped according to the ",(0,o.kt)("i",null,"describe")," blocks:"),(0,o.kt)("p",null,(0,o.kt)("img",{loading:"lazy",src:n(1387).Z,width:"1576",height:"506"})),(0,o.kt)("p",null,"There is still room for improvement, but it is time to move forward."),(0,o.kt)("p",null,"This way of testing the API, by making HTTP requests and inspecting the database with Mongoose, is by no means the only nor the best way of conducting API-level integration tests for server applications. There is no universal best way of writing tests, as it all depends on the application being tested and available resources."),(0,o.kt)("p",null,"You can find the code for our current application in its entirety in the ",(0,o.kt)("i",null,"part4-6")," branch of ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/fullstack-hy2020/part3-notes-backend/tree/part4-6"},"this Github repository"),"."),(0,o.kt)("h2",{id:"testing-react-apps"},"Testing React apps"),(0,o.kt)("p",null,"There are many different ways of testing React applications. Let's take a look at them next."),(0,o.kt)("p",null,"Tests will be implemented with the same ",(0,o.kt)("a",{parentName:"p",href:"http://jestjs.io/"},"Jest")," testing library developed by Facebook that was used in the previous part. Jest is actually configured by default to applications created with create-react-app."),(0,o.kt)("p",null,"In addition to Jest, we also need another testing library that will help us render components for testing purposes. The current best option for this is ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/testing-library/react-testing-library"},"react-testing-library")," which has seen rapid growth in popularity in recent times."),(0,o.kt)("p",null,"Let's install the library with the command:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"npm install --save-dev @testing-library/react @testing-library/jest-dom\n")),(0,o.kt)("p",null,"We installed also ",(0,o.kt)("a",{parentName:"p",href:"https://testing-library.com/docs/ecosystem-jest-dom/"},"jest-dom")," that provides some nice Jest-related helper methods."),(0,o.kt)("p",null,"Let's first write tests for the component that is responsible for rendering a note:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const Note = ({ note, toggleImportance }) => {\n  const label = note.important\n    ? 'make not important'\n    : 'make important'\n\n  return (\n    <li className='note'> // highlight-line\n      {note.content}\n      <button onClick={toggleImportance}>{label}</button>\n    </li>\n  )\n}\n")),(0,o.kt)("p",null,"Notice that the ",(0,o.kt)("i",null,"li")," element has the ",(0,o.kt)("a",{parentName:"p",href:"https://reactjs.org/docs/dom-elements.html#classname"},"CSS")," classname ",(0,o.kt)("i",null,"note"),", that could be used to access the component in our tests."),(0,o.kt)("h3",{id:"rendering-the-component-for-tests"},"Rendering the component for tests"),(0,o.kt)("p",null,"We will write our test in the ",(0,o.kt)("i",null,"src/components/Note.test.js")," file, which is in the same directory as the component itself."),(0,o.kt)("p",null,"The first test verifies that the component renders the contents of the note:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"import React from 'react'\nimport '@testing-library/jest-dom/extend-expect'\nimport { render, screen } from '@testing-library/react'\nimport Note from './Note'\n\ntest('renders content', () => {\n  const note = {\n    content: 'Component testing is done with react-testing-library',\n    important: true\n  }\n\n  render(<Note note={note} />)\n\n  const element = screen.getByText('Component testing is done with react-testing-library')\n  expect(element).toBeDefined()\n})\n")),(0,o.kt)("p",null,"After the initial configuration, the test renders the component with the ",(0,o.kt)("a",{parentName:"p",href:"https://testing-library.com/docs/react-testing-library/api#render"},"render")," function provided by the react-testing-library:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"render(<Note note={note} />)\n")),(0,o.kt)("p",null,"Normally React components are rendered to the ",(0,o.kt)("i",null,"DOM"),". The render method we used renders the components in a format that is suitable for tests without rendering them to the DOM."),(0,o.kt)("p",null,"We can use the object ",(0,o.kt)("a",{parentName:"p",href:"https://testing-library.com/docs/queries/about#screen"},"screen")," to access the rendered component. We use screen's method ",(0,o.kt)("a",{parentName:"p",href:"https://testing-library.com/docs/queries/bytext"},"getByText")," to search for an element that has the note content and ensure that it exists:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"}," const element = screen.getByText('Component testing is done with react-testing-library')\n  expect(element).toBeDefined()\n")),(0,o.kt)("h3",{id:"running-tests"},"Running tests"),(0,o.kt)("p",null,"Create-react-app configures tests to be run in watch mode by default, which means that the ",(0,o.kt)("em",{parentName:"p"},"npm test")," command will not exit once the tests have finished, and will instead wait for changes to be made to the code. Once new changes to the code are saved, the tests are executed automatically after which Jest goes back to waiting for new changes to be made."),(0,o.kt)("p",null,'If you want to run tests "normally", you can do so with the command:'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"CI=true npm test\n")),(0,o.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,o.kt)("div",{parentName:"div",className:"admonition-heading"},(0,o.kt)("h5",{parentName:"div"},(0,o.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,o.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,o.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),(0,o.kt)("div",{parentName:"div",className:"admonition-content"},(0,o.kt)("p",{parentName:"div"},"the console may issue a warning if you have not installed Watchman. Watchman is an application developed by Facebook that watches for changes that are made to files. The program speeds up the execution of tests and at least starting from macOS Sierra, running tests in watch mode issues some warnings to the console, that can be removed by installing Watchman."),(0,o.kt)("p",{parentName:"div"},"Instructions for installing Watchman on different operating systems can be found on the official Watchman website: ",(0,o.kt)("a",{parentName:"p",href:"https://facebook.github.io/watchman/"},"https://facebook.github.io/watchman/")))),(0,o.kt)("h3",{id:"test-file-location"},"Test file location"),(0,o.kt)("p",null,"In React there are ",(0,o.kt)("a",{parentName:"p",href:"https://medium.com/@JeffLombardJr/organizing-tests-in-jest-17fc431ff850"},"two main conventions")," for the test file's location. We created our test files according to the current standard by placing them in the same directory as the component being tested."),(0,o.kt)("p",null,'The other convention is to store the test files "normally" in their own separate directory. Whichever convention we choose, it is almost guaranteed to be wrong according to someone\'s opinion.'),(0,o.kt)("p",null,"The reason we choose to  storing tests and application code in the same directory is that it is configured by default in applications created by create-react-app."),(0,o.kt)("h3",{id:"searching-for-content-in-a-component"},"Searching for content in a component"),(0,o.kt)("p",null,"The react-testing-library package offers many different ways of investigating the content of the component being tested. Actually the expect in our test is not needed at all"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"import React from 'react'\nimport '@testing-library/jest-dom/extend-expect'\nimport { render, screen } from '@testing-library/react'\nimport Note from './Note'\n\ntest('renders content', () => {\n  const note = {\n    content: 'Component testing is done with react-testing-library',\n    important: true\n  }\n\n  render(<Note note={note} />)\n\n  const element = screen.getByText('Component testing is done with react-testing-library')\n\n  expect(element).toBeDefined() // highlight-line\n})\n")),(0,o.kt)("p",null,"Text fails if ",(0,o.kt)("em",{parentName:"p"},"getByText")," does not find the element it is looking for."),(0,o.kt)("p",null,"We could also use ",(0,o.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors"},"CSS-selectors")," to find rendered elements by using the method ",(0,o.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelector"},"querySelector")," of the object ",(0,o.kt)("a",{parentName:"p",href:"https://testing-library.com/docs/react-testing-library/api/#containerr"},"container")," that is one of the fields returned by the render:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"import React from 'react'\nimport '@testing-library/jest-dom/extend-expect'\nimport { render, screen } from '@testing-library/react'\nimport Note from './Note'\n\ntest('renders content', () => {\n  const note = {\n    content: 'Component testing is done with react-testing-library',\n    important: true\n  }\n\n  const { container } = render(<Note note={note} />) // highlight-line\n\n// highlight-start\n  const div = container.querySelector('.note')\n  expect(div).toHaveTextContent(\n    'Component testing is done with react-testing-library'\n  )\n  // highlight-end\n})\n")),(0,o.kt)("p",null,"There are also other methods, eg. ",(0,o.kt)("a",{parentName:"p",href:"https://testing-library.com/docs/queries/bytestid/"},"getByTestId"),", that is looking for elements based on id-attributes that are inserted to the code specifically for testing purposes."),(0,o.kt)("h3",{id:"debugging-tests"},"Debugging tests"),(0,o.kt)("p",null,"We typically run into many different kinds of problems when writing our tests."),(0,o.kt)("p",null,"Object ",(0,o.kt)("em",{parentName:"p"},"screen")," has method ",(0,o.kt)("a",{parentName:"p",href:"https://testing-library.com/docs/queries/about/#screendebug"},"debug")," that can be used to print the HTML of a component to terminal. If we change the test as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"import React from 'react'\nimport '@testing-library/jest-dom/extend-expect'\nimport { render, screen } from '@testing-library/react'\nimport Note from './Note'\n\ntest('renders content', () => {\n  const note = {\n    content: 'Component testing is done with react-testing-library',\n    important: true\n  }\n\n  render(<Note note={note} />)\n\n  screen.debug() // highlight-line\n\n  // ...\n\n})\n")),(0,o.kt)("p",null,"the HTML gets printed to the console:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'console.log\n  <body>\n    <div>\n      <li\n        class="note"\n      >\n        Component testing is done with react-testing-library\n        <button>\n          make not important\n        </button>\n      </li>\n    </div>\n  </body>\n')),(0,o.kt)("p",null,"It is also possible to use the same method to print a wanted element to console:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"import React from 'react'\nimport '@testing-library/jest-dom/extend-expect'\nimport { render, screen } from '@testing-library/react'\nimport Note from './Note'\n\ntest('renders content', () => {\n  const note = {\n    content: 'Component testing is done with react-testing-library',\n    important: true\n  }\n\n  render(<Note note={note} />)\n\n  const element = screen.getByText('Component testing is done with react-testing-library')\n\n  screen.debug(element)  // highlight-line\n\n  expect(element).toBeDefined()\n})\n")),(0,o.kt)("p",null,"Now the HTML of the wanted element gets printed:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'  <li\n    class="note"\n  >\n    Component testing is done with react-testing-library\n    <button>\n      make not important\n    </button>\n  </li>\n')),(0,o.kt)("h3",{id:"clicking-buttons-in-tests"},"Clicking buttons in tests"),(0,o.kt)("p",null,"In addition to displaying content, the ",(0,o.kt)("i",null,"Note")," component also makes sure that when the button associated with the note is pressed, the ",(0,o.kt)("em",{parentName:"p"},"toggleImportance")," event handler function gets called."),(0,o.kt)("p",null,"Let us install a library ",(0,o.kt)("a",{parentName:"p",href:"https://testing-library.com/docs/ecosystem-user-event/"},"user-event")," that makes simulating user input a bit easier:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"npm install --save-dev @testing-library/user-event\n")),(0,o.kt)("p",null,"At the moment of writing (28.1.2022) there is a mismatch between the version of a dependency jest-watch-typeahead that create-react-appin and user-event are using. The problem is fixed by installing a spefic version:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"npm install -D --exact jest-watch-typeahead@0.6.5\n")),(0,o.kt)("p",null,"Testing this functionality can be accomplished like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"import React from 'react'\nimport '@testing-library/jest-dom/extend-expect'\nimport { render, screen } from '@testing-library/react'\nimport userEvent from '@testing-library/user-event' // highlight-line\nimport Note from './Note'\n\n// ...\n\ntest('clicking the button calls event handler once', async () => {\n  const note = {\n    content: 'Component testing is done with react-testing-library',\n    important: true\n  }\n\n  const mockHandler = jest.fn()\n\n  render(\n    <Note note={note} toggleImportance={mockHandler} />\n  )\n\n  const button = screen.getByText('make not important')\n  userEvent.click(button)\n\n  expect(mockHandler.mock.calls).toHaveLength(1)\n})\n")),(0,o.kt)("p",null,"There are a few interesting things related to this test. The event handler is a ",(0,o.kt)("a",{parentName:"p",href:"https://facebook.github.io/jest/docs/en/mock-functions.html"},"mock")," function defined with Jest:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const mockHandler = jest.fn()\n")),(0,o.kt)("p",null,"The test finds the button ",(0,o.kt)("i",null,"based on the text")," from the rendered component and clicks the element:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const button = screen.getByText('make not important')\nuserEvent.click(button)\n")),(0,o.kt)("p",null,"Clicking happens with the method ",(0,o.kt)("a",{parentName:"p",href:"https://testing-library.com/docs/ecosystem-user-event/#clickelement-eventinit-options"},"click")," of the userEvent-library."),(0,o.kt)("p",null,"The expectation of the test verifies that the ",(0,o.kt)("i",null,"mock function")," has been called exactly once."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"expect(mockHandler.mock.calls).toHaveLength(1)\n")),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Mock_object"},"Mock objects and functions")," are commonly used stub components in testing that are used for replacing dependencies of the components being tested. Mocks make it possible to return hardcoded responses, and to verify the number of times the mock functions are called and with what parameters."),(0,o.kt)("p",null,"In our example, the mock function is a perfect choice since it can be easily used for verifying that the method gets called exactly once."),(0,o.kt)("h3",{id:"tests-for-the-togglable-component"},"Tests for the ",(0,o.kt)("i",null,"Togglable")," component"),(0,o.kt)("p",null,"Let's write a few tests for the ",(0,o.kt)("i",null,"Togglable")," component. Let's add the ",(0,o.kt)("i",null,"togglableContent")," CSS classname to the div that returns the child components."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'const Togglable = forwardRef((props, ref) => {\n  // ...\n\n  return (\n    <div>\n      <div style={hideWhenVisible}>\n        <button onClick={toggleVisibility}>\n          {props.buttonLabel}\n        </button>\n      </div>\n      <div style={showWhenVisible} className="togglableContent"> // highlight-line\n        {props.children}\n        <button onClick={toggleVisibility}>cancel</button>\n      </div>\n    </div>\n  )\n})\n')),(0,o.kt)("p",null,"The tests are shown below:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"import React from 'react'\nimport '@testing-library/jest-dom/extend-expect'\nimport { render, screen } from '@testing-library/react'\nimport userEvent from '@testing-library/user-event'\nimport Togglable from './Togglable'\n\ndescribe('<Togglable />', () => {\n  let container\n\n  beforeEach(() => {\n    container = render(\n      <Togglable buttonLabel=\"show...\">\n        <div className=\"testDiv\" >\n          togglable content\n        </div>\n      </Togglable>\n    ).container\n  })\n\n  test('renders its children', () => {\n    screen.findAllByText('togglable content')\n  })\n\n  test('at start the children are not displayed', () => {\n    const div = container.querySelector('.togglableContent')\n    expect(div).toHaveStyle('display: none')\n  })\n\n  test('after clicking the button, children are displayed', () => {\n    const button = screen.getByText('show...')\n    userEvent.click(button)\n\n    const div = container.querySelector('.togglableContent')\n    expect(div).not.toHaveStyle('display: none')\n  })\n})\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("em",{parentName:"p"},"beforeEach")," function gets called before each test, which then renders the ",(0,o.kt)("i",null,"Togglable")," component and saves the field ",(0,o.kt)("em",{parentName:"p"},"container")," of the return value."),(0,o.kt)("p",null,"The first test verifies that the ",(0,o.kt)("i",null,"Togglable")," component renders its child component "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'<div className="testDiv" >\n  togglable content\n</div>\n')),(0,o.kt)("p",null,"The remaining tests use the ",(0,o.kt)("a",{parentName:"p",href:"https://www.npmjs.com/package/@testing-library/jest-dom#tohavestyle"},"toHaveStyle")," method to verify that the child component of the ",(0,o.kt)("i",null,"Togglable")," component is not visible initially, by checking that the style of the ",(0,o.kt)("i",null,"div")," element contains ",(0,o.kt)("em",{parentName:"p"},"{ display: 'none' }"),". Another test verifies that when the button is pressed the component is visible, meaning that the style for hiding the component ",(0,o.kt)("i",null,"is no longer")," assigned to the component."),(0,o.kt)("p",null,"Let's also add a test that can be used to verify that the visible content can be hidden by clicking the second button of the component:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"describe('<Togglable />', () => {\n\n  // ...\n\n  test('toggled content can be closed', () => {\n    const button = screen.getByText('show...')\n    userEvent.click(button)\n\n    const closeButton = screen.getByText('cancel')\n    userEvent.click(closeButton)\n\n    const div = container.querySelector('.togglableContent')\n    expect(div).toHaveStyle('display: none')\n  })\n})\n")),(0,o.kt)("h3",{id:"testing-the-forms"},"Testing the forms"),(0,o.kt)("p",null,"We already used the ",(0,o.kt)("em",{parentName:"p"},"click")," function of the ",(0,o.kt)("a",{parentName:"p",href:"https://testing-library.com/docs/ecosystem-user-event/"},"user-event")," in our previous tests to click buttons."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const button = screen.getByText('show...')\nuserEvent.click(button)\n")),(0,o.kt)("p",null,"We can also simulate text input with ",(0,o.kt)("i",null,"userEvent"),"."),(0,o.kt)("p",null,"Let's make a test for the ",(0,o.kt)("i",null,"NoteForm")," component. The code of the component is as follows."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"import { useState } from 'react'\n\nconst NoteForm = ({ createNote }) => {\n  const [newNote, setNewNote] = useState('')\n\n  const handleChange = (event) => {\n    setNewNote(event.target.value)\n  }\n\n  const addNote = (event) => {\n    event.preventDefault()\n    createNote({\n      content: newNote,\n      important: Math.random() > 0.5,\n    })\n\n    setNewNote('')\n  }\n\n  return (\n    <div className=\"formDiv\">\n      <h2>Create a new note</h2>\n\n      <form onSubmit={addNote}>\n        <input\n          value={newNote}\n          onChange={handleChange}\n        />\n        <button type=\"submit\">save</button>\n      </form>\n    </div>\n  )\n}\n\nexport default NoteForm\n")),(0,o.kt)("p",null,"The form works by calling the ",(0,o.kt)("em",{parentName:"p"},"createNote")," function it received as props with the details of the new note."),(0,o.kt)("p",null,"The test is as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"import React from 'react'\nimport { render, screen } from '@testing-library/react'\nimport '@testing-library/jest-dom/extend-expect'\nimport NoteForm from './NoteForm'\nimport userEvent from '@testing-library/user-event'\n\ntest('<NoteForm /> updates parent state and calls onSubmit', () => {\n  const createNote = jest.fn()\n\n  render(<NoteForm createNote={createNote} />)\n\n  const input = screen.getByRole('textbox')\n  const sendButton = screen.getByText('save')\n\n  userEvent.type(input, 'testing a form...' )\n  userEvent.click(sendButton)\n\n  expect(createNote.mock.calls).toHaveLength(1)\n  expect(createNote.mock.calls[0][0].content).toBe('testing a form...' )\n})\n")),(0,o.kt)("p",null,"Tests gets the access to the the input field using the function ",(0,o.kt)("a",{parentName:"p",href:"https://testing-library.com/docs/queries/byrole"},"getByRole"),". "),(0,o.kt)("p",null,"Method ",(0,o.kt)("a",{parentName:"p",href:"https://testing-library.com/docs/ecosystem-user-event/#typeelement-text-options"},"type")," of the userEvent is used to write text to the input field."),(0,o.kt)("p",null,"The first test expectation ensures, that submitting the form calls the ",(0,o.kt)("em",{parentName:"p"},"createNote")," method.\nThe second expectation checks, that the event handler is called with the right parameters - that a note with the correct content is created when the form is filled. "),(0,o.kt)("h3",{id:"about-finding-the-elements"},"About finding the elements"),(0,o.kt)("p",null,"Let us assume that the form would have two input fields"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'const NoteForm = ({ createNote }) => {\n  // ...\n\n  return (\n    <div>\n      <h2>Create a new note</h2>\n\n      <form onSubmit={addNote}>\n        <input\n          value={newNote}\n          onChange={handleChange}\n        />\n        // highlight-start\n        <input\n          value={...}\n          onChange={...}\n        />\n        // highlight-end\n        <button type="submit">save</button>\n      </form>\n    </div>\n  )\n}\n')),(0,o.kt)("p",null,"Now the approach that our test uses to find the input field"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const input = screen.getByRole('textbox')\n")),(0,o.kt)("p",null,"would cause an error:"),(0,o.kt)("p",null,(0,o.kt)("img",{loading:"lazy",src:n(3010).Z,width:"1116",height:"604"})),(0,o.kt)("p",null,"The error message suggests to use ",(0,o.kt)("i",null,"getAllByRole"),". Test could be fixed as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const inputs = screen.getAllByRole('textbox')\n\nuserEvent.type(input[0], 'testing a form...' )\n")),(0,o.kt)("p",null,"Method ",(0,o.kt)("i",null,"getAllByRole")," now returns an array and the right input field is the first element of the array. However, this approach is a bit suspicious since it relies on the order of the input fields."),(0,o.kt)("p",null,"Quite often input fileds have a ",(0,o.kt)("i",null,"placehoder")," text that hints user what kind of input is expected. Let us add a placeholder to our form:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const NoteForm = ({ createNote }) => {\n  // ...\n\n  return (\n    <div>\n      <h2>Create a new note</h2>\n\n      <form onSubmit={addNote}>\n        <input\n          value={newNote}\n          onChange={handleChange}\n          placeholder='write here note content' // highlight-line \n        />\n        <input\n          value={...}\n          onChange={...}\n        />    \n        <button type=\"submit\">save</button>\n      </form>\n    </div>\n  )\n}\n")),(0,o.kt)("p",null,"Now finding the right input field is easy with method ",(0,o.kt)("a",{parentName:"p",href:"https://testing-library.com/docs/queries/byplaceholdertext"},"getByPlaceholderText"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"test('<NoteForm /> updates parent state and calls onSubmit', () => {\n  const createNote = jest.fn()\n\n  render(<NoteForm createNote={createNote} />) \n\n  const input = screen.getByPlaceholderText('write here note content') // highlight-line \n  const sendButton = screen.getByText('save')\n\n  userEvent.type(input, 'testing a form...' )\n  userEvent.click(sendButton)\n\n  expect(createNote.mock.calls).toHaveLength(1)\n  expect(createNote.mock.calls[0][0].content).toBe('testing a form...' )\n})\n")),(0,o.kt)("p",null,"The most flexible way of finding elements in tests is the method ",(0,o.kt)("i",null,"querySelector")," of the ",(0,o.kt)("em",{parentName:"p"},"content")," object, that is returned by ",(0,o.kt)("em",{parentName:"p"},"render"),", as was mentioned earlier. Any CSS selector can be used with this method for searching elements in tests."),(0,o.kt)("p",null,"Consider eg. that we would define an unique ",(0,o.kt)("em",{parentName:"p"},"id")," to the input field:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const NoteForm = ({ createNote }) => {\n  // ...\n\n  return (\n    <div>\n      <h2>Create a new note</h2>\n\n      <form onSubmit={addNote}>\n        <input\n          value={newNote}\n          onChange={handleChange}\n          id='note-input' // highlight-line \n        />\n        <input\n          value={...}\n          onChange={...}\n        />    \n        <button type=\"submit\">save</button>\n      </form>\n    </div>\n  )\n}\n")),(0,o.kt)("p",null,"The input element could now be found in the test as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const { content } = render(<NoteForm createNote={createNote} />)\n\nconst input = content.querySelector('#note-input')\n")),(0,o.kt)("p",null,"However we shall stick to a approach using ",(0,o.kt)("em",{parentName:"p"},"getByPlaceholderText")," in the test. "),(0,o.kt)("p",null,"Let us look to couple of details before moving on. Let us assume that a component would render test to an HTML-element as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const Note = ({ note, toggleImportance }) => {\n  const label = note.important\n    ? 'make not important' : 'make important'\n\n  return (\n    <li className='note'>\n      Your awesome note: {note.content} // highlight-line\n      <button onClick={toggleImportance}>{label}</button>\n    </li>\n  )\n}\n\nexport default Note\n")),(0,o.kt)("p",null,"the ",(0,o.kt)("em",{parentName:"p"},"getByText")," command that the test uses does ",(0,o.kt)("i",null,"not")," find the element"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"test('renders content', () => {\n  const note = {\n    content: 'Does not work anymore :(',\n    important: true\n  }\n\n  render(<Note note={note} />)\n\n  const element = screen.getByText('Does not work anymore :(')\n\n  expect(element).toBeDefined()\n})\n")),(0,o.kt)("p",null,"Command ",(0,o.kt)("em",{parentName:"p"},"getByText")," looks for an element that has exactly the text that it has as parameter, and nothing more. If we want to look for element that ",(0,o.kt)("i",null,"contains")," the text, we could use a extra option:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const element = screenscreen.getByText(\n  'Does not work anymore :(', { exact: false }\n)\n")),(0,o.kt)("p",null,"or we could use the command ",(0,o.kt)("em",{parentName:"p"},"findByText"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const element = await screen.findByText('Does not work anymore :(')\n")),(0,o.kt)("p",null,"It is important to notice that unlike the othet ",(0,o.kt)("em",{parentName:"p"},"ByText")," commands, ",(0,o.kt)("em",{parentName:"p"},"findByText")," returns a promise!"),(0,o.kt)("p",null,"There are situation where yet another form of the command ",(0,o.kt)("em",{parentName:"p"},"queryByText")," is useful. The command returns the element but ",(0,o.kt)("i",null,"it does not cause an exception")," if the element is not found."),(0,o.kt)("p",null,"We could eg. use the command to ensure that something ",(0,o.kt)("i",null,"is not rendered")," to the component:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"test('renders no shit', () => {\n  const note = {\n    content: 'This is a reminder',\n    important: true\n  }\n\n  render(<Note note={note} />)\n\n  const element = screen.queryByText('do not want this shit to be rendered')\n  expect(element).toBeNull()\n})\n")),(0,o.kt)("h3",{id:"test-coverage"},"Test coverage"),(0,o.kt)("p",null,"We can easily find out the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/facebookincubator/create-react-app/blob/ed5c48c81b2139b4414810e1efe917e04c96ee8d/packages/react-scripts/template/README.md#coverage-reporting"},"coverage")," of our tests by running them with the command."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"CI=true npm test -- --coverage\n")),(0,o.kt)("p",null,(0,o.kt)("img",{loading:"lazy",src:n(5348).Z,width:"1570",height:"926"})),(0,o.kt)("p",null,"A quite primitive HTML report will be generated to the ",(0,o.kt)("i",null,"coverage/lcov-report")," directory.\nThe report will tell us the lines of untested code in each component:"),(0,o.kt)("p",null,(0,o.kt)("img",{loading:"lazy",src:n(4165).Z,width:"1542",height:"958"})),(0,o.kt)("p",null,"You can find the code for our current application in its entirety in the ",(0,o.kt)("i",null,"part5-8")," branch of ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/fullstack-hy/part2-notes/tree/part5-8"},"this GitHub repository"),"."),(0,o.kt)("h3",{id:"frontend-integration-tests"},"Frontend integration tests"),(0,o.kt)("p",null,"In the previous part of the course material, we wrote integration tests for the backend that tested its logic and connected the database through the API provided by the backend. When writing these tests, we made the conscious decision not to write unit tests, as the code for that backend is fairly simple, and it is likely that bugs in our application occur in more complicated scenarios than unit tests are well suited for."),(0,o.kt)("p",null,"So far all of our tests for the frontend have been unit tests that have validated the correct functioning of individual components. Unit testing is useful at times, but even a comprehensive suite of unit tests is not enough to validate that the application works as a whole."),(0,o.kt)("p",null,"We could also make integration tests for the frontend. Integration testing tests the collaboration of multiple components. It is considerably more difficult than unit testing, as we would have to for example mock data from the server.\nWe chose to concentrate on making end to end tests in order to test the whole application. We will work on the end to end tests in the last chapter of this part."),(0,o.kt)("h3",{id:"snapshot-testing"},"Snapshot testing"),(0,o.kt)("p",null,'Jest offers a completely different alternative to "traditional" testing called ',(0,o.kt)("a",{parentName:"p",href:"https://facebook.github.io/jest/docs/en/snapshot-testing.html"},"snapshot")," testing. The interesting feature of snapshot testing is that developers do not need to define any tests themselves, it is simply enough to adopt snapshot testing. "),(0,o.kt)("p",null,"The fundamental principle is to compare the HTML code defined by the component after it has changed to the HTML code that existed before it was changed."),(0,o.kt)("p",null,'If the snapshot notices some change in the HTML defined by the component, then either it is new functionality or a "bug" caused by accident. Snapshot tests notify the developer if the HTML code of the component changes. The developer has to tell Jest if the change was desired or undesired. If the change to the HTML code is unexpected, it strongly implies a bug, and the developer can become aware of these potential issues easily thanks to snapshot testing.'),(0,o.kt)("h2",{id:"end-to-end--testing"},"End to end -testing"),(0,o.kt)("p",null,"So far we have tested the backend as a whole on an API level using integration tests, and tested some frontend components using unit tests."),(0,o.kt)("p",null,"Next we will look into one way to test the ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/System_testing"},"system as a whole")," using ",(0,o.kt)("i",null,"End to End")," (E2E) tests."),(0,o.kt)("p",null,"We can do E2E testing of a web application using a browser and a testing library. There are multiple libraries available, for example ",(0,o.kt)("a",{parentName:"p",href:"http://www.seleniumhq.org/"},"Selenium")," which can be used with almost any browser.\nAnother browser option are so called ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Headless_browser"},"headless browsers"),", which are browsers with no graphical user interface.\nFor example Chrome can be used in Headless-mode. "),(0,o.kt)("p",null,"E2E tests are potentially the most useful category of tests, because they test the system through the same interface as real users use. "),(0,o.kt)("p",null,"They do have some drawbacks too. Configuring E2E tests is more challenging than unit or integration tests. They also tend to be quite slow, and with a large system their execution time can be minutes, even hours. This is bad for development, because during coding it is beneficial to be able to run tests as often as possible in case of code ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Regression_testing"},"regressions"),"."),(0,o.kt)("p",null,"E2E tests can also be ",(0,o.kt)("a",{parentName:"p",href:"https://hackernoon.com/flaky-tests-a-war-that-never-ends-9aa32fdef359"},"flaky"),".\nSome tests might pass one time and fail another, even if the code does not change at all. "),(0,o.kt)("h3",{id:"cypress"},"Cypress"),(0,o.kt)("p",null,"E2E library ",(0,o.kt)("a",{parentName:"p",href:"https://www.cypress.io/"},"Cypress")," has become popular within the last year. Cypress is exceptionally easy to use, and when compared to Selenium, for example, it requires a lot less hassle and headache.\nIts operating principle is radically different than most E2E testing libraries, because Cypress tests are run completely within the browser.\nOther libraries run the tests in a Node-process, which is connected to the browser through an API. "),(0,o.kt)("p",null,"Let's  make some end to end tests for our note application."),(0,o.kt)("p",null,"We begin by installing Cypress to ",(0,o.kt)("i",null,"the frontend")," as development dependency"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"npm install --save-dev cypress\n")),(0,o.kt)("p",null,"and by adding an npm-script to run it:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'{\n  // ...\n  "scripts": {\n    "start": "react-scripts start",\n    "build": "react-scripts build",\n    "test": "react-scripts test",\n    "eject": "react-scripts eject",\n    "server": "json-server -p3001 db.json",\n    "cypress:open": "cypress open"  // highlight-line\n  },\n  // ...\n}\n')),(0,o.kt)("p",null,"Unlike the frontend's unit tests, Cypress tests can be in the frontend or the backend repository, or even in their own separate repository. "),(0,o.kt)("p",null,"The tests require the tested system to be running. Unlike our backend integration tests, Cypress tests ",(0,o.kt)("i",null,"do not start")," the system when they are run. "),(0,o.kt)("p",null,"Let's add an npm-script to ",(0,o.kt)("i",null,"the backend")," which starts it in test mode, or so that ",(0,o.kt)("i",null,"NODE","_","ENV")," is ",(0,o.kt)("i",null,"test"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'{\n  // ...\n  "scripts": {\n    "start": "cross-env NODE_ENV=production node index.js",\n    "dev": "cross-env NODE_ENV=development nodemon index.js",\n    "build:ui": "rm -rf build && cd ../../../2/luento/notes && npm run build && cp -r build ../../../3/luento/notes-backend",\n    "deploy": "git push heroku master",\n    "deploy:full": "npm run build:ui && git add . && git commit -m uibuild && git push && npm run deploy",\n    "logs:prod": "heroku logs --tail",\n    "lint": "eslint .",\n    "test": "cross-env NODE_ENV=test jest --verbose --runInBand",\n    "start:test": "cross-env NODE_ENV=test node index.js" // highlight-line\n  },\n  // ...\n}\n')),(0,o.kt)("p",null,"NB! In order to get Cypress working with WSL2 one might need to do some additional configuring first. These two ",(0,o.kt)("a",{parentName:"p",href:"https://docs.cypress.io/guides/getting-started/installing-cypress#Windows-Subsystem-for-Linux"},"links")," are great places to ",(0,o.kt)("a",{parentName:"p",href:"https://nickymeuleman.netlify.app/blog/gui-on-wsl2-cypress"},"start"),"."),(0,o.kt)("p",null,"When both backend and frontend are running, we can start Cypress with the command"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"npm run cypress:open\n")),(0,o.kt)("p",null,"When we first run Cypress, it creates a ",(0,o.kt)("i",null,"cypress")," directory. It contains an ",(0,o.kt)("i",null,"integration")," subdirectory, where we will place our tests. Cypress creates a bunch of example tests for us in two subdirectories: the ",(0,o.kt)("i",null,"integration/1-getting-started")," and the ",(0,o.kt)("i",null,"integration/2-advanced-examples")," directory. We can delete both directories and make our own test in file ",(0,o.kt)("i",null,"note","_","app.spec.js"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"describe('Note app', function() {\n  it('front page can be opened', function() {\n    cy.visit('http://localhost:3000')\n    cy.contains('Notes')\n    cy.contains('Note app, Department of Computer Science, University of Helsinki 2022')\n  })\n})\n")),(0,o.kt)("p",null,"We start the test from the opened window:"),(0,o.kt)("p",null,(0,o.kt)("img",{loading:"lazy",src:n(4967).Z,width:"1588",height:"682"})),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"NOTE"),": you might need to restart Cypress after deleting the example tests."),(0,o.kt)("p",null,"Running the test opens your browser and shows how the application behaves as the test is run:"),(0,o.kt)("p",null,(0,o.kt)("img",{loading:"lazy",src:n(7534).Z,width:"1922",height:"860"})),(0,o.kt)("p",null,"The structure of the test should look familiar. They use ",(0,o.kt)("i",null,"describe")," blocks to group different test cases like Jest does. The test cases have been defined with the ",(0,o.kt)("i",null,"it")," method.\nCypress borrowed these parts from the ",(0,o.kt)("a",{parentName:"p",href:"https://mochajs.org/"},"Mocha")," testing library it uses under the hood. "),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://docs.cypress.io/api/commands/visit.html"},"cy.visit")," and ",(0,o.kt)("a",{parentName:"p",href:"https://docs.cypress.io/api/commands/contains.html"},"cy.contains")," are Cypress commands, and their purpose is quite obvious.\n",(0,o.kt)("a",{parentName:"p",href:"https://docs.cypress.io/api/commands/visit.html"},"cy.visit")," opens the web address given to it as a parameter in the browser used by the test. ",(0,o.kt)("a",{parentName:"p",href:"https://docs.cypress.io/api/commands/contains.html"},"cy.contains")," searches for the string it received as a parameter from the page. "),(0,o.kt)("p",null,"We could have declared the test using an arrow function"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"describe('Note app', () => { // highlight-line\n  it('front page can be opened', () => { // highlight-line\n    cy.visit('http://localhost:3000')\n    cy.contains('Notes')\n    cy.contains('Note app, Department of Computer Science, University of Helsinki 2022')\n  })\n})\n")),(0,o.kt)("p",null,"However, Mocha ",(0,o.kt)("a",{parentName:"p",href:"https://mochajs.org/#arrow-functions"},"recommends")," that arrow functions are not used, because they might cause some issues in certain situations. "),(0,o.kt)("p",null,"If ",(0,o.kt)("i",null,"cy.contains")," does not find the text it is searching for, the test does not pass.  So if we extend our test like so"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"describe('Note app', function() {\n  it('front page can be opened',  function() {\n    cy.visit('http://localhost:3000')\n    cy.contains('Notes')\n    cy.contains('Note app, Department of Computer Science, University of Helsinki 2022')\n  })\n\n// highlight-start\n  it('front page contains random text', function() {\n    cy.visit('http://localhost:3000')\n    cy.contains('wtf is this app?')\n  })\n// highlight-end\n})\n")),(0,o.kt)("p",null,"the test fails"),(0,o.kt)("p",null,(0,o.kt)("img",{loading:"lazy",src:n(4884).Z,width:"1930",height:"1376"})),(0,o.kt)("p",null,"Let's remove the failing code from the test. "),(0,o.kt)("h3",{id:"writing-to-a-form"},"Writing to a form"),(0,o.kt)("p",null,"Let's extend our tests so that the test tries to log in to our application.\nWe assume our backend contains a user with the username ",(0,o.kt)("i",null,"mluukkai")," and password ",(0,o.kt)("i",null,"salainen"),"."),(0,o.kt)("p",null,"The test begins by opening the login form. "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"describe('Note app',  function() {\n  // ...\n\n  it('login form can be opened', function() {\n    cy.visit('http://localhost:3000')\n    cy.contains('login').click()\n  })\n})\n")),(0,o.kt)("p",null,"The test first searches for the login button by its text, and clicks the button with the command ",(0,o.kt)("a",{parentName:"p",href:"https://docs.cypress.io/api/commands/click.html#Syntax"},"cy.click"),"."),(0,o.kt)("p",null,"Both of our tests begin the same way, by opening the page ",(0,o.kt)("i",null,"http://localhost:3000"),", so we should\nseparate the shared part into a ",(0,o.kt)("i",null,"beforeEach")," block run before each test:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"describe('Note app', function() {\n  // highlight-start\n  beforeEach(function() {\n    cy.visit('http://localhost:3000')\n  })\n  // highlight-end\n\n  it('front page can be opened', function() {\n    cy.contains('Notes')\n    cy.contains('Note app, Department of Computer Science, University of Helsinki 2022')\n  })\n\n  it('login form can be opened', function() {\n    cy.contains('login').click()\n  })\n})\n")),(0,o.kt)("p",null,"The login field contains two ",(0,o.kt)("i",null,"input")," fields, which the test should write into. "),(0,o.kt)("p",null,"The ",(0,o.kt)("a",{parentName:"p",href:"https://docs.cypress.io/api/commands/get.html#Syntax"},"cy.get")," command allows for searching elements by CSS selectors. "),(0,o.kt)("p",null,"We can access the first and the last input field on the page, and write to them with the command ",(0,o.kt)("a",{parentName:"p",href:"https://docs.cypress.io/api/commands/type.html#Syntax"},"cy.type")," like so: "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"it('user can login', function () {\n  cy.contains('login').click()\n  cy.get('input:first').type('mluukkai')\n  cy.get('input:last').type('salainen')\n})  \n")),(0,o.kt)("p",null,"The test works. The problem is if we later add more input fields, the test will break because it expects the fields it needs to be the first and the last on the page. "),(0,o.kt)("p",null,"It would be better to give our inputs unique ",(0,o.kt)("i",null,"ids")," and use those to find them.\nWe change our login form like so:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'const LoginForm = ({ ... }) => {\n  return (\n    <div>\n      <h2>Login</h2>\n      <form onSubmit={handleSubmit}>\n        <div>\n          username\n          <input\n            id=\'username\'  // highlight-line\n            value={username}\n            onChange={handleUsernameChange}\n          />\n        </div>\n        <div>\n          password\n          <input\n            id=\'password\' // highlight-line\n            type="password"\n            value={password}\n            onChange={handlePasswordChange}\n          />\n        </div>\n        <button id="login-button" type="submit"> // highlight-line\n          login\n        </button>\n      </form>\n    </div>\n  )\n}\n')),(0,o.kt)("p",null,"We also added an id to our submit button so we can access it in our tests. "),(0,o.kt)("p",null,"The test becomes:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"describe('Note app',  function() {\n  // ..\n  it('user can log in', function() {\n    cy.contains('login').click()\n    cy.get('#username').type('mluukkai')  // highlight-line    \n    cy.get('#password').type('salainen')  // highlight-line\n    cy.get('#login-button').click()  // highlight-line\n\n    cy.contains('Matti Luukkainen logged in') // highlight-line\n  })\n})\n")),(0,o.kt)("p",null,"The last row ensures that the login was successful. "),(0,o.kt)("p",null,"Note that the CSS ",(0,o.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/ID_selectors"},"id-selector")," is #, so if we want to search for an element with the id ",(0,o.kt)("i",null,"username")," the CSS selector is ",(0,o.kt)("i",null,"#username"),"."),(0,o.kt)("h3",{id:"some-things-to-note"},"Some things to note"),(0,o.kt)("p",null,"The test first clicks the button opening the login form like so"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"cy.contains('login').click()\n")),(0,o.kt)("p",null,"When the form has been filled, the form is submitted by clicking the submit button"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"cy.get('#login-button').click()\n")),(0,o.kt)("p",null,"Both buttons have the text ",(0,o.kt)("i",null,"login"),", but they are two separate buttons.\nActually both buttons are in the application's DOM the whole time, but only one is visible at a time because of the ",(0,o.kt)("i",null,"display:none")," styling on one of them."),(0,o.kt)("p",null,"If we search for a button by its text, ",(0,o.kt)("a",{parentName:"p",href:"https://docs.cypress.io/api/commands/contains.html#Syntax"},"cy.contains")," will return the first of them, or the one opening the login form.\nThis will happen even if the button is not visible.\nTo avoid name conflicts, we gave the submit button the id ",(0,o.kt)("i",null,"login-button")," we can use to access it."),(0,o.kt)("p",null,"Now we notice that the variable ",(0,o.kt)("em",{parentName:"p"},"cy")," our tests use gives us a nasty Eslint error"),(0,o.kt)("p",null,(0,o.kt)("img",{loading:"lazy",src:n(3960).Z,width:"1430",height:"416"})),(0,o.kt)("p",null,"We can get rid of it by installing ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/cypress-io/eslint-plugin-cypress"},"eslint-plugin-cypress")," as a development dependency"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"npm install eslint-plugin-cypress --save-dev\n")),(0,o.kt)("p",null,"and changing the configuration in ",(0,o.kt)("i",null,".eslintrc.js")," like so:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'module.exports = {\n    "env": {\n        "browser": true,\n        "es6": true,\n        "jest/globals": true,\n        "cypress/globals": true // highlight-line\n    },\n    "extends": [ \n      // ...\n    ],\n    "parserOptions": {\n      // ...\n    },\n    "plugins": [\n        "react", "jest", "cypress" // highlight-line\n    ],\n    "rules": {\n      // ...\n    }\n}\n')),(0,o.kt)("h3",{id:"testing-new-note-form"},"Testing new note form"),(0,o.kt)("p",null,'Let\'s next add tests which test the "new note" functionality: '),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"describe('Note app', function() {\n  // ..\n  // highlight-start\n  describe('when logged in', function() {\n    beforeEach(function() {\n      cy.contains('login').click()\n      cy.get('input:first').type('mluukkai')\n      cy.get('input:last').type('salainen')\n      cy.get('#login-button').click()\n    })\n    // highlight-end\n\n    // highlight-start\n    it('a new note can be created', function() {\n      cy.contains('new note').click()\n      cy.get('input').type('a note created by cypress')\n      cy.contains('save').click()\n\n      cy.contains('a note created by cypress')\n    })\n  })\n  // highlight-end\n})\n")),(0,o.kt)("p",null,"The test has been defined in its own ",(0,o.kt)("i",null,"describe")," block.\nOnly logged-in users can create new notes, so we added logging in to the application to a ",(0,o.kt)("i",null,"beforeEach")," block. "),(0,o.kt)("p",null,"The test trusts that when creating a new note the page contains only one input, so it searches for it like so:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"cy.get('input')\n")),(0,o.kt)("p",null,"If the page contained more inputs, the test would break"),(0,o.kt)("p",null,(0,o.kt)("img",{loading:"lazy",src:n(9802).Z,width:"1640",height:"950"})),(0,o.kt)("p",null,"Due to this it would again be better to give the input an ",(0,o.kt)("i",null,"id")," and search for the element by its id. "),(0,o.kt)("p",null,"The structure of the tests looks like so:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"describe('Note app', function() {\n  // ...\n\n  it('user can log in', function() {\n    cy.contains('login').click()\n    cy.get('#username').type('mluukkai')\n    cy.get('#password').type('salainen')\n    cy.get('#login-button').click()\n\n    cy.contains('Matti Luukkainen logged in')\n  })\n\n  describe('when logged in', function() {\n    beforeEach(function() {\n      cy.contains('login').click()\n      cy.get('input:first').type('mluukkai')\n      cy.get('input:last').type('salainen')\n      cy.get('#login-button').click()\n    })\n\n    it('a new note can be created', function() {\n      // ...\n    })\n  })\n})\n")),(0,o.kt)("p",null,"Cypress runs the tests in the order they are in the code. So first it runs ",(0,o.kt)("i",null,"user can log in"),", where the user logs in. Then cypress will run ",(0,o.kt)("i",null,"a new note can be created")," for which a ",(0,o.kt)("i",null,"beforeEach")," block logs in as well.\nWhy do this? Isn't the user logged in after the first test?\nNo, because ",(0,o.kt)("i",null,"each")," test starts from zero as far as the browser is concerned.\nAll changes to the browser's state are reversed after each test."),(0,o.kt)("h3",{id:"controlling-the-state-of-the-database"},"Controlling the state of the database"),(0,o.kt)("p",null,"If the tests need to be able to modify the server's database, the situation immediately becomes more complicated. Ideally, the server's database should be the same each time we run the tests, so our tests can be reliably and easily repeatable. "),(0,o.kt)("p",null,"As with unit and integration tests, with E2E tests it is the best to empty the database and possibly format it before the tests are run. The challenge with E2E tests is that they do not have access to the database. "),(0,o.kt)("p",null,"The solution is to create API endpoints to the backend for the test.\nWe can empty the database using these endpoints.\nLet's create a new ",(0,o.kt)("i",null,"router")," for the tests"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const router = require('express').Router()\nconst Note = require('../models/note')\nconst User = require('../models/user')\n\nrouter.post('/reset', async (request, response) => {\n  await Note.deleteMany({})\n  await User.deleteMany({})\n\n  response.status(204).end()\n})\n\nmodule.exports = router\n")),(0,o.kt)("p",null,"and add it to the backend only ",(0,o.kt)("i",null,"if the application is run on test-mode"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"// ...\n\napp.use('/api/login', loginRouter)\napp.use('/api/users', usersRouter)\napp.use('/api/notes', notesRouter)\n\n// highlight-start\nif (process.env.NODE_ENV === 'test') {\n  const testingRouter = require('./controllers/testing')\n  app.use('/api/testing', testingRouter)\n}\n// highlight-end\n\napp.use(middleware.unknownEndpoint)\napp.use(middleware.errorHandler)\n\nmodule.exports = app\n")),(0,o.kt)("p",null,"After the changes, an HTTP POST request to the ",(0,o.kt)("i",null,"/api/testing/reset")," endpoint empties the database. Make sure your backend is running in test mode by starting it with this command (previously configured in the package.json file):"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"  npm run start:test\n")),(0,o.kt)("p",null,"The modified backend code can be found from ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/fullstack-hy/part3-notes-backend/tree/part5-1"},"GitHub")," branch ",(0,o.kt)("i",null,"part5-1"),"."),(0,o.kt)("p",null,"Next we will change the ",(0,o.kt)("i",null,"beforeEach")," block so that it empties the server's database before tests are run. "),(0,o.kt)("p",null,"Currently it is not possible to add new users through the frontend's UI, so we add a new user to the backend from the beforeEach block. "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"describe('Note app', function() {\n   beforeEach(function() {\n    // highlight-start\n    cy.request('POST', 'http://localhost:3001/api/testing/reset')\n    const user = {\n      name: 'Matti Luukkainen',\n      username: 'mluukkai',\n      password: 'salainen'\n    }\n    cy.request('POST', 'http://localhost:3001/api/users/', user) \n    // highlight-end\n    cy.visit('http://localhost:3000')\n  })\n  \n  it('front page can be opened', function() {\n    // ...\n  })\n\n  it('user can login', function() {\n    // ...\n  })\n\n  describe('when logged in', function() {\n    // ...\n  })\n})\n")),(0,o.kt)("p",null,"During the formatting the test does HTTP requests to the backend with ",(0,o.kt)("a",{parentName:"p",href:"https://docs.cypress.io/api/commands/request.html"},"cy.request"),"."),(0,o.kt)("p",null,"Unlike earlier, now the testing starts with the backend in the same state every time. The backend will contain one user and no notes. "),(0,o.kt)("p",null,"Let's add one more test for checking that we can change the importance of notes.\nFirst we change the frontend so that a new note is unimportant by default, or the ",(0,o.kt)("i",null,"important")," field is ",(0,o.kt)("i",null,"false"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const NoteForm = ({ createNote }) => {\n  // ...\n\n  const addNote = (event) => {\n    event.preventDefault()\n    createNote({\n      content: newNote,\n      important: false // highlight-line\n    })\n\n    setNewNote('')\n  }\n  // ...\n} \n")),(0,o.kt)("p",null,"There are multiple ways to test this. In the following example we first search for a note and click its ",(0,o.kt)("i",null,"make important")," button. Then we check that the note now contains a ",(0,o.kt)("i",null,"make not important")," button. "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"describe('Note app', function() {\n  // ...\n\n  describe('when logged in', function() {\n    // ...\n\n    describe('and a note exists', function () {\n      beforeEach(function () {\n        cy.contains('new note').click()\n        cy.get('input').type('another note cypress')\n        cy.contains('save').click()\n      })\n\n      it('it can be made important', function () {\n        cy.contains('another note cypress')\n          .contains('make important')\n          .click()\n\n        cy.contains('another note cypress')\n          .contains('make not important')\n      })\n    })\n  })\n})\n")),(0,o.kt)("p",null,"The first command searches for a component containing the text ",(0,o.kt)("i",null,"another note cypress"),", and then for a ",(0,o.kt)("i",null,"make important")," button within it. It then clicks the button."),(0,o.kt)("p",null,"The second command checks that the text on the button has changed to ",(0,o.kt)("i",null,"make not important"),"."),(0,o.kt)("p",null,"The tests and the current frontend code can be found from ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/fullstack-hy/part2-notes/tree/part5-9"},"GitHub")," branch ",(0,o.kt)("i",null,"part5-9"),"."),(0,o.kt)("h3",{id:"failed-login-test"},"Failed login test"),(0,o.kt)("p",null,"Let's make a test to ensure that a login attempt fails if the password is wrong. "),(0,o.kt)("p",null,"Cypress will run all tests each time by default, and as the number of tests increases it starts to become quite time-consuming.\nWhen developing a new test or when debugging a broken test, we can define the test with ",(0,o.kt)("i",null,"it.only")," instead of ",(0,o.kt)("i",null,"it"),", so that Cypress will only run the required test.\nWhen the test is working, we can remove ",(0,o.kt)("i",null,".only"),"."),(0,o.kt)("p",null,"First  version of our tests is as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"describe('Note app', function() {\n  // ...\n\n  it.only('login fails with wrong password', function() {\n    cy.contains('login').click()\n    cy.get('#username').type('mluukkai')\n    cy.get('#password').type('wrong')\n    cy.get('#login-button').click()\n\n    cy.contains('wrong credentials')\n  })\n\n  // ...\n)}\n")),(0,o.kt)("p",null,"The test uses ",(0,o.kt)("a",{parentName:"p",href:"https://docs.cypress.io/api/commands/contains.html#Syntax"},"cy.contains")," to ensure that the application prints an error message. "),(0,o.kt)("p",null,"The application renders the error message to a component with the CSS class ",(0,o.kt)("i",null,"error"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'const Notification = ({ message }) => {\n  if (message === null) {\n    return null\n  }\n\n  return (\n    <div className="error"> // highlight-line\n      {message}\n    </div>\n  )\n}\n')),(0,o.kt)("p",null,"We could make the test ensure that the error message is rendered to the correct component, that is, the component with the CSS class ",(0,o.kt)("i",null,"error"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"it('login fails with wrong password', function() {\n  // ...\n\n  cy.get('.error').contains('wrong credentials') // highlight-line\n})\n")),(0,o.kt)("p",null,"First we use ",(0,o.kt)("a",{parentName:"p",href:"https://docs.cypress.io/api/commands/get.html#Syntax"},"cy.get")," to search for a component with the CSS class ",(0,o.kt)("i",null,"error"),". Then we check that the error message can be found from this component.\nNote that the ",(0,o.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/Class_selectors"},"CSS class selector")," starts with a full stop, so the selector for the class ",(0,o.kt)("i",null,"error")," is ",(0,o.kt)("i",null,".error"),"."),(0,o.kt)("p",null,"We could do the same using the ",(0,o.kt)("a",{parentName:"p",href:"https://docs.cypress.io/api/commands/should.html"},"should")," syntax:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"it('login fails with wrong password', function() {\n  // ...\n\n  cy.get('.error').should('contain', 'wrong credentials') // highlight-line\n})\n")),(0,o.kt)("p",null,"Using should is a bit trickier than using ",(0,o.kt)("i",null,"contains"),", but it allows for more diverse tests than ",(0,o.kt)("i",null,"contains")," which works based on text content only. "),(0,o.kt)("p",null,"A list of the most common assertions which can be used with should can be found ",(0,o.kt)("a",{parentName:"p",href:"https://docs.cypress.io/guides/references/assertions.html#Common-Assertions"},"here"),"."),(0,o.kt)("p",null,"We can, for example, make sure that the error message is red and it has a border:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"it('login fails with wrong password', function() {\n  // ...\n\n  cy.get('.error').should('contain', 'wrong credentials') \n  cy.get('.error').should('have.css', 'color', 'rgb(255, 0, 0)')\n  cy.get('.error').should('have.css', 'border-style', 'solid')\n})\n")),(0,o.kt)("p",null,"Cypress requires the colors to be given as ",(0,o.kt)("a",{parentName:"p",href:"https://rgbcolorcode.com/color/red"},"rgb"),"."),(0,o.kt)("p",null,"Because all tests are for the same component we accessed using ",(0,o.kt)("a",{parentName:"p",href:"https://docs.cypress.io/api/commands/get.html#Syntax"},"cy.get"),", we can chain them using ",(0,o.kt)("a",{parentName:"p",href:"https://docs.cypress.io/api/commands/and.html"},"and"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"it('login fails with wrong password', function() {\n  // ...\n\n  cy.get('.error')\n    .should('contain', 'wrong credentials')\n    .and('have.css', 'color', 'rgb(255, 0, 0)')\n    .and('have.css', 'border-style', 'solid')\n})\n")),(0,o.kt)("p",null,"Let's finish the test so that it also checks that the application does not render the success message ",(0,o.kt)("i",null,"'Matti Luukkainen logged in'"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"it('login fails with wrong password', function() {\n  cy.contains('login').click()\n  cy.get('#username').type('mluukkai')\n  cy.get('#password').type('wrong')\n  cy.get('#login-button').click()\n\n  cy.get('.error')\n    .should('contain', 'wrong credentials')\n    .and('have.css', 'color', 'rgb(255, 0, 0)')\n    .and('have.css', 'border-style', 'solid')\n\n  cy.get('html').should('not.contain', 'Matti Luukkainen logged in') // highlight-line\n})\n")),(0,o.kt)("i",null,"Should")," should always be chained with ",(0,o.kt)("i",null,"get")," (or another chainable command). We used ",(0,o.kt)("i",null,"cy.get('html')")," to access the whole visible content of the application.",(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"NOTE:")," Some CSS properties ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/cypress-io/cypress/issues/9349"},"behave differently on Firefox"),". If you run the tests with Firefox:"),(0,o.kt)("p",null,"  ",(0,o.kt)("img",{parentName:"p",src:"https://user-images.githubusercontent.com/4255997/119015927-0bdff800-b9a2-11eb-9234-bb46d72c0368.png",alt:"running"})),(0,o.kt)("p",null,"  then tests that involve, for example, ",(0,o.kt)("inlineCode",{parentName:"p"},"border-style"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"border-radius")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"padding"),", will pass in Chrome or Electron, but fail in Firefox:"),(0,o.kt)("p",null,"  ",(0,o.kt)("img",{parentName:"p",src:"https://user-images.githubusercontent.com/4255997/119016340-7b55e780-b9a2-11eb-82e0-bab0418244c0.png",alt:"borderstyle"})),(0,o.kt)("h3",{id:"bypassing-the-ui"},"Bypassing the UI"),(0,o.kt)("p",null,"Currently we have the following tests:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"describe('Note app', function() {\n  it('user can login', function() {\n    cy.contains('login').click()\n    cy.get('#username').type('mluukkai')\n    cy.get('#password').type('salainen')\n    cy.get('#login-button').click()\n\n    cy.contains('Matti Luukkainen logged in')\n  })\n\n  it('login fails with wrong password', function() {\n    // ...\n  })\n\n  describe('when logged in', function() {\n    beforeEach(function() {\n      cy.contains('login').click()\n      cy.get('input:first').type('mluukkai')\n      cy.get('input:last').type('salainen')\n      cy.get('#login-button').click()\n    })\n\n    it('a new note can be created', function() {\n      // ... \n    })\n   \n  })\n})\n")),(0,o.kt)("p",null,"First we test logging in. Then, in their own describe block, we have a bunch of tests which expect the user to be logged in. User is logged in in the ",(0,o.kt)("i",null,"beforeEach")," block. "),(0,o.kt)("p",null,"As we said above, each test starts from zero! Tests do not start from the state where the previous tests ended. "),(0,o.kt)("p",null,"The Cypress documentation gives us the following advice: ",(0,o.kt)("a",{parentName:"p",href:"https://docs.cypress.io/guides/getting-started/testing-your-app.html#Logging-in"},"Fully test the login flow \u2013 but only once!"),".\nSo instead of logging in a user using the form in the ",(0,o.kt)("i",null,"beforeEach")," block, Cypress recommends that we ",(0,o.kt)("a",{parentName:"p",href:"https://docs.cypress.io/guides/getting-started/testing-your-app.html#Bypassing-your-UI"},"bypass the UI")," and do an HTTP request to the backend to log in. The reason for this is that logging in with an HTTP request is much faster than filling a form. "),(0,o.kt)("p",null,"Our situation is a bit more complicated than in the example in the Cypress documentation, because when a user logs in, our application saves their details to the localStorage.\nHowever Cypress can handle that as well.\nThe code is the following"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"describe('when logged in', function() {\n  beforeEach(function() {\n    // highlight-start\n    cy.request('POST', 'http://localhost:3001/api/login', {\n      username: 'mluukkai', password: 'salainen'\n    }).then(response => {\n      localStorage.setItem('loggedNoteappUser', JSON.stringify(response.body))\n      cy.visit('http://localhost:3000')\n    })\n    // highlight-end\n  })\n\n  it('a new note can be created', function() {\n    // ...\n  })\n\n  // ...\n})\n")),(0,o.kt)("p",null,"We can access the response to a ",(0,o.kt)("a",{parentName:"p",href:"https://docs.cypress.io/api/commands/request.html"},"cy.request")," with the ",(0,o.kt)("em",{parentName:"p"},"then")," method.  Under the hood ",(0,o.kt)("i",null,"cy.request"),", like all Cypress commands, are ",(0,o.kt)("a",{parentName:"p",href:"https://docs.cypress.io/guides/core-concepts/introduction-to-cypress.html#Commands-Are-Promises"},"promises"),".\nThe callback function saves the details of a logged-in user to localStorage, and reloads the page.\nNow there is no difference to a user logging in with the login form. "),(0,o.kt)("p",null,"If and when we write new tests to our application, we have to use the login code in multiple places.\nWe should make it a ",(0,o.kt)("a",{parentName:"p",href:"https://docs.cypress.io/api/cypress-api/custom-commands.html"},"custom command"),"."),(0,o.kt)("p",null,"Custom commands are declared in ",(0,o.kt)("i",null,"cypress/support/commands.js"),".\nThe code for logging in is as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"Cypress.Commands.add('login', ({ username, password }) => {\n  cy.request('POST', 'http://localhost:3001/api/login', {\n    username, password\n  }).then(({ body }) => {\n    localStorage.setItem('loggedNoteappUser', JSON.stringify(body))\n    cy.visit('http://localhost:3000')\n  })\n})\n")),(0,o.kt)("p",null,"Using our custom command is easy, and our test becomes cleaner:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"describe('when logged in', function() {\n  beforeEach(function() {\n    // highlight-start\n    cy.login({ username: 'mluukkai', password: 'salainen' })\n    // highlight-end\n  })\n\n  it('a new note can be created', function() {\n    // ...\n  })\n\n  // ...\n})\n")),(0,o.kt)("p",null,"The same applies to creating a new note now that we think about it. We have a test which makes a new note using the form. We also make a new note in the ",(0,o.kt)("i",null,"beforeEach")," block of the test testing changing the importance of a note: "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"describe('Note app', function() {\n  // ...\n\n  describe('when logged in', function() {\n    it('a new note can be created', function() {\n      cy.contains('new note').click()\n      cy.get('input').type('a note created by cypress')\n      cy.contains('save').click()\n\n      cy.contains('a note created by cypress')\n    })\n\n    describe('and a note exists', function () {\n      beforeEach(function () {\n        cy.contains('new note').click()\n        cy.get('input').type('another note cypress')\n        cy.contains('save').click()\n      })\n\n      it('it can be made important', function () {\n        // ...\n      })\n    })\n  })\n})\n")),(0,o.kt)("p",null,"Let's make a new custom command for making a new note. The command will make a new note with an HTTP POST request: "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"Cypress.Commands.add('createNote', ({ content, important }) => {\n  cy.request({\n    url: 'http://localhost:3001/api/notes',\n    method: 'POST',\n    body: { content, important },\n    headers: {\n      'Authorization': `bearer ${JSON.parse(localStorage.getItem('loggedNoteappUser')).token}`\n    }\n  })\n\n  cy.visit('http://localhost:3000')\n})\n")),(0,o.kt)("p",null,"The command expects the user to be logged in and the user's details to be saved to localStorage. "),(0,o.kt)("p",null,"Now the formatting block becomes:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"describe('Note app', function() {\n  // ...\n\n  describe('when logged in', function() {\n    it('a new note can be created', function() {\n      // ...\n    })\n\n    describe('and a note exists', function () {\n      beforeEach(function () {\n        // highlight-start\n        cy.createNote({\n          content: 'another note cypress',\n          important: false\n        })\n        // highlight-end\n      })\n\n      it('it can be made important', function () {\n        // ...\n      })\n    })\n  })\n})\n")),(0,o.kt)("p",null,"The tests and the frontend code can be found from ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/fullstack-hy/part2-notes/tree/part5-10"},"GitHub")," branch ",(0,o.kt)("i",null,"part5-10"),"."),(0,o.kt)("h3",{id:"changing-the-importance-of-a-note"},"Changing the importance of a note"),(0,o.kt)("p",null,"Lastly let's take a look at the test we did for changing the importance of a note.\nFirst we'll change the formatting block so that it creates three notes instead of one:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"describe('when logged in', function() {\n  describe('and several notes exist', function () {\n    beforeEach(function () {\n      // highlight-start\n      cy.createNote({ content: 'first note', important: false })\n      cy.createNote({ content: 'second note', important: false })\n      cy.createNote({ content: 'third note', important: false })\n      // highlight-end\n    })\n\n    it('one of those can be made important', function () {\n      cy.contains('second note')\n        .contains('make important')\n        .click()\n\n      cy.contains('second note')\n        .contains('make not important')\n    })\n  })\n})\n")),(0,o.kt)("p",null,"How does the ",(0,o.kt)("a",{parentName:"p",href:"https://docs.cypress.io/api/commands/contains.html"},"cy.contains")," command actually work?"),(0,o.kt)("p",null,"When we click the ",(0,o.kt)("em",{parentName:"p"},"cy.contains('second note')")," command in Cypress ",(0,o.kt)("a",{parentName:"p",href:"https://docs.cypress.io/guides/core-concepts/test-runner.html"},"Test Runner"),", we see that the command searches for the element containing the text ",(0,o.kt)("i",null,"second note"),":"),(0,o.kt)("p",null,(0,o.kt)("img",{loading:"lazy",src:n(8201).Z,width:"1732",height:"1054"})),(0,o.kt)("p",null,"By clicking the next line ",(0,o.kt)("em",{parentName:"p"},".contains('make important')")," we see that the test uses\nthe 'make important' button corresponding to ",(0,o.kt)("i",null,"second note"),":"),(0,o.kt)("p",null,(0,o.kt)("img",{loading:"lazy",src:n(8768).Z,width:"1756",height:"1032"})),(0,o.kt)("p",null,"When chained, the second ",(0,o.kt)("i",null,"contains")," command ",(0,o.kt)("i",null,"continues")," the search from within the component found by the first command. "),(0,o.kt)("p",null,"If we had not chained the commands, and instead wrote:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"cy.contains('second note')\ncy.contains('make important').click()\n")),(0,o.kt)("p",null,"the result would have been totally different. The second line of the test would click the button of a wrong note:"),(0,o.kt)("p",null,(0,o.kt)("img",{loading:"lazy",src:n(82).Z,width:"1918",height:"1040"})),(0,o.kt)("p",null,"When coding tests, you should check in the test runner that the tests use the right components!"),(0,o.kt)("p",null,"Let's change the ",(0,o.kt)("em",{parentName:"p"},"Note")," component so that the text of the note is rendered to a ",(0,o.kt)("i",null,"span"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const Note = ({ note, toggleImportance }) => {\n  const label = note.important\n    ? 'make not important' : 'make important'\n\n  return (\n    <li className='note'>\n      <span>{note.content}</span> // highlight-line\n      <button onClick={toggleImportance}>{label}</button>\n    </li>\n  )\n}\n")),(0,o.kt)("p",null,"Our tests break! As the test runner reveals,  ",(0,o.kt)("em",{parentName:"p"},"cy.contains('second note')")," now returns the component containing the text, and the button is not in it. "),(0,o.kt)("p",null,(0,o.kt)("img",{loading:"lazy",src:n(9617).Z,width:"1876",height:"950"})),(0,o.kt)("p",null,"One way to fix this is the following:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"it('one of those can be made important', function () {\n  cy.contains('second note').parent().find('button').click()\n  cy.contains('second note').parent().find('button')\n    .should('contain', 'make not important')\n})\n")),(0,o.kt)("p",null,"In the first line, we use the ",(0,o.kt)("a",{parentName:"p",href:"https://docs.cypress.io/api/commands/parent.html"},"parent")," command to access the parent element of the element containing ",(0,o.kt)("i",null,"second note")," and find the button from within it.\nThen we click the button, and check that the text on it changes. "),(0,o.kt)("p",null,"Note that we use the command ",(0,o.kt)("a",{parentName:"p",href:"https://docs.cypress.io/api/commands/find.html#Syntax"},"find")," to search for the button. We cannot use ",(0,o.kt)("a",{parentName:"p",href:"https://docs.cypress.io/api/commands/get.html"},"cy.get")," here, because it always searches from the ",(0,o.kt)("i",null,"whole")," page and would return all 5 buttons on the page. "),(0,o.kt)("p",null,"Unfortunately, we have some copy-paste in the tests now, because the code for searching for the right button is always the same. "),(0,o.kt)("p",null,"In these kinds of situations, it is possible to use the ",(0,o.kt)("a",{parentName:"p",href:"https://docs.cypress.io/api/commands/as.html"},"as")," command:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"it('one of those can be made important', function () {\n  cy.contains('second note').parent().find('button').as('theButton')\n  cy.get('@theButton').click()\n  cy.get('@theButton').should('contain', 'make not important')\n})\n")),(0,o.kt)("p",null,"Now the first line finds the right button, and uses ",(0,o.kt)("i",null,"as")," to save it as ",(0,o.kt)("i",null,"theButton"),". The following lines can use the named element with ",(0,o.kt)("i",null,"cy.get('@theButton')"),"."),(0,o.kt)("h3",{id:"running-and-debugging-the-tests"},"Running and debugging the tests"),(0,o.kt)("p",null,"Finally, some notes on how Cypress works and debugging your tests."),(0,o.kt)("p",null,"The form of the Cypress tests gives the impression that the tests are normal JavaScript code, and we could for example try this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const button = cy.contains('login')\nbutton.click()\ndebugger() \ncy.contains('logout').click()\n")),(0,o.kt)("p",null,"This won't work however. When Cypress runs a test, it adds each ",(0,o.kt)("em",{parentName:"p"},"cy")," command to an execution queue.\nWhen the code of the test method has been executed, Cypress will execute each command in the queue one by one. "),(0,o.kt)("p",null,"Cypress commands always return ",(0,o.kt)("em",{parentName:"p"},"undefined"),", so ",(0,o.kt)("em",{parentName:"p"},"button.click()")," in the above code would cause an error. An attempt to start the debugger would not stop the code between executing the commands, but before any commands have been executed. "),(0,o.kt)("p",null,"Cypress commands are ",(0,o.kt)("i",null,"like promises"),", so if we want to access their return values, we have to do it using the ",(0,o.kt)("a",{parentName:"p",href:"https://docs.cypress.io/api/commands/then.html"},"then")," command.\nFor example, the following test would print the number of buttons in the application, and click the first button: "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"it('then example', function() {\n  cy.get('button').then( buttons => {\n    console.log('number of buttons', buttons.length)\n    cy.wrap(buttons[0]).click()\n  })\n})\n")),(0,o.kt)("p",null,"Stopping the test execution with the debugger is ",(0,o.kt)("a",{parentName:"p",href:"https://docs.cypress.io/api/commands/debug.html"},"possible"),". The debugger starts only if Cypress test runner's developer console is open. "),(0,o.kt)("p",null,"The developer console is all sorts of useful when debugging your tests.\nYou can see the HTTP requests done by the tests on the Network tab, and the console tab will show you information about your tests:"),(0,o.kt)("p",null,(0,o.kt)("img",{loading:"lazy",src:n(8367).Z,width:"1772",height:"1244"})),(0,o.kt)("p",null,"So far we have run our Cypress tests using the graphical test runner.\nIt is also possible to run them ",(0,o.kt)("a",{parentName:"p",href:"https://docs.cypress.io/guides/guides/command-line.html"},"from the command line"),". We just have to add an npm script for it:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'  "scripts": {\n    "start": "react-scripts start",\n    "build": "react-scripts build",\n    "test": "react-scripts test",\n    "eject": "react-scripts eject",\n    "server": "json-server -p3001 --watch db.json",\n    "cypress:open": "cypress open",\n    "test:e2e": "cypress run" // highlight-line\n  },\n')),(0,o.kt)("p",null,"Now we can run our tests from the command line with the command ",(0,o.kt)("i",null,"npm run test:e2e")),(0,o.kt)("p",null,(0,o.kt)("img",{loading:"lazy",src:n(4483).Z,width:"1146",height:"1282"})),(0,o.kt)("p",null,"Note that videos of the test execution will be saved to ",(0,o.kt)("i",null,"cypress/videos/"),", so you should probably git ignore this directory. "),(0,o.kt)("p",null,"The frontend and the test code can be found from ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/fullstack-hy/part2-notes/tree/part5-11"},"GitHub")," branch ",(0,o.kt)("i",null,"part5-11"),"."),(0,o.kt)("h2",{id:"reference"},"Reference"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://fullstackopen.com"},"FullStackOpen: Part 4A-4B, 5C-5D"))))}d.isMDXComponent=!0},6895:function(e,t,n){t.Z=n.p+"assets/images/1x-97b5348ed54508c6e215d04aa7fa57f5.png"},6501:function(e,t,n){t.Z=n.p+"assets/images/2x-197d205e539fd34c8f1119c1d71e8960.png"},6867:function(e,t,n){t.Z=n.p+"assets/images/3-34e21720e2b9339da67a96a851e6e32a.png"},7442:function(e,t,n){t.Z=n.p+"assets/images/4x-4dbca896a87753b2b69cfa6fb6ad959a.png"},1387:function(e,t,n){t.Z=n.p+"assets/images/7-54b9d19369058e802c7edb1679689593.png"},4376:function(e,t,n){t.Z=n.p+"assets/images/8-fc5b90c3bdcc257863b7689e037f7879.png"},5348:function(e,t,n){t.Z=n.p+"assets/images/18ea-ad52b0badb45da0b6a668834575a8818.png"},4165:function(e,t,n){t.Z=n.p+"assets/images/19ea-e901b0e0dd9ff06ef9cf5fd27ffdb3dc.png"},3960:function(e,t,n){t.Z=n.p+"assets/images/30ea-86dc5a7a5bb8054a6d8a8d7b032e0f39.png"},9802:function(e,t,n){t.Z=n.p+"assets/images/31x-cf3f561467d97d9a5e5875cbbadcb321.png"},7534:function(e,t,n){t.Z=n.p+"assets/images/32x-932be8fac61ec2beb4119b139f3314be.png"},4884:function(e,t,n){t.Z=n.p+"assets/images/33x-7834a3260a952da8e2757402650ef5d5.png"},8201:function(e,t,n){t.Z=n.p+"assets/images/34x-f5eee03c2f10ffb43da2bf0997471e65.png"},8768:function(e,t,n){t.Z=n.p+"assets/images/35x-83cb70272aec36fb5b83161537038e1a.png"},82:function(e,t,n){t.Z=n.p+"assets/images/36x-60bffc639309775a23a925d2ca1c26e3.png"},9617:function(e,t,n){t.Z=n.p+"assets/images/37x-c418a5534393fddf280b9fb55b85f489.png"},8367:function(e,t,n){t.Z=n.p+"assets/images/38ea-0adc605ab47818eb430ecbc358a41703.png"},4483:function(e,t,n){t.Z=n.p+"assets/images/39x-3ddc5bf978340f30bd7276741b0d6b8d.png"},3010:function(e,t,n){t.Z=n.p+"assets/images/40-93de2cc69d1cf3a5ef7c302b0ea54ef8.png"},4967:function(e,t,n){t.Z=n.p+"assets/images/40x-9d0d854fc7cb3fa3c0ef3fe7e4c9c17f.png"}}]);