"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[7447],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return d}});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var i=a.createContext({}),c=function(e){var t=a.useContext(i),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},u=function(e){var t=c(e.components);return a.createElement(i.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,l=e.originalType,i=e.parentName,u=r(e,["components","mdxType","originalType","parentName"]),h=c(n),d=o,m=h["".concat(i,".").concat(d)]||h[d]||p[d]||l;return n?a.createElement(m,s(s({ref:t},u),{},{components:n})):a.createElement(m,s({ref:t},u))}));function d(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var l=n.length,s=new Array(l);s[0]=h;var r={};for(var i in t)hasOwnProperty.call(t,i)&&(r[i]=t[i]);r.originalType=e,r.mdxType="string"==typeof e?e:o,s[1]=r;for(var c=2;c<l;c++)s[c]=n[c];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},5414:function(e,t,n){n.r(t),n.d(t,{assets:function(){return u},contentTitle:function(){return i},default:function(){return d},frontMatter:function(){return r},metadata:function(){return c},toc:function(){return p}});var a=n(7462),o=n(3366),l=(n(7294),n(3905)),s=["components"],r={title:"Post Lecture Reading",sidebar_label:"Post Lecture",pagination_next:null,pagination_prev:null,hide_table_of_contents:!1,sidebar_position:5},i="After Lecture",c={unversionedId:"lecture-07/post-lecture",id:"lecture-07/post-lecture",title:"Post Lecture Reading",description:"Recommended videos",source:"@site/docs/lecture-07/post-lecture.md",sourceDirName:"lecture-07",slug:"/lecture-07/post-lecture",permalink:"/sp2022/lecture-07/post-lecture",tags:[],version:"current",sidebarPosition:5,frontMatter:{title:"Post Lecture Reading",sidebar_label:"Post Lecture",pagination_next:null,pagination_prev:null,hide_table_of_contents:!1,sidebar_position:5},sidebar:"docs"},u={},p=[{value:"Recommended videos",id:"recommended-videos",level:2},{value:"Component state, event handlers",id:"component-state-event-handlers",level:2},{value:"Component helper functions",id:"component-helper-functions",level:3},{value:"Destructuring",id:"destructuring",level:3},{value:"Page re-rendering",id:"page-re-rendering",level:3},{value:"Stateful component",id:"stateful-component",level:3},{value:"Event handling",id:"event-handling",level:2},{value:"Event handler is a function",id:"event-handler-is-a-function",level:3},{value:"Passing state to child components",id:"passing-state-to-child-components",level:3},{value:"Changes in state cause rerendering",id:"changes-in-state-cause-rerendering",level:3},{value:"Refactoring the components",id:"refactoring-the-components",level:3},{value:"Complex state",id:"complex-state",level:2},{value:"Handling arrays",id:"handling-arrays",level:3},{value:"Conditional rendering",id:"conditional-rendering",level:3},{value:"Old React",id:"old-react",level:3},{value:"Debugging React applications",id:"debugging-react-applications",level:3},{value:"Rules of Hooks",id:"rules-of-hooks",level:3},{value:"Event Handling Revisited",id:"event-handling-revisited",level:3},{value:"Function that returns a function",id:"function-that-returns-a-function",level:3},{value:"Passing Event Handlers to Child Components",id:"passing-event-handlers-to-child-components",level:3},{value:"Do Not Define Components Within Components",id:"do-not-define-components-within-components",level:3},{value:"Useful Reading",id:"useful-reading",level:3},{value:"Reference",id:"reference",level:2}],h={toc:p};function d(e){var t=e.components,r=(0,o.Z)(e,s);return(0,l.kt)("wrapper",(0,a.Z)({},h,r,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"after-lecture"},"After Lecture"),(0,l.kt)("h2",{id:"recommended-videos"},"Recommended videos"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://youtu.be/qhECs40xMec"},"Array Destructuring"),(0,l.kt)("a",{parentName:"li",href:"https://youtu.be/i4vhNKihfto"},"Object Destructuring")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://youtu.be/4Zyr5a3m0Fc"},"Spread Operator")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://egghead.io/lessons/react-a-beginners-guide-to-react-introduction"},"UseState(): egghead.io - Videos 9 to 13 (~30min)")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://www.youtube.com/playlist?list=PL4cUxeGkcC9ij8CfkAY2RAGb-tmkNwQHG"},"UseState() React Tutorial - Videos 5 to 13 (~55min)"))),(0,l.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,l.kt)("div",{parentName:"div",className:"admonition-heading"},(0,l.kt)("h5",{parentName:"div"},(0,l.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,l.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,l.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,l.kt)("div",{parentName:"div",className:"admonition-content"},(0,l.kt)("p",{parentName:"div"}," ",(0,l.kt)("strong",{parentName:"p"},"Credits"),": The post lecture material has been written by ",(0,l.kt)("a",{parentName:"p",href:"https://github.com/mluukkai"},"Matti Luukkainen")," from ",(0,l.kt)("a",{parentName:"p",href:"https://fullstackopen.com/en/"},"University of Helsinki"),". The material is licensed under the Creative Commons BY-NC-SA 3.0 License."))),(0,l.kt)("h2",{id:"component-state-event-handlers"},"Component state, event handlers"),(0,l.kt)("p",null,"Let's go back to working with React."),(0,l.kt)("p",null,"We start with a new example:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"const Hello = (props) => {\n  return (\n    <div>\n      <p>\n        Hello {props.name}, you are {props.age} years old\n      </p>\n    </div>\n  )\n}\n\nconst App = () => {\n  const name = 'Peter'\n  const age = 10\n\n  return (\n    <div>\n      <h1>Greetings</h1>\n      <Hello name=\"Maya\" age={26 + 10} />\n      <Hello name={name} age={age} />\n    </div>\n  )\n}\n\nexport default App\n")),(0,l.kt)("h3",{id:"component-helper-functions"},"Component helper functions"),(0,l.kt)("p",null,"Let's expand our ",(0,l.kt)("i",null,"Hello")," component so that it guesses the year of birth of the person being greeted:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"const Hello = (props) => {\n\n  const bornYear = () => {\n    const yearNow = new Date().getFullYear()\n    return yearNow - props.age\n  }\n\n\n  return (\n    <div>\n      <p>\n        Hello {props.name}, you are {props.age} years old\n      </p>\n      <p>So you were probably born in {bornYear()}</p> \n    </div>\n  )\n}\n")),(0,l.kt)("p",null,"The logic for guessing the year of birth is separated into a function of its own that is called when the component is rendered."),(0,l.kt)("p",null,"The person's age does not have to be passed as a parameter to the function, since it can directly access all props that are passed to the component."),(0,l.kt)("p",null,"If we examine our current code closely, we'll notice that the helper function is actually defined inside of another function that defines the behavior of our component. In Java programming, defining a function inside another one is complex and cumbersome, so not all that common. In JavaScript, however, defining functions within functions is a commonly-used technique."),(0,l.kt)("h3",{id:"destructuring"},"Destructuring"),(0,l.kt)("p",null,"Before we move forward, we will take a look at a small but useful feature of the JavaScript language that was added in the ES6 specification, that allows us to ",(0,l.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment"},"destructure")," values from objects and arrays upon assignment."),(0,l.kt)("p",null,"In our previous code, we had to reference the data passed to our component as ",(0,l.kt)("em",{parentName:"p"},"props.name")," and ",(0,l.kt)("em",{parentName:"p"},"props.age"),". Of these two expressions we had to repeat ",(0,l.kt)("em",{parentName:"p"},"props.age")," twice in our code."),(0,l.kt)("p",null,"Since ",(0,l.kt)("i",null,"props")," is an object"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"props = {\n  name: 'Arto Hellas',\n  age: 35,\n}\n")),(0,l.kt)("p",null,"we can streamline our component by assigning the values of the properties directly into two variables ",(0,l.kt)("em",{parentName:"p"},"name")," and ",(0,l.kt)("em",{parentName:"p"},"age")," which we can then use in our code:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"const Hello = (props) => {\n  \n  const name = props.name\n  const age = props.age\n  \n\n  const bornYear = () => new Date().getFullYear() - age\n\n  return (\n    <div>\n      <p>Hello {name}, you are {age} years old</p> \n      <p>So you were probably born in {bornYear()}</p>\n    </div>\n  )\n}\n")),(0,l.kt)("p",null,"Note that we've also utilized the more compact syntax for arrow functions when defining the ",(0,l.kt)("em",{parentName:"p"},"bornYear")," function. As mentioned earlier, if an arrow function consists of a single expression, then the function body does not need to be written inside of curly braces. In this more compact form, the function simply returns the result of the single expression."),(0,l.kt)("p",null,"To recap, the two function definitions shown below are equivalent:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"const bornYear = () => new Date().getFullYear() - age\n\nconst bornYear = () => {\n  return new Date().getFullYear() - age\n}\n")),(0,l.kt)("p",null,"Destructuring makes the assignment of variables even easier, since we can use it to extract and gather the values of an object's properties into separate variables:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"const Hello = (props) => {\n    \n  const { name, age } = props\n    \n  const bornYear = () => new Date().getFullYear() - age\n\n  return (\n    <div>\n      <p>Hello {name}, you are {age} years old</p>\n      <p>So you were probably born in {bornYear()}</p>\n    </div>\n  )\n}\n")),(0,l.kt)("p",null,"If the object we are destructuring has the values"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"props = {\n  name: 'Arto Hellas',\n  age: 35,\n}\n")),(0,l.kt)("p",null,"the expression ",(0,l.kt)("em",null,"const { name, age } = props")," assigns the values 'Arto Hellas' to ",(0,l.kt)("em",{parentName:"p"},"name")," and 35 to ",(0,l.kt)("em",{parentName:"p"},"age"),"."),(0,l.kt)("p",null,"We can take destructuring a step further:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"const Hello = ({ name, age }) => { \n  const bornYear = () => new Date().getFullYear() - age\n\n  return (\n    <div>\n      <p>\n        Hello {name}, you are {age} years old\n      </p>\n      <p>So you were probably born in {bornYear()}</p>\n    </div>\n  )\n}\n")),(0,l.kt)("p",null,"The props that are passed to the component are now directly destructured into the variables ",(0,l.kt)("em",{parentName:"p"},"name")," and ",(0,l.kt)("em",{parentName:"p"},"age"),"."),(0,l.kt)("p",null,"This means that instead of assigning the entire props object into a variable called ",(0,l.kt)("i",null,"props")," and then assigning its properties into the variables ",(0,l.kt)("em",{parentName:"p"},"name")," and ",(0,l.kt)("em",{parentName:"p"},"age")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"const Hello = (props) => {\n  const { name, age } = props\n")),(0,l.kt)("p",null,"we assign the values of the properties directly to variables by destructuring the props object that is passed to the component function as a parameter:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"const Hello = ({ name, age }) => {\n")),(0,l.kt)("p",null,"Here's another example how ",(0,l.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment"},"destructure")," values from arrays upon assignment."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"const t = [1, 2, 3, 4, 5]\n\nconst [first, second, ...rest] = t\n\nconsole.log(first, second)  // 1, 2 is printed\nconsole.log(rest)          // [3, 4, 5] is printed\n")),(0,l.kt)("p",null,"Thanks to the assignment, the variables ",(0,l.kt)("em",{parentName:"p"},"first")," and ",(0,l.kt)("em",{parentName:"p"},"second"),' will receive the first two integers of the array as their values. The remaining integers are "collected" into an array of their own which is then assigned to the variable ',(0,l.kt)("em",{parentName:"p"},"rest"),"."),(0,l.kt)("h3",{id:"page-re-rendering"},"Page re-rendering"),(0,l.kt)("p",null,"So far all of our applications have been such that their appearance remains the same after the initial rendering. What if we wanted to create a counter where the value increased as a function of time or at the click of a button?"),(0,l.kt)("p",null,"Let's start with the following. File ",(0,l.kt)("i",null,"App.js")," becomes:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"const App = (props) => {\n  const {counter} = props\n  return (\n    <div>{counter}</div>\n  )\n}\n\nexport default App\n")),(0,l.kt)("p",null,"And file ",(0,l.kt)("i",null,"index.js")," becomes:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"import ReactDOM from 'react-dom'\nimport App from './App'\n\nlet counter = 1\n\nReactDOM.render(\n  <App counter={counter} />, \n  document.getElementById('root')\n)\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Note")," when you change file ",(0,l.kt)("i",null,"index.js")," React does not always refresh the page automatically so you possibly need to reload the browser page to get the new content shown."),(0,l.kt)("p",null,"The App component is given the value of the counter via the ",(0,l.kt)("em",{parentName:"p"},"counter")," prop. This component renders the value to the screen. What happens when the value of ",(0,l.kt)("em",{parentName:"p"},"counter")," changes? Even if we were to add the following"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"counter += 1\n")),(0,l.kt)("p",null,"the component won't re-render. We can get the component to re-render by calling the ",(0,l.kt)("em",{parentName:"p"},"ReactDOM.render")," method a second time, e.g. in the following way:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"let counter = 1\n\nconst refresh = () => {\n  ReactDOM.render(<App counter={counter} />, \n  document.getElementById('root'))\n}\n\nrefresh()\ncounter += 1\nrefresh()\ncounter += 1\nrefresh()\n")),(0,l.kt)("p",null,"The re-rendering command has been wrapped inside of the ",(0,l.kt)("em",{parentName:"p"},"refresh")," function to cut down on the amount of copy-pasted code."),(0,l.kt)("p",null,"Now the component  ",(0,l.kt)("i",null,"renders three times"),", first with the value 1, then 2, and finally 3. However, the values 1 and 2 are displayed on the screen for such a short amount of time that they can't be noticed."),(0,l.kt)("p",null,"We can implement slightly more interesting functionality by re-rendering and incrementing the counter every second by using ",(0,l.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setInterval"},"setInterval"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"setInterval(() => {\n  refresh()\n  counter += 1\n}, 1000)\n")),(0,l.kt)("p",null,"Making repeated calls to the ",(0,l.kt)("em",{parentName:"p"},"ReactDOM.render")," method is not the recommended way to re-render components. Next, we'll introduce a better way of accomplishing this effect."),(0,l.kt)("h3",{id:"stateful-component"},"Stateful component"),(0,l.kt)("p",null,"All of our components up till now have been simple in the sense that they have not contained any state that could change during the lifecycle of the component."),(0,l.kt)("p",null,"Next, let's add state to our application's ",(0,l.kt)("i",null,"App")," component with the help of React's ",(0,l.kt)("a",{parentName:"p",href:"https://reactjs.org/docs/hooks-state.html"},"state hook"),"."),(0,l.kt)("p",null,"We will change the application as follows.  ",(0,l.kt)("i",null,"index.js")," goes back to"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"import ReactDOM from 'react-dom'\nimport App from './App'\n\nReactDOM.render(<App />, \ndocument.getElementById('root'))\n")),(0,l.kt)("p",null,"and ",(0,l.kt)("i",null,"App.js")," changes to the following:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"import { useState } from 'react' \n\nconst App = () => {\n  const [ counter, setCounter ] = useState(0) \n\n\n  setTimeout(\n    () => setCounter(counter + 1),\n    1000\n  )\n  \n\n  return (\n    <div>{counter}</div>\n  )\n}\n\nexport default App\n")),(0,l.kt)("p",null,"In the first row, the file imports the ",(0,l.kt)("em",{parentName:"p"},"useState")," function:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"import { useState } from 'react'\n")),(0,l.kt)("p",null,"The function body that defines the component begins with the function call:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"const [ counter, setCounter ] = useState(0)\n")),(0,l.kt)("p",null,"The function call adds ",(0,l.kt)("i",null,"state")," to the component and renders it initialized with the value of zero. The function returns an array that contains two items. We assign the items to the variables ",(0,l.kt)("em",{parentName:"p"},"counter")," and ",(0,l.kt)("em",{parentName:"p"},"setCounter")," by using the destructuring assignment syntax shown earlier."),(0,l.kt)("p",null,"The ",(0,l.kt)("em",{parentName:"p"},"counter")," variable is assigned the initial value of ",(0,l.kt)("i",null,"state")," which is zero. The variable ",(0,l.kt)("em",{parentName:"p"},"setCounter")," is assigned to a function that will be used to ",(0,l.kt)("i",null,"modify the state"),"."),(0,l.kt)("p",null,"The application calls the ",(0,l.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout"},"setTimeout")," function and passes it two parameters: a function to increment the counter state and a timeout of one second:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"setTimeout(\n  () => setCounter(counter + 1),\n  1000\n)\n")),(0,l.kt)("p",null,"The function passed as the first parameter to the ",(0,l.kt)("em",{parentName:"p"},"setTimeout")," function is invoked one second after calling the ",(0,l.kt)("em",{parentName:"p"},"setTimeout")," function"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"() => setCounter(counter + 1)\n")),(0,l.kt)("p",null,"When the state modifying function ",(0,l.kt)("em",{parentName:"p"},"setCounter")," is called, ",(0,l.kt)("i",null,"React re-renders the component")," which means that the function body of the component function gets re-executed:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"() => {\n  const [ counter, setCounter ] = useState(0)\n\n  setTimeout(\n    () => setCounter(counter + 1),\n    1000\n  )\n\n  return (\n    <div>{counter}</div>\n  )\n}\n")),(0,l.kt)("p",null,"The second time the component function is executed it calls the ",(0,l.kt)("em",{parentName:"p"},"useState")," function and returns the new value of the state: 1. Executing the function body again also makes a new function call to ",(0,l.kt)("em",{parentName:"p"},"setTimeout"),", which executes the one second timeout and increments the ",(0,l.kt)("em",{parentName:"p"},"counter")," state again. Because the value of the ",(0,l.kt)("em",{parentName:"p"},"counter")," variable is 1, incrementing the value by 1 is essentially the same as an expression setting the value of ",(0,l.kt)("em",{parentName:"p"},"counter")," to 2."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"() => setCounter(2)\n")),(0,l.kt)("p",null,"Meanwhile, the old value of ",(0,l.kt)("em",{parentName:"p"},"counter"),' - "1" - is rendered to the screen.'),(0,l.kt)("p",null,"Every time the ",(0,l.kt)("em",{parentName:"p"},"setCounter"),"  modifies the state it causes the component to re-render. The value of the state will be incremented again after one second, and this will continue to repeat for as long as the application is running."),(0,l.kt)("p",null,"If the component doesn't render when you think it should, or if it renders at the \"wrong time\", you can debug the application by logging the values of the component's variables to the console. If we make the following additions to our code:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"import React, { useState } from 'react';\n\nconst App = () => {\n  const [ counter, setCounter ] = useState(0)\n\n  setTimeout(\n    () => setCounter(counter + 1),\n    1000\n  )\n\n  console.log('rendering...', counter) \n\n  return (\n    <div>{counter}</div>\n  )\n}\nexport default App\n")),(0,l.kt)("p",null,"It's easy to follow and track the calls made to the ",(0,l.kt)("i",null,"App")," component's render function:"),(0,l.kt)("p",null,(0,l.kt)("img",{loading:"lazy",src:n(9409).Z,width:"1586",height:"864"})),(0,l.kt)("h2",{id:"event-handling"},"Event handling"),(0,l.kt)("p",null,"We have already mentioned ",(0,l.kt)("i",null,"event handlers")," that are registered to be called when specific events occur a few times in Lecture 04. E.g. a user's interaction with the different elements of a web page can cause a collection of various different kinds of events to be triggered."),(0,l.kt)("p",null,"Let's change the application so that increasing the counter happens when a user clicks a button, which is implemented with the ",(0,l.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button"},"button")," element."),(0,l.kt)("p",null,"Button elements support so-called ",(0,l.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent"},"mouse events"),", of which ",(0,l.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/Events/click"},"click")," is the most common event. The click event on a button can also be triggered with the keyboard or a touch screen despite the name ",(0,l.kt)("i",null,"mouse event"),"."),(0,l.kt)("p",null,"In React, ",(0,l.kt)("a",{parentName:"p",href:"https://reactjs.org/docs/handling-events.html"},"registering an event handler function")," to the ",(0,l.kt)("i",null,"click")," event happens like this:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"const App = () => {\n  const [ counter, setCounter ] = useState(0)\n\n  \n  const handleClick = () => {\n    console.log('clicked')\n  }\n  \n\n  return (\n    <div>\n      <div>{counter}</div>\n      \n      <button onClick={handleClick}>\n        plus\n      </button>\n      \n    </div>\n  )\n}\n")),(0,l.kt)("p",null,"We set the value of the button's ",(0,l.kt)("i",null,"onClick")," attribute to be a reference to the ",(0,l.kt)("em",{parentName:"p"},"handleClick")," function defined in the code."),(0,l.kt)("p",null,"Now every click of the ",(0,l.kt)("i",null,"plus")," button causes the ",(0,l.kt)("em",{parentName:"p"},"handleClick")," function to be called, meaning that every click event will log a ",(0,l.kt)("i",null,"clicked")," message to the browser console."),(0,l.kt)("p",null,"The event handler function can also be defined directly in the value assignment of the onClick-attribute:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"const App = () => {\n  const [ counter, setCounter ] = useState(0)\n\n  return (\n    <div>\n      <div>{counter}</div>\n      <button onClick={() => console.log('clicked')}> \n        plus\n      </button>\n    </div>\n  )\n}\n")),(0,l.kt)("p",null,"By changing the event handler to the following form"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"<button onClick={() => setCounter(counter + 1)}>\n  plus\n</button>\n")),(0,l.kt)("p",null,"we achieve the desired behavior, meaning that the value of ",(0,l.kt)("em",{parentName:"p"},"counter")," is increased by one ",(0,l.kt)("i",null,"and")," the component gets re-rendered."),(0,l.kt)("p",null,"Let's also add a button for resetting the counter:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"const App = () => {\n  const [ counter, setCounter ] = useState(0)\n\n  return (\n    <div>\n      <div>{counter}</div>\n      <button onClick={() => setCounter(counter + 1)}>\n        plus\n      </button>\n      \n      <button onClick={() => setCounter(0)}> \n        zero\n      </button>\n      \n    </div>\n  )\n}\n")),(0,l.kt)("p",null,"Our application is now ready!"),(0,l.kt)("h3",{id:"event-handler-is-a-function"},"Event handler is a function"),(0,l.kt)("p",null,"We define the event handlers for our buttons where we declare their ",(0,l.kt)("i",null,"onClick")," attributes:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"<button onClick={() => setCounter(counter + 1)}> \n  plus\n</button>\n")),(0,l.kt)("p",null,"What if we tried to define the event handlers in a simpler form?"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"<button onClick={setCounter(counter + 1)}> \n  plus\n</button>\n")),(0,l.kt)("p",null,"This would completely break our application:"),(0,l.kt)("p",null,(0,l.kt)("img",{loading:"lazy",src:n(9397).Z,width:"1450",height:"1028"})),(0,l.kt)("p",null,"What's going on? An event handler is supposed to be either a ",(0,l.kt)("i",null,"function")," or a ",(0,l.kt)("i",null,"function reference"),", and when we write:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"<button onClick={setCounter(counter + 1)}>\n")),(0,l.kt)("p",null,"the event handler is actually a ",(0,l.kt)("i",null,"function call"),". In many situations this is ok, but not in this particular situation. In the beginning the value of the ",(0,l.kt)("i",null,"counter")," variable is 0. When React renders the component for the first time, it executes the function call ",(0,l.kt)("em",null,"setCounter(0+1)"),", and changes the value of the component's state to 1.\nThis will cause the component to be re-rendered, React will execute the setCounter function call again, and the state will change leading to another rerender..."),(0,l.kt)("p",null,"Let's define the event handlers like we did before:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"<button onClick={() => setCounter(counter + 1)}> \n  plus\n</button>\n")),(0,l.kt)("p",null,"Now the button's attribute which defines what happens when the button is clicked - ",(0,l.kt)("i",null,"onClick")," - has the value ",(0,l.kt)("em",{parentName:"p"},"() => setCounter(counter + 1)"),".\nThe setCounter function is called only when a user clicks the button. "),(0,l.kt)("p",null,"Usually defining event handlers within JSX-templates is not a good idea.\nHere it's ok, because our event handlers are so simple. "),(0,l.kt)("p",null,"Let's separate the event handlers into separate functions anyway: "),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"const App = () => {\n  const [ counter, setCounter ] = useState(0)\n\n\n  const increaseByOne = () => setCounter(counter + 1)\n  \n  const setToZero = () => setCounter(0)\n  \n\n  return (\n    <div>\n      <div>{counter}</div>\n      <button onClick={increaseByOne}> \n        plus\n      </button>\n      <button onClick={setToZero}> \n        zero\n      </button>\n    </div>\n  )\n}\n")),(0,l.kt)("p",null,"Here, the event handlers have been defined correctly. The value of the ",(0,l.kt)("i",null,"onClick")," attribute is a variable containing a reference to a function:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"<button onClick={increaseByOne}> \n  plus\n</button>\n")),(0,l.kt)("h3",{id:"passing-state-to-child-components"},"Passing state to child components"),(0,l.kt)("p",null,"It's recommended to write React components that are small and reusable across the application and even across projects. Let's refactor our application so that it's composed of three smaller components, one component for displaying the counter and two components for buttons."),(0,l.kt)("p",null,"Let's first implement a ",(0,l.kt)("i",null,"Display")," component that's responsible for displaying the value of the counter."),(0,l.kt)("p",null,"One best practice in React is to ",(0,l.kt)("a",{parentName:"p",href:"https://reactjs.org/docs/lifting-state-up.html"},"lift the state up")," in the component hierarchy. The documentation says:"),(0,l.kt)("blockquote",null,(0,l.kt)("i",null,"Often, several components need to reflect the same changing data. We recommend lifting the shared state up to their closest common ancestor.")),(0,l.kt)("p",null,"So let's place the application's state in the ",(0,l.kt)("i",null,"App")," component and pass it down to the ",(0,l.kt)("i",null,"Display")," component through ",(0,l.kt)("i",null,"props"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"const Display = (props) => {\n  return (\n    <div>{props.counter}</div>\n  )\n}\n")),(0,l.kt)("p",null,"Using the component is straightforward, as we only need to pass the state of the ",(0,l.kt)("em",{parentName:"p"},"counter")," to it:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"const App = () => {\n  const [ counter, setCounter ] = useState(0)\n\n  const increaseByOne = () => setCounter(counter + 1)\n  const setToZero = () => setCounter(0)\n\n  return (\n    <div>\n      <Display counter={counter}/> \n      <button onClick={increaseByOne}>\n        plus\n      </button>\n      <button onClick={setToZero}> \n        zero\n      </button>\n    </div>\n  )\n}\n")),(0,l.kt)("p",null,"Everything still works. When the buttons are clicked and the ",(0,l.kt)("i",null,"App")," gets re-rendered, all of its children including the ",(0,l.kt)("i",null,"Display")," component are also re-rendered."),(0,l.kt)("p",null,"Next, let's make a ",(0,l.kt)("i",null,"Button")," component for the buttons of our application. We have to pass the event handler as well as the title of the button through the component's props:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"const Button = (props) => {\n  return (\n    <button onClick={props.onClick}>\n      {props.text}\n    </button>\n  )\n}\n")),(0,l.kt)("p",null,"Our ",(0,l.kt)("i",null,"App")," component now looks like this:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"const App = () => {\n  const [ counter, setCounter ] = useState(0)\n\n  const increaseByOne = () => setCounter(counter + 1)\n  //highlight-start\n  const decreaseByOne = () => setCounter(counter - 1)\n  //highlight-end\n  const setToZero = () => setCounter(0)\n\n  return (\n    <div>\n      <Display counter={counter}/>\n      \n      <Button\n        onClick={increaseByOne}\n        text='plus'\n      />\n      <Button\n        onClick={setToZero}\n        text='zero'\n      />     \n      <Button\n        onClick={decreaseByOne}\n        text='minus'\n      />           \n      \n    </div>\n  )\n}\n")),(0,l.kt)("p",null,"Since we now have an easily reusable ",(0,l.kt)("i",null,"Button")," component, we've also implemented new functionality into our application by adding a button that can be used to decrement the counter."),(0,l.kt)("p",null,"The event handler is passed to the ",(0,l.kt)("i",null,"Button")," component through the ",(0,l.kt)("em",{parentName:"p"},"onClick")," prop. The name of the prop itself is not that significant, but our naming choice wasn't completely random. React's own official ",(0,l.kt)("a",{parentName:"p",href:"https://reactjs.org/tutorial/tutorial.html"},"tutorial")," suggests this convention."),(0,l.kt)("h3",{id:"changes-in-state-cause-rerendering"},"Changes in state cause rerendering"),(0,l.kt)("p",null,"Let's go over the main principles of how an application works once more."),(0,l.kt)("p",null,"When the application starts, the code in ",(0,l.kt)("em",{parentName:"p"},"App")," is executed. This code uses a ",(0,l.kt)("a",{parentName:"p",href:"https://reactjs.org/docs/hooks-reference.html#usestate"},"useState")," hook to create the application state, setting an initial value of the variable ",(0,l.kt)("em",{parentName:"p"},"counter"),".\nThis component contains the ",(0,l.kt)("em",{parentName:"p"},"Display")," component - which displays the counter's value, 0 - and three ",(0,l.kt)("em",{parentName:"p"},"Button")," components. The buttons all have event handlers, which are used to change the state of the counter."),(0,l.kt)("p",null,"When one of the buttons is clicked, the event handler is executed. The event handler changes the state of the ",(0,l.kt)("em",{parentName:"p"},"App")," component with the ",(0,l.kt)("em",{parentName:"p"},"setCounter")," function.\n",(0,l.kt)("strong",{parentName:"p"},"Calling a function which changes the state causes the component to rerender.")),(0,l.kt)("p",null,"So, if a user clicks the ",(0,l.kt)("i",null,"plus")," button, the button's event handler changes the value of ",(0,l.kt)("em",{parentName:"p"},"counter")," to 1, and the ",(0,l.kt)("em",{parentName:"p"},"App")," component is rerendered.\nThis causes its subcomponents ",(0,l.kt)("em",{parentName:"p"},"Display")," and ",(0,l.kt)("em",{parentName:"p"},"Button")," to also be re-rendered.\n",(0,l.kt)("em",{parentName:"p"},"Display")," receives the new value of the counter, 1, as props. The ",(0,l.kt)("em",{parentName:"p"},"Button")," components receive event handlers which can be used to change the state of the counter."),(0,l.kt)("h3",{id:"refactoring-the-components"},"Refactoring the components"),(0,l.kt)("p",null,"The component displaying the value of the counter is as follows:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"const Display = (props) => {\n  return (\n    <div>{props.counter}</div>\n  )\n}\n")),(0,l.kt)("p",null,"The component only uses the ",(0,l.kt)("em",{parentName:"p"},"counter")," field of its ",(0,l.kt)("i",null,"props"),".\nThis means we can simplify the component by using destructuring, like so:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"const Display = ({ counter }) => {\n  return (\n    <div>{counter}</div>\n  )\n}\n")),(0,l.kt)("p",null,"The function defining the component contains only the return statement, so\nwe can define the function using the more compact form of arrow functions:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"const Display = ({ counter }) => <div>{counter}</div>\n")),(0,l.kt)("p",null,"We can simplify the Button component as well."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"const Button = (props) => {\n  return (\n    <button onClick={props.onClick}>\n      {props.text}\n    </button>\n  )\n}\n")),(0,l.kt)("p",null,"We can use destructuring to get only the required fields from ",(0,l.kt)("i",null,"props"),", and use the more compact form of arrow functions:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"const Button = ({ onClick, text }) => (\n  <button onClick={onClick}>\n    {text}\n  </button>\n)\n")),(0,l.kt)("h2",{id:"complex-state"},"Complex state"),(0,l.kt)("p",null,"In our previous example the application state was simple as it was comprised of a single integer. What if our application requires a more complex state?"),(0,l.kt)("p",null,"In most cases the easiest and best way to accomplish this is by using the ",(0,l.kt)("em",{parentName:"p"},"useState"),' function multiple times to create separate "pieces" of state.'),(0,l.kt)("p",null,"In the following code we create two pieces of state for the application named ",(0,l.kt)("em",{parentName:"p"},"left")," and ",(0,l.kt)("em",{parentName:"p"},"right")," that both get the initial value of 0:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"const App = () => {\n  const [left, setLeft] = useState(0)\n  const [right, setRight] = useState(0)\n\n  return (\n    <div>\n      {left}\n      <button onClick={() => setLeft(left + 1)}>\n        left\n      </button>\n      <button onClick={() => setRight(right + 1)}>\n        right\n      </button>\n      {right}\n    </div>\n  )\n}\n")),(0,l.kt)("p",null,"The component gets access to the functions ",(0,l.kt)("em",{parentName:"p"},"setLeft")," and ",(0,l.kt)("em",{parentName:"p"},"setRight")," that it can use to update the two pieces of state."),(0,l.kt)("p",null,"The component's state or a piece of its state can be of any type. We could implement the same functionality by saving the click count of both the ",(0,l.kt)("i",null,"left")," and ",(0,l.kt)("i",null,"right")," buttons into a single object:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"{\n  left: 0,\n  right: 0\n}\n")),(0,l.kt)("p",null,"In this case the application would look like this:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"const App = () => {\n  const [clicks, setClicks] = useState({\n    left: 0, right: 0\n  })\n\n  const handleLeftClick = () => {\n    const newClicks = { \n      left: clicks.left + 1, \n      right: clicks.right \n    }\n    setClicks(newClicks)\n  }\n\n  const handleRightClick = () => {\n    const newClicks = { \n      left: clicks.left, \n      right: clicks.right + 1 \n    }\n    setClicks(newClicks)\n  }\n\n  return (\n    <div>\n      {clicks.left}\n      <button onClick={handleLeftClick}>left</button>\n      <button onClick={handleRightClick}>right</button>\n      {clicks.right}\n    </div>\n  )\n}\n")),(0,l.kt)("p",null,"Now the component only has a single piece of state and the event handlers have to take care of changing the ",(0,l.kt)("i",null,"entire application state"),"."),(0,l.kt)("p",null,"The event handler looks a bit messy. When the left button is clicked, the following function is called:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"const handleLeftClick = () => {\n  const newClicks = { \n    left: clicks.left + 1, \n    right: clicks.right \n  }\n  setClicks(newClicks)\n}\n")),(0,l.kt)("p",null,"The following object is set as the new state of the application:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"{\n  left: clicks.left + 1,\n  right: clicks.right\n}\n")),(0,l.kt)("p",null,"The new value of the ",(0,l.kt)("i",null,"left")," property is now the same as the value of ",(0,l.kt)("i",null,"left + 1")," from the previous state, and the value of the ",(0,l.kt)("i",null,"right")," property is the same as value of the ",(0,l.kt)("i",null,"right")," property from the previous state."),(0,l.kt)("p",null,"We can define the new state object a bit more neatly by using the ",(0,l.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax"},"object spread"),"\nsyntax that was added to the language specification in the summer of 2018:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"const handleLeftClick = () => {\n  const newClicks = { \n    ...clicks, \n    left: clicks.left + 1 \n  }\n  setClicks(newClicks)\n}\n\nconst handleRightClick = () => {\n  const newClicks = { \n    ...clicks, \n    right: clicks.right + 1 \n  }\n  setClicks(newClicks)\n}\n")),(0,l.kt)("p",null,"The syntax may seem a bit strange at first. In practice ",(0,l.kt)("em",null,"{ ...clicks }")," creates a new object that has copies of all of the properties of the ",(0,l.kt)("em",{parentName:"p"},"clicks")," object. When we specify a particular property - e.g. ",(0,l.kt)("i",null,"right")," in ",(0,l.kt)("em",null,"{ ...clicks, right: 1 }"),", the value of the ",(0,l.kt)("em",{parentName:"p"},"right")," property in the new object will be 1."),(0,l.kt)("p",null,"In the example above, this:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"{ ...clicks, right: clicks.right + 1 }\n")),(0,l.kt)("p",null,"creates a copy of the ",(0,l.kt)("em",{parentName:"p"},"clicks")," object where the value of the ",(0,l.kt)("em",{parentName:"p"},"right")," property is increased by one."),(0,l.kt)("p",null,"Assigning the object to a variable in the event handlers is not necessary and we can simplify the functions to the following form:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"const handleLeftClick = () =>\n  setClicks({ ...clicks, left: clicks.left + 1 })\n\nconst handleRightClick = () =>\n  setClicks({ ...clicks, right: clicks.right + 1 })\n")),(0,l.kt)("p",null,"Some readers might be wondering why we didn't just update the state directly, like this:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"const handleLeftClick = () => {\n  clicks.left++\n  setClicks(clicks)\n}\n")),(0,l.kt)("p",null,"The application appears to work. However, ",(0,l.kt)("i",null,"it is forbidden in React to mutate state directly"),", since it can result in unexpected side effects. Changing state has to always be done by setting the state to a new object. If properties from the previous state object are not changed, they need to simply be copied, which is done by copying those properties into a new object, and setting that as the new state."),(0,l.kt)("p",null,"Storing all of the state in a single state object is a bad choice for this particular application; there's no apparent benefit and the resulting application is a lot more complex. In this case storing the click counters into separate pieces of state is a far more suitable choice."),(0,l.kt)("p",null,"There are situations where it can be beneficial to store a piece of application state in a more complex data structure. ",(0,l.kt)("a",{parentName:"p",href:"https://reactjs.org/docs/hooks-faq.html#should-i-use-one-or-many-state-variables"},"The official React documentation")," contains some helpful guidance on the topic."),(0,l.kt)("h3",{id:"handling-arrays"},"Handling arrays"),(0,l.kt)("p",null,"Let's add a piece of state to our application containing an array ",(0,l.kt)("em",{parentName:"p"},"allClicks")," that remembers every click that has occurred in the application."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"const App = () => {\n  const [left, setLeft] = useState(0)\n  const [right, setRight] = useState(0)\n  const [allClicks, setAll] = useState([]) \n\n\n  const handleLeftClick = () => {\n    setAll(allClicks.concat('L'))\n    setLeft(left + 1)\n  }\n  \n\n\n  const handleRightClick = () => {\n    setAll(allClicks.concat('R'))\n    setRight(right + 1)\n  }\n  \n\n  return (\n    <div>\n      {left}\n      <button onClick={handleLeftClick}>left</button>\n      <button onClick={handleRightClick}>right</button>\n      {right}\n      <p>{allClicks.join(' ')}</p> \n    </div>\n  )\n}\n")),(0,l.kt)("p",null,"Every click is stored into a separate piece of state called ",(0,l.kt)("em",{parentName:"p"},"allClicks")," that is initialized as an empty array:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"const [allClicks, setAll] = useState([])\n")),(0,l.kt)("p",null,"When the ",(0,l.kt)("i",null,"left")," button is clicked, we add the letter ",(0,l.kt)("i",null,"L")," to the ",(0,l.kt)("em",{parentName:"p"},"allClicks")," array:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"const handleLeftClick = () => {\n  setAll(allClicks.concat('L'))\n  setLeft(left + 1)\n}\n")),(0,l.kt)("p",null,"The piece of state stored in ",(0,l.kt)("em",{parentName:"p"},"allClicks")," is now set to be an array that contains all of the items of the previous state array plus the letter ",(0,l.kt)("i",null,"L"),". Adding the new item to the array is accomplished with the ",(0,l.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/concat"},"concat")," method, that does not mutate the existing array but rather returns a ",(0,l.kt)("i",null,"new copy of the array")," with the item added to it."),(0,l.kt)("p",null,"As mentioned previously, it's also possible in JavaScript to add items to an array with the ",(0,l.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/push"},"push")," method. If we add the item by pushing it to the ",(0,l.kt)("em",{parentName:"p"},"allClicks")," array and then updating the state, the application would still appear to work:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"const handleLeftClick = () => {\n  allClicks.push('L')\n  setAll(allClicks)\n  setLeft(left + 1)\n}\n")),(0,l.kt)("p",null,"However, ",(0,l.kt)("strong",{parentName:"p"},"don't")," do this. As mentioned previously, the state of React components like ",(0,l.kt)("em",{parentName:"p"},"allClicks")," must not be mutated directly. Even if mutating state appears to work in some cases, it can lead to problems that are very hard to debug."),(0,l.kt)("p",null,"Let's take a closer look at how the clicking\nis rendered to the page:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"const App = () => {\n  // ...\n\n  return (\n    <div>\n      {left}\n      <button onClick={handleLeftClick}>left</button>\n      <button onClick={handleRightClick}>right</button>\n      {right}\n      <p>{allClicks.join(' ')}</p> \n    </div>\n  )\n}\n")),(0,l.kt)("p",null,"We call the ",(0,l.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/join"},"join")," method on the ",(0,l.kt)("em",{parentName:"p"},"allClicks")," array that joins all the items into a single string, separated by the string passed as the function parameter, which in our case is an empty space."),(0,l.kt)("h3",{id:"conditional-rendering"},"Conditional rendering"),(0,l.kt)("p",null,"Let's modify our application so that the rendering of the clicking history is handled by a new ",(0,l.kt)("i",null,"History")," component:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"\nconst History = (props) => {\n  if (props.allClicks.length === 0) {\n    return (\n      <div>\n        the app is used by pressing the buttons\n      </div>\n    )\n  }\n\n  return (\n    <div>\n      button press history: {props.allClicks.join(' ')}\n    </div>\n  )\n}\n\n\nconst App = () => {\n  // ...\n\n  return (\n    <div>\n      {left}\n      <button onClick={handleLeftClick}>left</button>\n      <button onClick={handleRightClick}>right</button>\n      {right}\n      <History allClicks={allClicks} /> \n    </div>\n  )\n}\n")),(0,l.kt)("p",null,"Now the behavior of the component depends on whether or not any buttons have been clicked. If not, meaning that the ",(0,l.kt)("em",null,"allClicks")," array is empty, the component renders a div element with some instructions instead:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"<div>the app is used by pressing the buttons</div>\n")),(0,l.kt)("p",null,"And in all other cases, the component renders the clicking history:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"<div>\n  button press history: {props.allClicks.join(' ')}\n</div>\n")),(0,l.kt)("p",null,"The ",(0,l.kt)("i",null,"History")," component renders completely different React elements depending on the state of the application. This is called ",(0,l.kt)("i",null,"conditional rendering"),"."),(0,l.kt)("p",null,"React also offers many other ways of doing ",(0,l.kt)("a",{parentName:"p",href:"https://reactjs.org/docs/conditional-rendering.html"},"conditional rendering"),". "),(0,l.kt)("p",null,"Let's make one last modification to our application by refactoring it to use the ",(0,l.kt)("em",{parentName:"p"},"Button")," component that we defined earlier on:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"const History = (props) => {\n  if (props.allClicks.length === 0) {\n    return (\n      <div>\n        the app is used by pressing the buttons\n      </div>\n    )\n  }\n\n  return (\n    <div>\n      button press history: {props.allClicks.join(' ')}\n    </div>\n  )\n}\n\n\nconst Button = ({ handleClick, text }) => (\n  <button onClick={handleClick}>\n    {text}\n  </button>\n)\n\n\nconst App = () => {\n  const [left, setLeft] = useState(0)\n  const [right, setRight] = useState(0)\n  const [allClicks, setAll] = useState([])\n\n  const handleLeftClick = () => {\n    setAll(allClicks.concat('L'))\n    setLeft(left + 1)\n  }\n\n  const handleRightClick = () => {\n    setAll(allClicks.concat('R'))\n    setRight(right + 1)\n  }\n\n  return (\n    <div>\n      {left}\n      \n      <Button handleClick={handleLeftClick} text='left' />\n      <Button handleClick={handleRightClick} text='right' />\n      \n      {right}\n      <History allClicks={allClicks} />\n    </div>\n  )\n}\n")),(0,l.kt)("h3",{id:"old-react"},"Old React"),(0,l.kt)("p",null,"In this course we use the ",(0,l.kt)("a",{parentName:"p",href:"https://reactjs.org/docs/hooks-state.html"},"state hook")," to add state to our React components, which is part of the newer versions of React and is available from version ",(0,l.kt)("a",{parentName:"p",href:"https://www.npmjs.com/package/react/v/16.8.0"},"16.8.0")," onwards. Before the addition of hooks, there was no way to add state to functional components. Components that required state had to be defined as ",(0,l.kt)("a",{parentName:"p",href:"https://reactjs.org/docs/react-component.html"},"class")," components, using the JavaScript class syntax."),(0,l.kt)("p",null,"In this course we have made the slightly radical decision to use hooks exclusively from day one, to ensure that we are learning the current and future style of React. Even though functional components are the future of React, it is still important to learn the class syntax, as there are billions of lines of legacy React code that you might end up maintaining someday. The same applies to documentation and examples of React that you may stumble across on the internet."),(0,l.kt)("p",null,"We will learn more about React class components later on in the course."),(0,l.kt)("h3",{id:"debugging-react-applications"},"Debugging React applications"),(0,l.kt)("p",null,"A large part of a typical developer's time is spent on debugging and reading existing code. Every now and then we do get to write a line or two of new code, but a large part of our time is spent on trying to figure out why something is broken or how something works. Good practices and tools for debugging are extremely important for this reason."),(0,l.kt)("p",null,"Lucky for us, React is an extremely developer-friendly library when it comes to debugging."),(0,l.kt)("p",null,"Before we move on, let us remind ourselves of one of the most important rules of web development."),(0,l.kt)("h4",null,"The first rule of web development"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"}," ",(0,l.kt)("strong",{parentName:"p"},"Keep the browser's developer console open at all times.")),(0,l.kt)("p",{parentName:"blockquote"},"The ",(0,l.kt)("i",null,"Console")," tab in particular should always be open, unless there is a specific reason to view another tab.")),(0,l.kt)("p",null,"Keep both your code and the web page open together ",(0,l.kt)("strong",{parentName:"p"},"at the same time, all the time"),"."),(0,l.kt)("p",null,"If and when your code fails to compile and your browser lights up like a Christmas tree:"),(0,l.kt)("p",null,(0,l.kt)("img",{loading:"lazy",src:n(1553).Z,width:"1470",height:"942"})),(0,l.kt)("p",null,"don't write more code but rather find and fix the problem ",(0,l.kt)("strong",{parentName:"p"},"immediately"),". There has yet to be a moment in the history of coding where code that fails to compile would miraculously start working after writing large amounts of additional code. I highly doubt that such an event will transpire during this course either."),(0,l.kt)("p",null,"Old school, print-based debugging is always a good idea. If the component"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"const Button = ({ onClick, text }) => (\n  <button onClick={onClick}>\n    {text}\n  </button>\n)\n")),(0,l.kt)("p",null,"is not working as intended, it's useful to start printing its variables out to the console. In order to do this effectively, we must transform our function into the less compact form and receive the entire props object without destructuring it immediately:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"const Button = (props) => { \n  console.log(props) \n  const { onClick, text } = props\n  return (\n    <button onClick={onClick}>\n      {text}\n    </button>\n  )\n}\n")),(0,l.kt)("p",null,"This will immediately reveal if, for instance, one of the attributes has been misspelled when using the component."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"NB")," When you use ",(0,l.kt)("em",{parentName:"p"},"console.log")," for debugging, don't combine ",(0,l.kt)("em",{parentName:"p"},"objects")," in a Java-like fashion by using the plus operator. Instead of writing:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"console.log('props value is ' + props)\n")),(0,l.kt)("p",null,"Separate the things you want to log to the console with a comma:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"console.log('props value is', props)\n")),(0,l.kt)("p",null,"If you use the Java-like way of concatenating a string with an object, you will end up with a rather uninformative log message:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"props value is [Object object]\n")),(0,l.kt)("p",null,"Whereas the items separated by a comma will all be available in the browser console for further inspection."),(0,l.kt)("p",null,"Logging to the console is by no means the only way of debugging our applications. You can pause the execution of your application code in the Chrome developer console's ",(0,l.kt)("i",null,"debugger"),", by writing the command ",(0,l.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/debugger"},"debugger")," anywhere in your code."),(0,l.kt)("p",null,"The execution will pause once it arrives at a point where the ",(0,l.kt)("em",{parentName:"p"},"debugger")," command gets executed:"),(0,l.kt)("p",null,(0,l.kt)("img",{loading:"lazy",src:n(6787).Z,width:"1810",height:"1010"})),(0,l.kt)("p",null,"By going to the ",(0,l.kt)("i",null,"Console")," tab, it is easy to inspect the current state of variables:"),(0,l.kt)("p",null,(0,l.kt)("img",{loading:"lazy",src:n(5640).Z,width:"1432",height:"512"})),(0,l.kt)("p",null,"Once the cause of the bug is discovered you can remove the ",(0,l.kt)("em",{parentName:"p"},"debugger")," command and refresh the page."),(0,l.kt)("p",null,"The debugger also enables us to execute our code line by line with the controls found on the right-hand side of the ",(0,l.kt)("i",null,"Sources")," tab."),(0,l.kt)("p",null,"You can also access the debugger without the ",(0,l.kt)("em",{parentName:"p"},"debugger")," command by adding breakpoints in the ",(0,l.kt)("i",null,"Sources")," tab. Inspecting the values of the component's variables can be done in the ",(0,l.kt)("em",{parentName:"p"},"Scope"),"-section:"),(0,l.kt)("p",null,(0,l.kt)("img",{loading:"lazy",src:n(1198).Z,width:"1816",height:"662"})),(0,l.kt)("p",null,"It is highly recommended to add the ",(0,l.kt)("a",{parentName:"p",href:"https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi"},"React developer tools")," extension to Chrome. It adds a new ",(0,l.kt)("em",{parentName:"p"},"Components")," tab to the developer tools. The new developer tools tab can be used to inspect the different React elements in the application, along with their state and props:"),(0,l.kt)("p",null,(0,l.kt)("img",{loading:"lazy",src:n(3625).Z,width:"1820",height:"894"})),(0,l.kt)("p",null,"The ",(0,l.kt)("em",{parentName:"p"},"App")," component's state is defined like so:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"const [left, setLeft] = useState(0)\nconst [right, setRight] = useState(0)\nconst [allClicks, setAll] = useState([])\n")),(0,l.kt)("p",null,"Dev tools shows the state of hooks in the order of their definition:"),(0,l.kt)("p",null,(0,l.kt)("img",{loading:"lazy",src:n(86).Z,width:"1782",height:"886"})),(0,l.kt)("p",null,"The first ",(0,l.kt)("i",null,"State")," contains the value of the ",(0,l.kt)("i",null,"left")," state, the next contains the value of the ",(0,l.kt)("i",null,"right")," state and the last contains the value of the ",(0,l.kt)("i",null,"allClicks")," state."),(0,l.kt)("h3",{id:"rules-of-hooks"},"Rules of Hooks"),(0,l.kt)("p",null,"There are a few limitations and rules we have to follow to ensure that our application uses hooks-based state functions correctly."),(0,l.kt)("p",null,"The ",(0,l.kt)("em",{parentName:"p"},"useState")," function (as well as the ",(0,l.kt)("em",{parentName:"p"},"useEffect")," function introduced later on in the course) ",(0,l.kt)("i",null,"must not be called")," from inside of a loop, a conditional expression, or any place that is not a function defining a component. This must be done to ensure that the hooks are always called in the same order, and if this isn't the case the application will behave erratically."),(0,l.kt)("p",null,"To recap, hooks may only be called from the inside of a function body that defines a React component:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"const App = () => {\n  // these are ok\n  const [age, setAge] = useState(0)\n  const [name, setName] = useState('Juha Tauriainen')\n\n  if ( age > 10 ) {\n    // this does not work!\n    const [foobar, setFoobar] = useState(null)\n  }\n\n  for ( let i = 0; i < age; i++ ) {\n    // also this is not good\n    const [rightWay, setRightWay] = useState(false)\n  }\n\n  const notGood = () => {\n    // and this is also illegal\n    const [x, setX] = useState(-1000)\n  }\n\n  return (\n    //...\n  )\n}\n")),(0,l.kt)("h3",{id:"event-handling-revisited"},"Event Handling Revisited"),(0,l.kt)("p",null,"Event handling has proven to be a difficult topic in previous iterations of this course."),(0,l.kt)("p",null,"For this reason we will revisit the topic."),(0,l.kt)("p",null,"Let's assume that we're developing this simple application with the following component ",(0,l.kt)("i",null,"App"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"const App = () => {\n  const [value, setValue] = useState(10)\n\n  return (\n    <div>\n      {value}\n      <button>reset to zero</button>\n    </div>\n  )\n}\n")),(0,l.kt)("p",null,"We want the clicking of the button to reset the state stored in the ",(0,l.kt)("em",{parentName:"p"},"value")," variable."),(0,l.kt)("p",null,"In order to make the button react to a click event, we have to add an ",(0,l.kt)("i",null,"event handler")," to it."),(0,l.kt)("p",null,"Event handlers must always be a function or a reference to a function. The button will not work if the event handler is set to a variable of any other type."),(0,l.kt)("p",null,"If we were to define the event handler as a string:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},'<button onClick="crap...">button</button>\n')),(0,l.kt)("p",null,"React would warn us about this in the console:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"index.js:2178 Warning: Expected `onClick` listener to be a function, instead got a value of `string` type.\n    in button (at index.js:20)\n    in div (at index.js:18)\n    in App (at index.js:27)\n")),(0,l.kt)("p",null,"The following attempt would also not work:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"<button onClick={value + 1}>button</button>\n")),(0,l.kt)("p",null,"We have attempted to set the event handler to ",(0,l.kt)("em",{parentName:"p"},"value + 1")," which simply returns the result of the operation. React will kindly warn us about this in the console:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"index.js:2178 Warning: Expected `onClick` listener to be a function, instead got a value of `number` type.\n")),(0,l.kt)("p",null,"This attempt would not work either:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"<button onClick={value = 0}>button</button>\n")),(0,l.kt)("p",null,"The event handler is not a function but a variable assignment, and React will once again issue a warning to the console. This attempt is also flawed in the sense that we must never mutate state directly in React."),(0,l.kt)("p",null,"What about the following:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"<button onClick={console.log('clicked the button')}>\n  button\n</button>\n")),(0,l.kt)("p",null,"The message gets printed to the console once when the component is rendered but nothing happens when we click the button. Why does this not work even when our event handler contains a function ",(0,l.kt)("em",{parentName:"p"},"console.log"),"?"),(0,l.kt)("p",null,"The issue here is that our event handler is defined as a ",(0,l.kt)("i",null,"function call")," which means that the event handler is actually assigned the returned value from the function, which in the case of ",(0,l.kt)("em",{parentName:"p"},"console.log")," is ",(0,l.kt)("i",null,"undefined"),"."),(0,l.kt)("p",null,"The ",(0,l.kt)("em",{parentName:"p"},"console.log")," function call gets executed when the component is rendered and for this reason it gets printed once to the console."),(0,l.kt)("p",null,"The following attempt is flawed as well:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"<button onClick={setValue(0)}>button</button>\n")),(0,l.kt)("p",null,"We have once again tried to set a function call as the event handler. This does not work. This particular attempt also causes another problem. When the component is rendered the function ",(0,l.kt)("em",{parentName:"p"},"setValue(0)")," gets executed which in turn causes the component to be re-rendered. Re-rendering in turn calls ",(0,l.kt)("em",{parentName:"p"},"setValue(0)")," again, resulting in an infinite recursion."),(0,l.kt)("p",null,"Executing a particular function call when the button is clicked can be accomplished like this:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"<button onClick={() => console.log('clicked the button')}>\n  button\n</button>\n")),(0,l.kt)("p",null,"Now the event handler is a function defined with the arrow function syntax ",(0,l.kt)("em",{parentName:"p"},"() => console.log('clicked the button')"),". When the component gets rendered, no function gets called and only the reference to the arrow function is set to the event handler. Calling the function happens only once the button is clicked."),(0,l.kt)("p",null,"We can implement resetting the state in our application with this same technique:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"<button onClick={() => setValue(0)}>button</button>\n")),(0,l.kt)("p",null,"The event handler is now the function ",(0,l.kt)("em",{parentName:"p"},"() => setValue(0)"),"."),(0,l.kt)("p",null,"Defining event handlers directly in the attribute of the button is not necessarily the best possible idea."),(0,l.kt)("p",null,"You will often see event handlers defined in a separate place. In the following version of our application we define a function that then gets assigned to the ",(0,l.kt)("em",{parentName:"p"},"handleClick")," variable in the body of the component function:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"const App = () => {\n  const [value, setValue] = useState(10)\n\n  const handleClick = () =>\n    console.log('clicked the button')\n\n  return (\n    <div>\n      {value}\n      <button onClick={handleClick}>button</button>\n    </div>\n  )\n}\n")),(0,l.kt)("p",null,"The ",(0,l.kt)("em",{parentName:"p"},"handleClick")," variable is now assigned to a reference to the function. The reference is passed to the button as the ",(0,l.kt)("i",null,"onClick")," attribute:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"<button onClick={handleClick}>button</button>\n")),(0,l.kt)("p",null,"Naturally, our event handler function can be composed of multiple commands. In these cases we use the longer curly brace syntax for arrow functions:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"const App = () => {\n  const [value, setValue] = useState(10)\n\n  \n  const handleClick = () => {\n    console.log('clicked the button')\n    setValue(0)\n  }\n   \n\n  return (\n    <div>\n      {value}\n      <button onClick={handleClick}>button</button>\n    </div>\n  )\n}\n")),(0,l.kt)("h3",{id:"function-that-returns-a-function"},"Function that returns a function"),(0,l.kt)("p",null,"Another way to define an event handler is to use ",(0,l.kt)("i",null,"function that returns a function"),"."),(0,l.kt)("p",null,"You probably won't need to use functions that return functions in any of the exercises in this course.  If the topic seems particularly confusing, you may skip over this section for now and return to it later."),(0,l.kt)("p",null,"Let's make the following changes to our code:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"const App = () => {\n  const [value, setValue] = useState(10)\n\n  \n  const hello = () => {\n    const handler = () => console.log('hello world')\n\n    return handler\n  }\n  \n\n  return (\n    <div>\n      {value}\n      <button onClick={hello()}>button</button>\n    </div>\n  )\n}\n")),(0,l.kt)("p",null,"The code functions correctly even though it looks complicated. "),(0,l.kt)("p",null,"The event handler is now set to a function call:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"<button onClick={hello()}>button</button>\n")),(0,l.kt)("p",null,"Earlier on we stated that an event handler may not be a call to a function, and that it has to be a function or a reference to a function. Why then does a function call work in this case?"),(0,l.kt)("p",null,"When the component is rendered, the following function gets executed:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"const hello = () => {\n  const handler = () => console.log('hello world')\n\n  return handler\n}\n")),(0,l.kt)("p",null,"The ",(0,l.kt)("i",null,"return value")," of the function is another function that is assigned to the ",(0,l.kt)("em",{parentName:"p"},"handler")," variable."),(0,l.kt)("p",null,"When React renders the line:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"<button onClick={hello()}>button</button>\n")),(0,l.kt)("p",null,"It assigns the return value of ",(0,l.kt)("em",{parentName:"p"},"hello()")," to the onClick attribute. Essentially the line gets transformed into:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"<button onClick={() => console.log('hello world')}>\n  button\n</button>\n")),(0,l.kt)("p",null,"Since the ",(0,l.kt)("em",{parentName:"p"},"hello")," function returns a function, the event handler is now a function."),(0,l.kt)("p",null,"What's the point of this concept?"),(0,l.kt)("p",null,"Let's change the code a tiny bit:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"const App = () => {\n  const [value, setValue] = useState(10)\n\n  \n  const hello = (who) => {\n    const handler = () => {\n      console.log('hello', who)\n    }\n\n    return handler\n  }\n    \n\n  return (\n    <div>\n      {value}\n        \n      <button onClick={hello('world')}>button</button>\n      <button onClick={hello('react')}>button</button>\n      <button onClick={hello('function')}>button</button>\n        \n    </div>\n  )\n}\n")),(0,l.kt)("p",null,"Now the application has three buttons with event handlers defined by the ",(0,l.kt)("em",{parentName:"p"},"hello")," function that accepts a parameter."),(0,l.kt)("p",null,"The first button is defined as"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"<button onClick={hello('world')}>button</button>\n")),(0,l.kt)("p",null,"The event handler is created by ",(0,l.kt)("i",null,"executing")," the function call ",(0,l.kt)("em",{parentName:"p"},"hello('world')"),". The function call returns the function:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"() => {\n  console.log('hello', 'world')\n}\n")),(0,l.kt)("p",null,"The second button is defined as:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"<button onClick={hello('react')}>button</button>\n")),(0,l.kt)("p",null,"The function call ",(0,l.kt)("em",{parentName:"p"},"hello('react')")," that creates the event handler returns:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"() => {\n  console.log('hello', 'react')\n}\n")),(0,l.kt)("p",null,"Both buttons get their own individualized event handlers."),(0,l.kt)("p",null,"Functions returning functions can be utilized in defining generic functionality that can be customized with parameters. The ",(0,l.kt)("em",{parentName:"p"},"hello")," function that creates the event handlers can be thought of as a factory that produces customized event handlers meant for greeting users."),(0,l.kt)("p",null,"Our current definition is slightly verbose:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"const hello = (who) => {\n  const handler = () => {\n    console.log('hello', who)\n  }\n\n  return handler\n}\n")),(0,l.kt)("p",null,"Let's eliminate the helper variables and directly return the created function:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"const hello = (who) => {\n  return () => {\n    console.log('hello', who)\n  }\n}\n")),(0,l.kt)("p",null,"Since our ",(0,l.kt)("em",{parentName:"p"},"hello")," function is composed of a single return command, we can omit the curly braces and use the more compact syntax for arrow functions:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"const hello = (who) =>\n  () => {\n    console.log('hello', who)\n  }\n")),(0,l.kt)("p",null,"Lastly, let's write all of the arrows on the same line:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"const hello = (who) => () => {\n  console.log('hello', who)\n}\n")),(0,l.kt)("p",null,"We can use the same trick to define event handlers that set the state of the component to a given value. Let's make the following changes to our code:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"const App = () => {\n  const [value, setValue] = useState(10)\n  \n  \n  const setToValue = (newValue) => () => {\n    console.log('value now', newValue)  // print the new value to console\n    setValue(newValue)\n  }\n  \n  \n  return (\n    <div>\n      {value}\n      \n      <button onClick={setToValue(1000)}>thousand</button>\n      <button onClick={setToValue(0)}>reset</button>\n      <button onClick={setToValue(value + 1)}>increment</button>\n      \n    </div>\n  )\n}\n")),(0,l.kt)("p",null,"When the component is rendered, the ",(0,l.kt)("i",null,"thousand")," button is created:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"<button onClick={setToValue(1000)}>thousand</button>\n")),(0,l.kt)("p",null,"The event handler is set to the return value of ",(0,l.kt)("em",{parentName:"p"},"setToValue(1000)")," which is the following function:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"() => {\n  console.log('value now', 1000)\n  setValue(1000)\n}\n")),(0,l.kt)("p",null,"The increase button is declared as follows:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"<button onClick={setToValue(value + 1)}>increment</button>\n")),(0,l.kt)("p",null,"The event handler is created by the function call ",(0,l.kt)("em",{parentName:"p"},"setToValue(value + 1)")," which receives as its parameter the current value of the state variable ",(0,l.kt)("em",{parentName:"p"},"value")," increased by one. If the value of ",(0,l.kt)("em",{parentName:"p"},"value")," was 10, then the created event handler would be the function:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"() => {\n  console.log('value now', 11)\n  setValue(11)\n}\n")),(0,l.kt)("p",null,"Using functions that return functions is not required to achieve this functionality. Let's return the ",(0,l.kt)("em",{parentName:"p"},"setToValue")," function that is responsible for updating state, into a normal function:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"const App = () => {\n  const [value, setValue] = useState(10)\n\n  const setToValue = (newValue) => {\n    console.log('value now', newValue)\n    setValue(newValue)\n  }\n\n  return (\n    <div>\n      {value}\n      <button onClick={() => setToValue(1000)}>\n        thousand\n      </button>\n      <button onClick={() => setToValue(0)}>\n        reset\n      </button>\n      <button onClick={() => setToValue(value + 1)}>\n        increment\n      </button>\n    </div>\n  )\n}\n")),(0,l.kt)("p",null,"We can now define the event handler as a function that calls the ",(0,l.kt)("em",{parentName:"p"},"setToValue")," function with an appropriate parameter. The event handler for resetting the application state would be:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"<button onClick={() => setToValue(0)}>reset</button>\n")),(0,l.kt)("p",null,"Choosing between the two presented ways of defining your event handlers is mostly a matter of taste."),(0,l.kt)("h3",{id:"passing-event-handlers-to-child-components"},"Passing Event Handlers to Child Components"),(0,l.kt)("p",null,"Let's extract the button into its own component:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"const Button = (props) => (\n  <button onClick={props.handleClick}>\n    {props.text}\n  </button>\n)\n")),(0,l.kt)("p",null,"The component gets the event handler function from the ",(0,l.kt)("em",{parentName:"p"},"handleClick")," prop, and the text of the button from the ",(0,l.kt)("em",{parentName:"p"},"text")," prop."),(0,l.kt)("p",null,"Using the ",(0,l.kt)("i",null,"Button")," component is simple, although we have to make sure that we use the correct attribute names when passing props to the component."),(0,l.kt)("p",null,(0,l.kt)("img",{loading:"lazy",src:n(5420).Z,width:"1424",height:"842"})),(0,l.kt)("h3",{id:"do-not-define-components-within-components"},"Do Not Define Components Within Components"),(0,l.kt)("p",null,"Let's start displaying the value of the application into its own ",(0,l.kt)("i",null,"Display")," component."),(0,l.kt)("p",null,"We will change the application by defining a new component inside of the ",(0,l.kt)("i",null,"App"),"-component."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},'// This is the right place to define a component\nconst Button = (props) => (\n  <button onClick={props.handleClick}>\n    {props.text}\n  </button>\n)\n\nconst App = () => {\n  const [value, setValue] = useState(10)\n\n  const setToValue = newValue => {\n    console.log(\'value now\', newValue)\n    setValue(newValue)\n  }\n\n  // Do not define components inside another component\n  const Display = props => <div>{props.value}</div> \n\n  return (\n    <div>\n      <Display value={value} />\n      <Button handleClick={() => setToValue(1000)} text="thousand" />\n      <Button handleClick={() => setToValue(0)} text="reset" />\n      <Button handleClick={() => setToValue(value + 1)} text="increment" />\n    </div>\n  )\n}\n')),(0,l.kt)("p",null,"The application still appears to work, but ",(0,l.kt)("strong",{parentName:"p"},"don't implement components like this!")," Never define components inside of other components. The method provides no benefits and leads to many unpleasant problems. The biggest problems are due to the fact that React treats a component defined inside of another component as a new component in every render. This makes it impossible for React to optimize the component."),(0,l.kt)("p",null,"Let's instead move the ",(0,l.kt)("i",null,"Display")," component function to its correct place, which is outside of the ",(0,l.kt)("i",null,"App")," component function:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},'const Display = props => <div>{props.value}</div>\n\nconst Button = (props) => (\n  <button onClick={props.handleClick}>\n    {props.text}\n  </button>\n)\n\nconst App = () => {\n  const [value, setValue] = useState(10)\n\n  const setToValue = newValue => {\n    console.log(\'value now\', newValue)\n    setValue(newValue)\n  }\n\n  return (\n    <div>\n      <Display value={value} />\n      <Button handleClick={() => setToValue(1000)} text="thousand" />\n      <Button handleClick={() => setToValue(0)} text="reset" />\n      <Button handleClick={() => setToValue(value + 1)} text="increment" />\n    </div>\n  )\n}\n')),(0,l.kt)("h3",{id:"useful-reading"},"Useful Reading"),(0,l.kt)("p",null,"The internet is full of React-related material. However, we use the new style of React that still a large majority of the material found online is outdated for our purposes."),(0,l.kt)("p",null,"You may find the following links useful:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"The ",(0,l.kt)("a",{parentName:"li",href:"https://reactjs.org/docs/hello-world.html"},"official React documentation")," is worth checking out at some point, although most of it will become relevant only later on in the course. Also, everything related to class-based components is irrelevant to us;"),(0,l.kt)("li",{parentName:"ul"},"Some courses on ",(0,l.kt)("a",{parentName:"li",href:"https://egghead.io"},"Egghead.io")," like ",(0,l.kt)("a",{parentName:"li",href:"https://egghead.io/courses/start-learning-react"},"Start learning React")," are of high quality, and recently updated ",(0,l.kt)("a",{parentName:"li",href:"https://egghead.io/courses/the-beginner-s-guide-to-reactjs"},"The Beginner's Guide to React")," is also relatively good; both courses introduce concepts that will also be introduced later on in this course. ",(0,l.kt)("strong",{parentName:"li"},"NB")," The first one uses class components but the latter uses the new functional ones.")),(0,l.kt)("h2",{id:"reference"},"Reference"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://fullstackopen.com"},"FullStackOpen: Part1 C")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://fullstackopen.com"},"FullStackOpen: Part1 D"))))}d.isMDXComponent=!0},3625:function(e,t,n){t.Z=n.p+"assets/images/10ea-8a7bb072c9efd6b39403eaac7788c36d.png"},86:function(e,t,n){t.Z=n.p+"assets/images/11ea-da49f7caa4bba213d050c49a69bed620.png"},5420:function(e,t,n){t.Z=n.p+"assets/images/12e-2b93ab756f05432a8d43a4016000d4a2.png"},9409:function(e,t,n){t.Z=n.p+"assets/images/4e-ed9dfac7167d4340feee6485a48be235.png"},9397:function(e,t,n){t.Z=n.p+"assets/images/5c-b73d0d3b4b6d7d2b2c43f943026ec358.png"},1553:function(e,t,n){t.Z=n.p+"assets/images/6x-0e55d48200f6a03920345b84297e18b7.png"},6787:function(e,t,n){t.Z=n.p+"assets/images/7a-106a133a75eb52d43040055c98123f74.png"},5640:function(e,t,n){t.Z=n.p+"assets/images/8a-0e605f901108395dc727332633c4e043.png"},1198:function(e,t,n){t.Z=n.p+"assets/images/9a-6f96c91148494c405bda0969cb62bec8.png"}}]);