"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[6349],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return d}});var o=n(7294);function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){s(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,o,s=function(e,t){if(null==e)return{};var n,o,s={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(s[n]=e[n]);return s}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}var l=o.createContext({}),u=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},c=function(e){var t=u(e.components);return o.createElement(l.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},p=o.forwardRef((function(e,t){var n=e.components,s=e.mdxType,a=e.originalType,l=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),p=u(n),d=s,m=p["".concat(l,".").concat(d)]||p[d]||h[d]||a;return n?o.createElement(m,r(r({ref:t},c),{},{components:n})):o.createElement(m,r({ref:t},c))}));function d(e,t){var n=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var a=n.length,r=new Array(a);r[0]=p;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:s,r[1]=i;for(var u=2;u<a;u++)r[u]=n[u];return o.createElement.apply(null,r)}return o.createElement.apply(null,n)}p.displayName="MDXCreateElement"},5593:function(e,t,n){n.r(t),n.d(t,{assets:function(){return c},contentTitle:function(){return l},default:function(){return d},frontMatter:function(){return i},metadata:function(){return u},toc:function(){return h}});var o=n(7462),s=n(3366),a=(n(7294),n(3905)),r=["components"],i={title:"Post Lecture Reading",sidebar_label:"Post Lecture",pagination_next:null,pagination_prev:null,hide_table_of_contents:!1,sidebar_position:5},l="After Lecture",u={unversionedId:"lecture-14/post-lecture",id:"lecture-14/post-lecture",title:"Post Lecture Reading",description:"Credits: The post lecture material has been written by Matti Luukkainen from University of Helsinki. The material is licensed under the Creative Commons BY-NC-SA 3.0 License.",source:"@site/docs/lecture-14/post-lecture.md",sourceDirName:"lecture-14",slug:"/lecture-14/post-lecture",permalink:"/sp2022/lecture-14/post-lecture",tags:[],version:"current",sidebarPosition:5,frontMatter:{title:"Post Lecture Reading",sidebar_label:"Post Lecture",pagination_next:null,pagination_prev:null,hide_table_of_contents:!1,sidebar_position:5},sidebar:"docs"},c={},h=[{value:"Project structure",id:"project-structure",level:2},{value:"Note on exports",id:"note-on-exports",level:2},{value:"async/await",id:"asyncawait",level:2},{value:"async/await in the backend",id:"asyncawait-in-the-backend",level:3},{value:"Refactoring the backend",id:"refactoring-the-backend",level:3},{value:"Error handling and async/await",id:"error-handling-and-asyncawait",level:3},{value:"Eliminating the try-catch",id:"eliminating-the-try-catch",level:3},{value:"User administration",id:"user-administration",level:2},{value:"References across collections",id:"references-across-collections",level:3},{value:"Mongoose schema for users",id:"mongoose-schema-for-users",level:3},{value:"Creating users",id:"creating-users",level:3},{value:"Creating a new note",id:"creating-a-new-note",level:3},{value:"Populate",id:"populate",level:3},{value:"Token authentication",id:"token-authentication",level:2},{value:"Limiting creating new notes to logged in users",id:"limiting-creating-new-notes-to-logged-in-users",level:3},{value:"Error handling",id:"error-handling",level:3},{value:"Problems of Token-based authentication",id:"problems-of-token-based-authentication",level:3},{value:"End notes",id:"end-notes",level:3},{value:"Reference",id:"reference",level:2}],p={toc:h};function d(e){var t=e.components,i=(0,s.Z)(e,r);return(0,a.kt)("wrapper",(0,o.Z)({},p,i,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"after-lecture"},"After Lecture"),(0,a.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,a.kt)("div",{parentName:"div",className:"admonition-heading"},(0,a.kt)("h5",{parentName:"div"},(0,a.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,a.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,a.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,a.kt)("div",{parentName:"div",className:"admonition-content"},(0,a.kt)("p",{parentName:"div"}," ",(0,a.kt)("strong",{parentName:"p"},"Credits"),": The post lecture material has been written by ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/mluukkai"},"Matti Luukkainen")," from ",(0,a.kt)("a",{parentName:"p",href:"https://fullstackopen.com/en/"},"University of Helsinki"),". The material is licensed under the Creative Commons BY-NC-SA 3.0 License."))),(0,a.kt)("h2",{id:"project-structure"},"Project structure"),(0,a.kt)("p",null,"We will  continue our work on the backend of the notes application. "),(0,a.kt)("p",null,"We start by modifying the structure of our project to adhere to Node.js best practices."),(0,a.kt)("p",null,"After making the changes to the directory structure of our project, we end up with the following structure:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"\u251c\u2500\u2500 index.js\n\u251c\u2500\u2500 app.js\n\u251c\u2500\u2500 build\n\u2502   \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 controllers\n\u2502   \u2514\u2500\u2500 notes.js\n\u251c\u2500\u2500 models\n\u2502   \u2514\u2500\u2500 note.js\n\u251c\u2500\u2500 package-lock.json\n\u251c\u2500\u2500 package.json\n\u251c\u2500\u2500 utils\n\u2502   \u251c\u2500\u2500 config.js\n\u2502   \u251c\u2500\u2500 logger.js\n\u2502   \u2514\u2500\u2500 middleware.js  \n")),(0,a.kt)("p",null,"So far we have been using ",(0,a.kt)("i",null,"console.log")," and ",(0,a.kt)("i",null,"console.error")," to print different information from the code.\nHowever, this is not a very good way to do things.\nLet's separate all printing to the console to its own module ",(0,a.kt)("i",null,"utils/logger.js"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"const info = (...params) => {\n  console.log(...params)\n}\n\nconst error = (...params) => {\n  console.error(...params)\n}\n\nmodule.exports = {\n  info, error\n}\n")),(0,a.kt)("p",null,"The logger has two functions, ",(0,a.kt)("strong",{parentName:"p"},"info")," for printing normal log messages, and ",(0,a.kt)("strong",{parentName:"p"},"error")," for all error messages. "),(0,a.kt)("p",null,"Extracting logging into its own module is a good idea in more ways than one. If we wanted to start writing logs to a file or send them to an external logging service like ",(0,a.kt)("a",{parentName:"p",href:"https://www.graylog.org/"},"graylog")," or ",(0,a.kt)("a",{parentName:"p",href:"https://papertrailapp.com"},"papertrail")," we would only have to make changes in one place."),(0,a.kt)("p",null,"The contents of the ",(0,a.kt)("i",null,"index.js")," file used for starting the application gets simplified as follows:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"const app = require('./app') // the actual Express application\nconst http = require('http')\nconst config = require('./utils/config')\nconst logger = require('./utils/logger')\n\nconst server = http.createServer(app)\n\nserver.listen(config.PORT, () => {\n  logger.info(`Server running on port ${config.PORT}`)\n})\n")),(0,a.kt)("p",null,"The ",(0,a.kt)("i",null,"index.js")," file only imports the actual application from the ",(0,a.kt)("i",null,"app.js")," file and then starts the application. The function ",(0,a.kt)("em",{parentName:"p"},"info")," of the logger-module is used for the console printout telling that the application is running."),(0,a.kt)("p",null,"The handling of environment variables is extracted into a separate ",(0,a.kt)("i",null,"utils/config.js")," file:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"require('dotenv').config()\n\nconst PORT = process.env.PORT\nconst MONGODB_URI = process.env.MONGODB_URI\n\nmodule.exports = {\n  MONGODB_URI,\n  PORT\n}\n")),(0,a.kt)("p",null,"The other parts of the application can access the environment variables by importing the configuration module:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"const config = require('./utils/config')\n\nlogger.info(`Server running on port ${config.PORT}`)\n")),(0,a.kt)("p",null,"The route handlers have also been moved into a dedicated module. The event handlers of routes are commonly referred to as ",(0,a.kt)("i",null,"controllers"),", and for this reason we have created a new ",(0,a.kt)("i",null,"controllers")," directory. All of the routes related to notes are now in the ",(0,a.kt)("i",null,"notes.js")," module under the ",(0,a.kt)("i",null,"controllers")," directory."),(0,a.kt)("p",null,"The contents of the ",(0,a.kt)("i",null,"notes.js")," module are the following:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"const notesRouter = require('express').Router()\nconst Note = require('../models/note')\n\nnotesRouter.get('/', (request, response) => {\n  Note.find({}).then(notes => {\n    response.json(notes)\n  })\n})\n\nnotesRouter.get('/:id', (request, response, next) => {\n  Note.findById(request.params.id)\n    .then(note => {\n      if (note) {\n        response.json(note)\n      } else {\n        response.status(404).end()\n      }\n    })\n    .catch(error => next(error))\n})\n\nnotesRouter.post('/', (request, response, next) => {\n  const body = request.body\n\n  const note = new Note({\n    content: body.content,\n    important: body.important || false,\n    date: new Date()\n  })\n\n  note.save()\n    .then(savedNote => {\n      response.json(savedNote)\n    })\n    .catch(error => next(error))\n})\n\nnotesRouter.delete('/:id', (request, response, next) => {\n  Note.findByIdAndRemove(request.params.id)\n    .then(() => {\n      response.status(204).end()\n    })\n    .catch(error => next(error))\n})\n\nnotesRouter.put('/:id', (request, response, next) => {\n  const body = request.body\n\n  const note = {\n    content: body.content,\n    important: body.important,\n  }\n\n  Note.findByIdAndUpdate(request.params.id, note, { new: true })\n    .then(updatedNote => {\n      response.json(updatedNote)\n    })\n    .catch(error => next(error))\n})\n\nmodule.exports = notesRouter\n")),(0,a.kt)("p",null,"This is almost an exact copy-paste of our previous ",(0,a.kt)("i",null,"index.js")," file."),(0,a.kt)("p",null,"However, there are a few significant changes. At the very beginning of the file we create a new ",(0,a.kt)("a",{parentName:"p",href:"http://expressjs.com/en/api.html#router"},"router")," object:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"const notesRouter = require('express').Router()\n\n//...\n\nmodule.exports = notesRouter\n")),(0,a.kt)("p",null,"The module exports the router to be available for all consumers of the module."),(0,a.kt)("p",null,"All routes are now defined for the router object, in a similar fashion to what we had previously done with the object representing the entire application."),(0,a.kt)("p",null,"It's worth noting that the paths in the route handlers have shortened. In the previous version, we had:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"app.delete('/api/notes/:id', (request, response) => {\n")),(0,a.kt)("p",null,"And in the current version, we have:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"notesRouter.delete('/:id', (request, response) => {\n")),(0,a.kt)("p",null,"So what are these router objects exactly? The Express manual provides the following explanation:"),(0,a.kt)("blockquote",null,(0,a.kt)("i",null,"A router object is an isolated instance of middleware and routes. You can think of it as a \u201cmini-application,\u201d capable only of performing middleware and routing functions. Every Express application has a built-in app router.")),(0,a.kt)("p",null,"The router is in fact a ",(0,a.kt)("i",null,"middleware"),', that can be used for defining "related routes" in a single place, that is typically placed in its own module.'),(0,a.kt)("p",null,"The ",(0,a.kt)("i",null,"app.js")," file that creates the actual application, takes the router into use as shown below:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"const notesRouter = require('./controllers/notes')\napp.use('/api/notes', notesRouter)\n")),(0,a.kt)("p",null,"The router we defined earlier is used ",(0,a.kt)("i",null,"if")," the URL of the request starts with ",(0,a.kt)("i",null,"/api/notes"),". For this reason, the notesRouter object must only define the relative parts of the routes, i.e. the empty path ",(0,a.kt)("i",null,"/")," or just the parameter ",(0,a.kt)("i",null,"/:id"),"."),(0,a.kt)("p",null,"After making these changes, our ",(0,a.kt)("i",null,"app.js")," file looks like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"const config = require('./utils/config')\nconst express = require('express')\nconst app = express()\nconst cors = require('cors')\nconst notesRouter = require('./controllers/notes')\nconst middleware = require('./utils/middleware')\nconst logger = require('./utils/logger')\nconst mongoose = require('mongoose')\n\nlogger.info('connecting to', config.MONGODB_URI)\n\nmongoose.connect(config.MONGODB_URI)\n  .then(() => {\n    logger.info('connected to MongoDB')\n  })\n  .catch((error) => {\n    logger.error('error connecting to MongoDB:', error.message)\n  })\n\napp.use(cors())\napp.use(express.static('build'))\napp.use(express.json())\napp.use(middleware.requestLogger)\n\napp.use('/api/notes', notesRouter)\n\napp.use(middleware.unknownEndpoint)\napp.use(middleware.errorHandler)\n\nmodule.exports = app\n")),(0,a.kt)("p",null,"The file takes different middleware into use, and one of these is the ",(0,a.kt)("i",null,"notesRouter")," that is attached to the ",(0,a.kt)("i",null,"/api/notes")," route."),(0,a.kt)("p",null,"Our custom middleware has been moved to a new ",(0,a.kt)("i",null,"utils/middleware.js")," module:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"const logger = require('./logger')\n\nconst requestLogger = (request, response, next) => {\n  logger.info('Method:', request.method)\n  logger.info('Path:  ', request.path)\n  logger.info('Body:  ', request.body)\n  logger.info('---')\n  next()\n}\n\nconst unknownEndpoint = (request, response) => {\n  response.status(404).send({ error: 'unknown endpoint' })\n}\n\nconst errorHandler = (error, request, response, next) => {\n  logger.error(error.message)\n\n  if (error.name === 'CastError') {\n    return response.status(400).send({ error: 'malformatted id' })\n  } else if (error.name === 'ValidationError') {\n    return response.status(400).json({ error: error.message })\n  }\n\n  next(error)\n}\n\nmodule.exports = {\n  requestLogger,\n  unknownEndpoint,\n  errorHandler\n}\n")),(0,a.kt)("p",null,"The responsibility of establishing the connection to the database has been given to the  ",(0,a.kt)("i",null,"app.js")," module. The ",(0,a.kt)("i",null,"note.js")," file under the ",(0,a.kt)("i",null,"models")," directory only defines the Mongoose schema for notes."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"const mongoose = require('mongoose')\n\nconst noteSchema = new mongoose.Schema({\n  content: {\n    type: String,\n    required: true,\n    minlength: 5\n  },\n  date: {\n    type: Date,\n    required: true,\n  },\n  important: Boolean,\n})\n\nnoteSchema.set('toJSON', {\n  transform: (document, returnedObject) => {\n    returnedObject.id = returnedObject._id.toString()\n    delete returnedObject._id\n    delete returnedObject.__v\n  }\n})\n\nmodule.exports = mongoose.model('Note', noteSchema)\n")),(0,a.kt)("p",null,"To recap, the directory structure looks like this after the changes have been made:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"\u251c\u2500\u2500 index.js\n\u251c\u2500\u2500 app.js\n\u251c\u2500\u2500 build\n\u2502   \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 controllers\n\u2502   \u2514\u2500\u2500 notes.js\n\u251c\u2500\u2500 models\n\u2502   \u2514\u2500\u2500 note.js\n\u251c\u2500\u2500 package-lock.json\n\u251c\u2500\u2500 package.json\n\u251c\u2500\u2500 utils\n\u2502   \u251c\u2500\u2500 config.js\n\u2502   \u251c\u2500\u2500 logger.js\n\u2502   \u2514\u2500\u2500 middleware.js  \n")),(0,a.kt)("p",null,"For smaller applications the structure does not matter that much. Once the application starts to grow in size, you are going to have to establish some kind of structure, and separate the different responsibilities of the application into separate modules. This will make developing the application much easier."),(0,a.kt)("p",null,"There is no strict directory structure or file naming convention that is required for Express applications. To contrast this, Ruby on Rails does require a specific structure. Our current structure simply follows some of the best practices you can come across on the internet."),(0,a.kt)("p",null,"You can find the code for our current application in its entirety in the ",(0,a.kt)("i",null,"part4-1")," branch of ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/fullstack-hy/part3-notes-backend/tree/part4-1"},"this Github repository"),"."),(0,a.kt)("p",null,"If you clone the project for yourself, run the ",(0,a.kt)("em",{parentName:"p"},"npm install")," command before starting the application with ",(0,a.kt)("em",{parentName:"p"},"npm start"),"."),(0,a.kt)("h2",{id:"note-on-exports"},"Note on exports"),(0,a.kt)("p",null,"We have used two different kings of exports in this parts. Firstly, eg. the file ",(0,a.kt)("i",null,"utils/logger.js")," does the export as follows:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"const info = (...params) => {\n  console.log(...params)\n}\n\nconst error = (...params) => {\n  console.error(...params)\n}\n\n// highlight-start\nmodule.exports = {\n  info, error\n}\n// highlight-end\n")),(0,a.kt)("p",null,"The file exports ",(0,a.kt)("i",null,"an object")," that has two fields, both of which are functions. The functions can be used with two different ways. The first option is to require the whole object and refer to functions throught he object using the dot notation: "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"const logger = require('./utils/logger')\n\nlogger.info('message')\n\nlogger.error('error message')\n")),(0,a.kt)("p",null,"The other option is to destructure the functions to own variables in the ",(0,a.kt)("i",null,"require")," statement:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"const { info, error } = require('./utils/logger')\n\ninfo('message')\nerror('error message')\n")),(0,a.kt)("p",null,"The latter may be preferable way if only small portion of exported functions are used in a file."),(0,a.kt)("p",null,"Eg. in file ",(0,a.kt)("i",null,"controller/notes.js")," exporting happens as follows:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"const notesRouter = require('express').Router()\nconst Note = require('../models/note')\n\n// ...\n\nmodule.exports = notesRouter // highlight-line\n")),(0,a.kt)("p",null,'In this case there is just one "thing" exported, so the only way to use it is the following:'),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"const notesRouter = require('./controllers/notes')\n\n// ...\n\napp.use('/api/notes', notesRouter)\n")),(0,a.kt)("p",null,'Now the exported "thing" (in this case a router object) is assigned to a variable and used as such.'),(0,a.kt)("h2",{id:"asyncawait"},"async/await"),(0,a.kt)("p",null,"Let's take a look at the ",(0,a.kt)("em",{parentName:"p"},"async")," and ",(0,a.kt)("em",{parentName:"p"},"await")," keywords. "),(0,a.kt)("p",null,"The async/await syntax that was introduced in ES7 makes it possible to use ",(0,a.kt)("i",null,"asynchronous functions that return a promise")," in a way that makes the code look synchronous."),(0,a.kt)("p",null,"As an example, the fetching of notes from the database with promises looks like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"Note.find({}).then(notes => {\n  console.log('operation returned the following notes', notes)\n})\n")),(0,a.kt)("p",null,"The ",(0,a.kt)("em",{parentName:"p"},"Note.find()")," method returns a promise and we can access the result of the operation by registering a callback function with the ",(0,a.kt)("em",{parentName:"p"},"then")," method."),(0,a.kt)("p",null,"All of the code we want to execute once the operation finishes is written in the callback function. If we wanted to make several asynchronous function calls in sequence, the situation would soon become painful. The asynchronous calls would have to be made in the callback. This would likely lead to complicated code and could potentially give birth to a so-called ",(0,a.kt)("a",{parentName:"p",href:"http://callbackhell.com/"},"callback hell"),"."),(0,a.kt)("p",null,"By ",(0,a.kt)("a",{parentName:"p",href:"https://javascript.info/promise-chaining"},"chaining promises")," we could keep the situation somewhat under control, and avoid callback hell by creating a fairly clean chain of ",(0,a.kt)("em",{parentName:"p"},"then")," method calls. We have seen a few of these during the course. To illustrate this, you can view an artificial example of a function that fetches all notes and then deletes the first one:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"Note.find({})\n  .then(notes => {\n    return notes[0].remove()\n  })\n  .then(response => {\n    console.log('the first note is removed')\n    // more code here\n  })\n")),(0,a.kt)("p",null,"The then-chain is alright, but we can do better. The ",(0,a.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator"},"generator functions")," introduced in ES6 provided a ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/getify/You-Dont-Know-JS/blob/1st-ed/async%20%26%20performance/ch4.md#iterating-generators-asynchronously"},"clever way"),' of writing asynchronous code in a way that "looks synchronous". The syntax is a bit clunky and not widely used.'),(0,a.kt)("p",null,"The ",(0,a.kt)("em",{parentName:"p"},"async")," and ",(0,a.kt)("em",{parentName:"p"},"await")," keywords introduced in ES7 bring the same functionality as the generators, but in an understandable and syntactically cleaner way to the hands of all citizens of the JavaScript world."),(0,a.kt)("p",null,"We could fetch all of the notes in the database by utilizing the ",(0,a.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await"},"await")," operator like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"const notes = await Note.find({})\n\nconsole.log('operation returned the following notes', notes)\n")),(0,a.kt)("p",null,"The code looks exactly like synchronous code. The execution of code pauses at ",(0,a.kt)("em",null,"const notes = await Note.find({})")," and waits until the related promise is ",(0,a.kt)("i",null,"fulfilled"),", and then continues its execution to the next line. When the execution continues, the result of the operation that returned a promise is assigned to the ",(0,a.kt)("em",{parentName:"p"},"notes")," variable."),(0,a.kt)("p",null,"The slightly complicated example presented above could be implemented by using await like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"const notes = await Note.find({})\nconst response = await notes[0].remove()\n\nconsole.log('the first note is removed')\n")),(0,a.kt)("p",null,"Thanks to the new syntax, the code is a lot simpler than the previous then-chain."),(0,a.kt)("p",null,"There are a few important details to pay attention to when using async/await syntax. In order to use the await operator with asynchronous operations, they have to return a promise. This is not a problem as such, as regular asynchronous functions using callbacks are easy to wrap around promises."),(0,a.kt)("p",null,"The await keyword can't be used just anywhere in JavaScript code. Using await is possible only inside of an ",(0,a.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function"},"async")," function."),(0,a.kt)("p",null,"This means that in order for the previous examples to work, they have to be using async functions. Notice the first line in the arrow function definition:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"const main = async () => { // highlight-line\n  const notes = await Note.find({})\n  console.log('operation returned the following notes', notes)\n\n  const response = await notes[0].remove()\n  console.log('the first note is removed')\n}\n\nmain() // highlight-line\n")),(0,a.kt)("p",null,"The code declares that the function assigned to ",(0,a.kt)("em",{parentName:"p"},"main")," is asynchronous. After this the code calls the function with ",(0,a.kt)("code",null,"main()"),"."),(0,a.kt)("h3",{id:"asyncawait-in-the-backend"},"async/await in the backend"),(0,a.kt)("p",null,"Let's start to change the backend to async and await. As all of the asynchronous operations are currently done inside of a function, it is enough to change the route handler functions into async functions."),(0,a.kt)("p",null,"The route for fetching all notes gets changed to the following:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"notesRouter.get('/', async (request, response) => { \n  const notes = await Note.find({})\n  response.json(notes)\n})\n")),(0,a.kt)("p",null,"We can verify that our refactoring was successful by testing the endpoint through the browser."),(0,a.kt)("p",null,"You can find the code for our current application in its entirety in the ",(0,a.kt)("i",null,"part4-3")," branch of ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/fullstack-hy/part3-notes-backend/tree/part4-3"},"this Github repository"),"."),(0,a.kt)("h3",{id:"refactoring-the-backend"},"Refactoring the backend"),(0,a.kt)("p",null,"When code gets refactored, there is always the risk of ",(0,a.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Regression_testing"},"regression"),", meaning that existing functionality may break. "),(0,a.kt)("p",null,"We are returning by accident the status code ",(0,a.kt)("i",null,"200 OK")," when a new note is created. Let us change that to ",(0,a.kt)("i",null,"201 CREATED"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"notesRouter.post('/', (request, response, next) => {\n  const body = request.body\n\n  const note = new Note({\n    content: body.content,\n    important: body.important || false,\n    date: new Date(),\n  })\n\n  note.save()\n    .then(savedNote => {\n      response.status(201).json(savedNote) // highlight-line\n    })\n    .catch(error => next(error))\n})\n")),(0,a.kt)("p",null,"We make the following changes to the code that takes care of adding a new note(notice that the route handler definition is preceded by the ",(0,a.kt)("em",{parentName:"p"},"async")," keyword):"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"notesRouter.post('/', async (request, response, next) => {\n  const body = request.body\n\n  const note = new Note({\n    content: body.content,\n    important: body.important || false,\n    date: new Date(),\n  })\n\n  const savedNote = await note.save()\n  response.status(201).json(savedNote)\n})\n")),(0,a.kt)("p",null,"There's a slight problem with our code: we don't handle error situations. How should we deal with them?"),(0,a.kt)("h3",{id:"error-handling-and-asyncawait"},"Error handling and async/await"),(0,a.kt)("p",null,"If there's an exception while handling the POST request we end up in a familiar situation:"),(0,a.kt)("p",null,(0,a.kt)("img",{loading:"lazy",src:n(8861).Z,width:"1610",height:"544"})),(0,a.kt)("p",null,"In other words we end up with an unhandled promise rejection, and the request never receives a response."),(0,a.kt)("p",null,"With async/await the recommended way of dealing with exceptions is the old and familiar ",(0,a.kt)("em",{parentName:"p"},"try/catch")," mechanism:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"notesRouter.post('/', async (request, response, next) => {\n  const body = request.body\n\n  const note = new Note({\n    content: body.content,\n    important: body.important || false,\n    date: new Date(),\n  })\n  // highlight-start\n  try {\n    const savedNote = await note.save()\n    response.status(201).json(savedNote)\n  } catch(exception) {\n    next(exception)\n  }\n  // highlight-end\n})\n")),(0,a.kt)("p",null,"The catch block simply calls the ",(0,a.kt)("em",{parentName:"p"},"next")," function, which passes the request handling to the error handling middleware."),(0,a.kt)("p",null,"we can safely refactor the routes to use async/await:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"notesRouter.get('/:id', async (request, response, next) => {\n  try {\n    const note = await Note.findById(request.params.id)\n    if (note) {\n      response.json(note)\n    } else {\n      response.status(404).end()\n    }\n  } catch(exception) {\n    next(exception)\n  }\n})\n\nnotesRouter.delete('/:id', async (request, response, next) => {\n  try {\n    await Note.findByIdAndRemove(request.params.id)\n    response.status(204).end()\n  } catch (exception) {\n    next(exception)\n  }\n})\n")),(0,a.kt)("p",null,"You can find the code for our current application in its entirety in the ",(0,a.kt)("i",null,"part4-4")," branch of ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/fullstack-hy/part3-notes-backend/tree/part4-4"},"this Github repository"),"."),(0,a.kt)("h3",{id:"eliminating-the-try-catch"},"Eliminating the try-catch"),(0,a.kt)("p",null,"Async/await unclutters the code a bit, but the 'price' is the ",(0,a.kt)("i",null,"try/catch")," structure required for catching exceptions.\nAll of the route handlers follow the same structure"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"try {\n  // do the async operations here\n} catch(exception) {\n  next(exception)\n}\n")),(0,a.kt)("p",null,"One starts to wonder, if it would be possible to refactor the code to eliminate the ",(0,a.kt)("i",null,"catch")," from the methods?"),(0,a.kt)("p",null,"The ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/davidbanham/express-async-errors"},"express-async-errors")," library has a solution for this. "),(0,a.kt)("p",null,"Let's install the library"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"npm install express-async-errors\n")),(0,a.kt)("p",null,"Using the library is ",(0,a.kt)("i",null,"very")," easy.\nYou introduce the library in ",(0,a.kt)("i",null,"app.js"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"const config = require('./utils/config')\nconst express = require('express')\nrequire('express-async-errors') // highlight-line\nconst app = express()\nconst cors = require('cors')\nconst notesRouter = require('./controllers/notes')\nconst middleware = require('./utils/middleware')\nconst logger = require('./utils/logger')\nconst mongoose = require('mongoose')\n\n// ...\n\nmodule.exports = app\n")),(0,a.kt)("p",null,"The 'magic' of the library allows us to eliminate the try-catch blocks completely.\nFor example the route for deleting a note"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"notesRouter.delete('/:id', async (request, response, next) => {\n  try {\n    await Note.findByIdAndRemove(request.params.id)\n    response.status(204).end()\n  } catch (exception) {\n    next(exception)\n  }\n})\n")),(0,a.kt)("p",null,"becomes"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"notesRouter.delete('/:id', async (request, response) => {\n  await Note.findByIdAndRemove(request.params.id)\n  response.status(204).end()\n})\n")),(0,a.kt)("p",null,"Because of the library, we do not need the ",(0,a.kt)("em",{parentName:"p"},"next(exception)")," call anymore.\nThe library handles everything under the hood. If an exception occurs in a ",(0,a.kt)("i",null,"async")," route, the execution is automatically passed to the error handling middleware."),(0,a.kt)("p",null,"The other routes become:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"notesRouter.post('/', async (request, response) => {\n  const body = request.body\n\n  const note = new Note({\n    content: body.content,\n    important: body.important || false,\n    date: new Date(),\n  })\n\n  const savedNote = await note.save()\n  response.json(savedNote)\n})\n\nnotesRouter.get('/:id', async (request, response) => {\n  const note = await Note.findById(request.params.id)\n  if (note) {\n    response.json(note)\n  } else {\n    response.status(404).end()\n  }\n})\n")),(0,a.kt)("h2",{id:"user-administration"},"User administration"),(0,a.kt)("p",null,"We want to add user authentication and authorization to our application. Users should be stored in the database and every note should be linked to the user who created it. Deleting and editing a note should only be allowed for the user who created it."),(0,a.kt)("p",null,"Let's start by adding information about users to the database. There is a one-to-many relationship between the user (",(0,a.kt)("i",null,"User"),") and notes (",(0,a.kt)("i",null,"Note"),"):"),(0,a.kt)("p",null,(0,a.kt)("img",{parentName:"p",src:"https://yuml.me/a187045b.png",alt:null})),(0,a.kt)("p",null,"If we were working with a relational database the implementation would be straightforward. Both resources would have their separate database tables, and the id of the user who created a note would be stored in the notes table as a foreign key."),(0,a.kt)("p",null,"When working with document databases the situation is a bit different, as there are many different ways of modeling the situation."),(0,a.kt)("p",null,"The existing solution saves every note in the ",(0,a.kt)("i",null,"notes collection")," in the database. If we do not want to change this existing collection, then the natural choice is to save users in their own collection,  ",(0,a.kt)("i",null,"users")," for example."),(0,a.kt)("p",null,"Like with all document databases, we can use object id's in Mongo to reference documents in other collections. This is similar to using foreign keys in relational databases."),(0,a.kt)("p",null,"Traditionally document databases like Mongo do not support  ",(0,a.kt)("i",null,"join queries")," that are available in relational databases,  used for aggregating data from multiple tables. However starting from version 3.2. Mongo has supported ",(0,a.kt)("a",{parentName:"p",href:"https://docs.mongodb.com/manual/reference/operator/aggregation/lookup/"},"lookup aggregation queries"),". We will not be taking a look at this functionality in this course."),(0,a.kt)("p",null,"If we need a functionality similar to join queries, we will implement it in our application code by making multiple queries. In certain situations Mongoose can take care of joining and aggregating data, which gives the appearance of a join query. However, even in these situations Mongoose makes multiple queries to the database in the background."),(0,a.kt)("h3",{id:"references-across-collections"},"References across collections"),(0,a.kt)("p",null,"If we were using a relational database the note would contain a ",(0,a.kt)("i",null,"reference key")," to the user who created it. In document databases we can do the same thing. "),(0,a.kt)("p",null,"Let's assume that the ",(0,a.kt)("i",null,"users")," collection contains two users:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"[\n  {\n    username: 'mluukkai',\n    _id: 123456,\n  },\n  {\n    username: 'hellas',\n    _id: 141414,\n  },\n];\n")),(0,a.kt)("p",null,"The ",(0,a.kt)("i",null,"notes")," collection contains three notes that all have a ",(0,a.kt)("i",null,"user")," field that references a user in the ",(0,a.kt)("i",null,"users")," collection:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"[\n  {\n    content: 'HTML is easy',\n    important: false,\n    _id: 221212,\n    user: 123456,\n  },\n  {\n    content: 'The most important operations of HTTP protocol are GET and POST',\n    important: true,\n    _id: 221255,\n    user: 123456,\n  },\n  {\n    content: 'A proper dinosaur codes with Java',\n    important: false,\n    _id: 221244,\n    user: 141414,\n  },\n]\n")),(0,a.kt)("p",null,"Document databases do not demand the foreign key to be stored in the note resources, it could ",(0,a.kt)("i",null,"also")," be stored in the users collection, or even both:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"[\n  {\n    username: 'mluukkai',\n    _id: 123456,\n    notes: [221212, 221255],\n  },\n  {\n    username: 'hellas',\n    _id: 141414,\n    notes: [221244],\n  },\n]\n")),(0,a.kt)("p",null,"Since users can have many notes, the related ids are stored in an array in the ",(0,a.kt)("i",null,"notes")," field."),(0,a.kt)("p",null,"Document databases also offer a radically different way of organizing the data: In some situations it might be beneficial to nest the entire notes array as a part of the documents in the users collection:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"[\n  {\n    username: 'mluukkai',\n    _id: 123456,\n    notes: [\n      {\n        content: 'HTML is easy',\n        important: false,\n      },\n      {\n        content: 'The most important operations of HTTP protocol are GET and POST',\n        important: true,\n      },\n    ],\n  },\n  {\n    username: 'hellas',\n    _id: 141414,\n    notes: [\n      {\n        content:\n          'A proper dinosaur codes with Java',\n        important: false,\n      },\n    ],\n  },\n]\n")),(0,a.kt)("p",null,"In this schema notes would be tightly nested under users and the database would not generate ids for them."),(0,a.kt)("p",null,"The structure and schema of the database is not as self-evident as it was with relational databases. The chosen schema must be one which supports the use cases of the application the best. This is not a simple design decision to make, as all use cases of the applications are not known when the design decision is made."),(0,a.kt)("p",null,"Paradoxically, schema-less databases like Mongo require developers to make far more radical design decisions about data organization at the beginning of the project than relational databases with schemas. On average, relational databases offer a more-or-less suitable way of organizing data for many applications."),(0,a.kt)("h3",{id:"mongoose-schema-for-users"},"Mongoose schema for users"),(0,a.kt)("p",null,"In this case, we make the decision to store the ids of the notes created by the user in the user document. Let's define the model for representing a user in the ",(0,a.kt)("i",null,"models/user.js")," file:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"const mongoose = require('mongoose')\n\nconst userSchema = new mongoose.Schema({\n  username: String,\n  name: String,\n  passwordHash: String,\n  notes: [\n    {\n      type: mongoose.Schema.Types.ObjectId,\n      ref: 'Note'\n    }\n  ],\n})\n\nuserSchema.set('toJSON', {\n  transform: (document, returnedObject) => {\n    returnedObject.id = returnedObject._id.toString()\n    delete returnedObject._id\n    delete returnedObject.__v\n    // the passwordHash should not be revealed\n    delete returnedObject.passwordHash\n  }\n})\n\nconst User = mongoose.model('User', userSchema)\n\nmodule.exports = User\n")),(0,a.kt)("p",null,"The ids of the notes are stored within the user document as an array of Mongo ids. The definition is as follows:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"{\n  type: mongoose.Schema.Types.ObjectId,\n  ref: 'Note'\n}\n")),(0,a.kt)("p",null,"The type of the field is ",(0,a.kt)("i",null,"ObjectId")," that references ",(0,a.kt)("i",null,"note"),"-style documents. Mongo does not inherently know that this is a field that references notes, the syntax is purely related to and defined by Mongoose."),(0,a.kt)("p",null,"Let's expand the schema of the note defined in the ",(0,a.kt)("i",null,"models/note.js")," file so that the note contains information about the user who created it:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"const noteSchema = new mongoose.Schema({\n  content: {\n    type: String,\n    required: true,\n    minlength: 5\n  },\n  date: Date,\n  important: Boolean,\n  // highlight-start\n  user: {\n    type: mongoose.Schema.Types.ObjectId,\n    ref: 'User'\n  }\n  // highlight-end\n})\n")),(0,a.kt)("p",null,"In stark contrast to the conventions of relational databases, ",(0,a.kt)("i",null,"references are now stored in both documents"),": the note references the user who created it, and the user has an array of references to all of the notes created by them."),(0,a.kt)("h3",{id:"creating-users"},"Creating users"),(0,a.kt)("p",null,"Let's implement a route for creating new users. Users have a unique ",(0,a.kt)("i",null,"username"),", a ",(0,a.kt)("i",null,"name")," and something called a ",(0,a.kt)("i",null,"passwordHash"),". The password hash is the output of a ",(0,a.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Cryptographic_hash_function"},"one-way hash function")," applied to the user's password. It is never wise to store unencrypted plain text passwords in the database!"),(0,a.kt)("p",null,"Let's install the ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/kelektiv/node.bcrypt.js"},"bcrypt")," package for generating the password hashes:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"npm install bcrypt\n")),(0,a.kt)("p",null,"Creating new users happens in compliance with the RESTful conventions, by making an HTTP POST request to the ",(0,a.kt)("i",null,"users")," path."),(0,a.kt)("p",null,"Let's define a separate ",(0,a.kt)("i",null,"router")," for dealing with users in a new ",(0,a.kt)("i",null,"controllers/users.js")," file. Let's take the router into use in our application in the ",(0,a.kt)("i",null,"app.js")," file, so that it handles requests made to the ",(0,a.kt)("i",null,"/api/users")," url:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"const usersRouter = require('./controllers/users')\n\n// ...\n\napp.use('/api/users', usersRouter)\n")),(0,a.kt)("p",null,"The contents of the file that defines the router are as follows:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"const bcrypt = require('bcrypt')\nconst usersRouter = require('express').Router()\nconst User = require('../models/user')\n\nusersRouter.post('/', async (request, response) => {\n  const { username, name, password } = request.body\n\n  const saltRounds = 10\n  const passwordHash = await bcrypt.hash(password, saltRounds)\n\n  const user = new User({\n    username,\n    name,\n    passwordHash,\n  })\n\n  const savedUser = await user.save()\n\n  response.status(201).json(savedUser)\n})\n\nmodule.exports = usersRouter\n")),(0,a.kt)("p",null,"The password sent in the request is ",(0,a.kt)("i",null,"not")," stored in the database. We store the ",(0,a.kt)("i",null,"hash")," of the password that is generated with the ",(0,a.kt)("em",{parentName:"p"},"bcrypt.hash")," function."),(0,a.kt)("p",null,"The fundamentals of ",(0,a.kt)("a",{parentName:"p",href:"https://codahale.com/how-to-safely-store-a-password/"},"storing passwords")," are outside the scope of this course material. We will not discuss what the magic number 10 assigned to the ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/kelektiv/node.bcrypt.js/#a-note-on-rounds"},"saltRounds")," variable means, but you can read more about it in the linked material."),(0,a.kt)("p",null,"Our current code does not contain any error handling or input validation for verifying that the username and password are in the desired format."),(0,a.kt)("p",null,"The new feature can and should initially be tested manually with a tool like Postman. "),(0,a.kt)("p",null,"Mongoose does not have a built-in validator for checking the uniqueness of a field. In principle we could find a ready-made solution for this from the ",(0,a.kt)("a",{parentName:"p",href:"https://www.npmjs.com/package/mongoose-unique-validator"},"mongoose-unique-validator")," npm package but unfortunately at the time of writing (24th Jan 2022)\nmongoose-unique-validator does not work with Mongoose version 6.x, so we have to implement the uniqueness check by ourselves in the controller:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"usersRouter.post('/', async (request, response) => {\n  const { username, name, password } = request.body\n\n// highlight-start\n  const existingUser = await User.findOne({ username })\n  if (existingUser) {\n    return response.status(400).json({\n      error: 'username must be unique'\n    })\n  }\n  // highlight-end\n\n  const saltRounds = 10\n  const passwordHash = await bcrypt.hash(password, saltRounds)\n\n  const user = new User({\n    username,\n    name,\n    passwordHash,\n  })\n\n  const savedUser = await user.save()\n\n  response.status(201).json(savedUser)\n})\n")),(0,a.kt)("p",null,"We could also implement other validations into the user creation. We could check that the username is long enough, that the username only consists of permitted characters, or that the password is strong enough. Implementing these functionalities is left as an optional exercise."),(0,a.kt)("p",null,"Before we move onward, let's add an initial implementation of a route handler that returns all of the users in the database:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"usersRouter.get('/', async (request, response) => {\n  const users = await User.find({})\n  response.json(users)\n})\n")),(0,a.kt)("p",null,"For making new users in a production or development environment, you may send a POST request to ",(0,a.kt)("inlineCode",{parentName:"p"},"/api/users/")," via Postman or REST Client in the following format:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'{\n    "notes": [],\n    "username": "root",\n    "name": "Superuser",\n    "password": "salainen"\n}\n\n')),(0,a.kt)("p",null,"The list looks like this:"),(0,a.kt)("p",null,(0,a.kt)("img",{loading:"lazy",src:n(1857).Z,width:"1332",height:"562"})),(0,a.kt)("p",null,"You can find the code for our current application in its entirety in the ",(0,a.kt)("i",null,"part4-7")," branch of ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/fullstack-hy2020/part3-notes-backend/tree/part4-7"},"this github repository"),"."),(0,a.kt)("h3",{id:"creating-a-new-note"},"Creating a new note"),(0,a.kt)("p",null,"The code for creating a new note has to be updated so that the note is assigned to the user who created it."),(0,a.kt)("p",null,"Let's expand our current implementation so, that the information about the user who created a note is sent in the ",(0,a.kt)("i",null,"userId")," field of the request body:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"const User = require('../models/user') //highlight-line\n\n//...\n\nnotesRouter.post('/', async (request, response, next) => {\n  const body = request.body\n\n  const user = await User.findById(body.userId) //highlight-line\n\n  const note = new Note({\n    content: body.content,\n    important: body.important === undefined ? false : body.important,\n    date: new Date(),\n    user: user._id //highlight-line\n  })\n\n  const savedNote = await note.save()\n  user.notes = user.notes.concat(savedNote._id) //highlight-line\n  await user.save()  //highlight-line\n  \n  response.json(savedNote)\n})\n")),(0,a.kt)("p",null,"It's worth noting that the ",(0,a.kt)("i",null,"user")," object also changes. The ",(0,a.kt)("i",null,"id")," of the note is stored in the ",(0,a.kt)("i",null,"notes")," field:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"const user = await User.findById(body.userId)\n\n// ...\n\nuser.notes = user.notes.concat(savedNote._id)\nawait user.save()\n")),(0,a.kt)("p",null,"Let's try to create a new note"),(0,a.kt)("p",null,(0,a.kt)("img",{loading:"lazy",src:n(9863).Z,width:"1590",height:"506"})),(0,a.kt)("p",null,"The operation appears to work. Let's add one more note and then visit the route for fetching all users:"),(0,a.kt)("p",null,(0,a.kt)("img",{loading:"lazy",src:n(7795).Z,width:"1416",height:"624"})),(0,a.kt)("p",null,"We can see that the user has two notes. "),(0,a.kt)("p",null,"Likewise, the ids of the users who created the notes can be seen when we visit the route for fetching all notes:"),(0,a.kt)("p",null,(0,a.kt)("img",{loading:"lazy",src:n(7528).Z,width:"1466",height:"802"})),(0,a.kt)("h3",{id:"populate"},"Populate"),(0,a.kt)("p",null,"We would like our API to work in such a way, that when an HTTP GET request is made to the ",(0,a.kt)("i",null,"/api/users")," route, the user objects would also contain the contents of the user's notes, and not just their id. In a relational database, this functionality would be implemented with a ",(0,a.kt)("i",null,"join query"),"."),(0,a.kt)("p",null,"As previously mentioned, document databases do not properly support join queries between collections, but the Mongoose library can do some of these joins for us. Mongoose accomplishes the join by doing multiple queries, which is different from join queries in relational databases which are ",(0,a.kt)("i",null,"transactional"),", meaning that the state of the database does not change during the time that the query is made. With join queries in Mongoose, nothing can guarantee that the state between the collections being joined is consistent, meaning that if we make a query that joins the user and notes collections, the state of the collections may change during the query."),(0,a.kt)("p",null,"The Mongoose join is done with the ",(0,a.kt)("a",{parentName:"p",href:"http://mongoosejs.com/docs/populate.html"},"populate")," method. Let's update the route that returns all users first:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"usersRouter.get('/', async (request, response) => {\n  const users = await User  // highlight-line\n    .find({}).populate('notes') // highlight-line\n\n  response.json(users)\n})\n")),(0,a.kt)("p",null,"The ",(0,a.kt)("a",{parentName:"p",href:"http://mongoosejs.com/docs/populate.html"},"populate")," method is chained after the ",(0,a.kt)("i",null,"find")," method making the initial query. The parameter given to the populate method defines that the ",(0,a.kt)("i",null,"ids")," referencing ",(0,a.kt)("i",null,"note")," objects in the ",(0,a.kt)("i",null,"notes")," field of the ",(0,a.kt)("i",null,"user")," document will be replaced by the referenced ",(0,a.kt)("i",null,"note")," documents."),(0,a.kt)("p",null,"The result is almost exactly what we wanted:"),(0,a.kt)("p",null,(0,a.kt)("img",{loading:"lazy",src:n(9880).Z,width:"1702",height:"1070"})),(0,a.kt)("p",null,"We can use the populate parameter for choosing the fields we want to include from the documents. The selection of fields is done with the Mongo ",(0,a.kt)("a",{parentName:"p",href:"https://docs.mongodb.com/manual/tutorial/project-fields-from-query-results/#return-the-specified-fields-and-the-id-field-only"},"syntax"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"usersRouter.get('/', async (request, response) => {\n  const users = await User\n    .find({}).populate('notes', { content: 1, date: 1 })\n\n  response.json(users)\n});\n")),(0,a.kt)("p",null,"The result is now exactly like we want it to be:"),(0,a.kt)("p",null,(0,a.kt)("img",{loading:"lazy",src:n(1364).Z,width:"1668",height:"942"})),(0,a.kt)("p",null,"Let's also add a suitable population of user information to notes:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"notesRouter.get('/', async (request, response) => {\n  const notes = await Note\n    .find({}).populate('user', { username: 1, name: 1 })\n\n  response.json(notes)\n});\n")),(0,a.kt)("p",null,"Now the user's information is added to the ",(0,a.kt)("i",null,"user")," field of note objects."),(0,a.kt)("p",null,(0,a.kt)("img",{loading:"lazy",src:n(3476).Z,width:"1608",height:"848"})),(0,a.kt)("p",null,"It's important to understand that the database does not actually know that the ids stored in the ",(0,a.kt)("i",null,"user")," field of notes reference documents in the user collection."),(0,a.kt)("p",null,"The functionality of the ",(0,a.kt)("i",null,"populate"),' method of Mongoose is based on the fact that we have defined "types" to the references in the Mongoose schema with the ',(0,a.kt)("i",null,"ref")," option:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"const noteSchema = new mongoose.Schema({\n  content: {\n    type: String,\n    required: true,\n    minlength: 5\n  },\n  date: Date,\n  important: Boolean,\n  user: {\n    type: mongoose.Schema.Types.ObjectId,\n    ref: 'User'\n  }\n})\n")),(0,a.kt)("p",null,"You can find the code for our current application in its entirety in the ",(0,a.kt)("i",null,"part4-8")," branch of ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/fullstack-hy/part3-notes-backend/tree/part4-8"},"this github repository"),"."),(0,a.kt)("h2",{id:"token-authentication"},"Token authentication"),(0,a.kt)("p",null,"Users must be able to log into our application, and when a user is logged in, their user information must automatically be attached to any new notes they create. "),(0,a.kt)("p",null,"We will now implement support for ",(0,a.kt)("a",{parentName:"p",href:"https://scotch.io/tutorials/the-ins-and-outs-of-token-based-authentication#toc-how-token-based-works"},"token based authentication")," to the backend. "),(0,a.kt)("p",null,"The principles of token based authentication are depicted in the following sequence diagram: "),(0,a.kt)("p",null,(0,a.kt)("img",{loading:"lazy",src:n(1716).Z,width:"1502",height:"944"})),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"User starts by logging in using a login form implemented with React   "),(0,a.kt)("li",{parentName:"ul"},"This causes the React code to send the username and the password to the server address ",(0,a.kt)("i",null,"/api/login")," as a HTTP POST request. "),(0,a.kt)("li",{parentName:"ul"},"If the username and the password are correct, the server generates a ",(0,a.kt)("i",null,"token")," which somehow identifies the logged in user. ",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"The token is signed digitally, making it impossible to falsify (with cryptographic means)"))),(0,a.kt)("li",{parentName:"ul"},"The backend responds with a status code indicating the operation was successful, and returns the token with the response."),(0,a.kt)("li",{parentName:"ul"},"The browser saves the token, for example to the state of a React application. "),(0,a.kt)("li",{parentName:"ul"},"When the user creates a new note (or does some other operation requiring identification), the React code sends the token to the server with the request."),(0,a.kt)("li",{parentName:"ul"},"The server uses the token to identify the user")),(0,a.kt)("p",null,"Let's first implement the functionality for logging in. Install the ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/auth0/node-jsonwebtoken"},"jsonwebtoken")," library, which allows us to generate ",(0,a.kt)("a",{parentName:"p",href:"https://jwt.io/"},"JSON web tokens"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"npm install jsonwebtoken\n")),(0,a.kt)("p",null,"The code for login functionality goes to the file controllers/login.js."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"const jwt = require('jsonwebtoken')\nconst bcrypt = require('bcrypt')\nconst loginRouter = require('express').Router()\nconst User = require('../models/user')\n\nloginRouter.post('/', async (request, response) => {\n  const { username, password } = request.body\n\n  const user = await User.findOne({ username })\n  const passwordCorrect = user === null\n    ? false\n    : await bcrypt.compare(password, user.passwordHash)\n\n  if (!(user && passwordCorrect)) {\n    return response.status(401).json({\n      error: 'invalid username or password'\n    })\n  }\n\n  const userForToken = {\n    username: user.username,\n    id: user._id,\n  }\n\n  const token = jwt.sign(userForToken, process.env.SECRET)\n\n  response\n    .status(200)\n    .send({ token, username: user.username, name: user.name })\n})\n\nmodule.exports = loginRouter\n")),(0,a.kt)("p",null,"The code starts by searching for the user from the database by the ",(0,a.kt)("i",null,"username")," attached to the request.\nNext, it checks the ",(0,a.kt)("i",null,"password"),", also attached to the request.\nBecause the passwords themselves are not saved to the database, but ",(0,a.kt)("i",null,"hashes")," calculated from the passwords, the ",(0,a.kt)("em",{parentName:"p"},"bcrypt.compare")," method is used to check if the password is correct: "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"await bcrypt.compare(body.password, user.passwordHash)\n")),(0,a.kt)("p",null,"If the user is not found, or the password is incorrect, the request is responded to with the status code ",(0,a.kt)("a",{parentName:"p",href:"https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.4.2"},"401 unauthorized"),". The reason for the failure is explained in the response body. "),(0,a.kt)("p",null,"If the password is correct, a token is created with the method  ",(0,a.kt)("em",{parentName:"p"},"jwt.sign"),". The token contains the username and the user id in a digitally signed form. "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"const userForToken = {\n  username: user.username,\n  id: user._id,\n}\n\nconst token = jwt.sign(userForToken, process.env.SECRET)\n")),(0,a.kt)("p",null,"The token has been digitally signed using a string from the environment variable ",(0,a.kt)("i",null,"SECRET")," as the ",(0,a.kt)("i",null,"secret"),".\nThe digital signature ensures that only parties who know the secret can generate a valid token.\nThe value for the environment variable must be set in the ",(0,a.kt)("i",null,".env")," file. "),(0,a.kt)("p",null,"A successful request is responded to with the status code ",(0,a.kt)("i",null,"200 OK"),". The generated token and the username of the user are sent back in the response body. "),(0,a.kt)("p",null,"Now the code for login just has to be added to the application by adding the new router to ",(0,a.kt)("i",null,"app.js"),". "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"const loginRouter = require('./controllers/login')\n\n//...\n\napp.use('/api/login', loginRouter)\n")),(0,a.kt)("p",null,"Let's try logging in using VS Code REST-client: "),(0,a.kt)("p",null,(0,a.kt)("img",{loading:"lazy",src:n(2908).Z,width:"1498",height:"384"})),(0,a.kt)("p",null,"It does not work. The following is printed to console: "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"(node:32911) UnhandledPromiseRejectionWarning: Error: secretOrPrivateKey must have a value\n    at Object.module.exports [as sign] (/Users/mluukkai/opetus/_2019fullstack-koodit/osa3/notes-backend/node_modules/jsonwebtoken/sign.js:101:20)\n    at loginRouter.post (/Users/mluukkai/opetus/_2019fullstack-koodit/osa3/notes-backend/controllers/login.js:26:21)\n(node:32911) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). (rejection id: 2)\n")),(0,a.kt)("p",null,"The command ",(0,a.kt)("em",{parentName:"p"},"jwt.sign(userForToken, process.env.SECRET)")," fails. We forgot to set a value to the environment variable ",(0,a.kt)("i",null,"SECRET"),". It can be any string. When we set the value in file ",(0,a.kt)("i",null,".env"),", the login works. "),(0,a.kt)("p",null,"A successful login returns the user details and the token: "),(0,a.kt)("p",null,(0,a.kt)("img",{loading:"lazy",src:n(7187).Z,width:"2036",height:"776"})),(0,a.kt)("p",null,"A wrong username or password returns an error message and the proper status code:"),(0,a.kt)("p",null,(0,a.kt)("img",{loading:"lazy",src:n(5382).Z,width:"2018",height:"526"})),(0,a.kt)("h3",{id:"limiting-creating-new-notes-to-logged-in-users"},"Limiting creating new notes to logged in users"),(0,a.kt)("p",null,"Let's change creating new notes so that it is only possible if the post request has a valid token attached.\nThe note is then saved to the notes list of the user identified by the token. "),(0,a.kt)("p",null,"There are several ways of sending the token from the browser to the server. We will use the ",(0,a.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Authorization"},"Authorization")," header. The header also tells which ",(0,a.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication#Authentication_schemes"},"authentication scheme")," is used. This can be necessary if the server offers multiple ways to authenticate.\nIdentifying the scheme tells the server how the attached credentials should be interpreted. "),(0,a.kt)("p",null,"The ",(0,a.kt)("i",null,"Bearer")," scheme is suitable to our needs. "),(0,a.kt)("p",null,"In practice, this means that if the token is for example, the string ",(0,a.kt)("i",null,"eyJhbGciOiJIUzI1NiIsInR5c2VybmFtZSI6Im1sdXVra2FpIiwiaW"),", the Authorization header will have the value: "),(0,a.kt)("pre",null,"Bearer eyJhbGciOiJIUzI1NiIsInR5c2VybmFtZSI6Im1sdXVra2FpIiwiaW"),(0,a.kt)("p",null,"Creating new notes will change like so: "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"const jwt = require('jsonwebtoken') //highlight-line\n\n// ...\n  //highlight-start\nconst getTokenFrom = request => {\n  const authorization = request.get('authorization')\n  if (authorization && authorization.toLowerCase().startsWith('bearer ')) {\n    return authorization.substring(7)\n  }\n  return null\n}\n  //highlight-end\n\nnotesRouter.post('/', async (request, response) => {\n  const body = request.body\n//highlight-start\n  const token = getTokenFrom(request)\n\n  const decodedToken = jwt.verify(token, process.env.SECRET)\n  if (!decodedToken.id) {\n    return response.status(401).json({ error: 'token missing or invalid' })\n  }\n\n  const user = await User.findById(decodedToken.id)\n//highlight-end\n\n  const note = new Note({\n    content: body.content,\n    important: body.important === undefined ? false : body.important,\n    date: new Date(),\n    user: user._id\n  })\n\n  const savedNote = await note.save()\n  user.notes = user.notes.concat(savedNote._id)\n  await user.save()\n\n  response.json(savedNote)\n})\n")),(0,a.kt)("p",null,"The helper function ",(0,a.kt)("em",{parentName:"p"},"getTokenFrom")," isolates the token from the ",(0,a.kt)("i",null,"authorization")," header. The validity of the token is checked with ",(0,a.kt)("em",{parentName:"p"},"jwt.verify"),". The method also decodes the token, or returns the Object which the token was based on. If there is no token passed, it will return error ",(0,a.kt)("i",null,'"jwt must be provided"'),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"const decodedToken = jwt.verify(token, process.env.SECRET)\n")),(0,a.kt)("p",null,"The object decoded from the token contains the ",(0,a.kt)("i",null,"username")," and ",(0,a.kt)("i",null,"id")," fields, which tells the server who made the request. "),(0,a.kt)("p",null,"If the object decoded from the token does not contain the user's identity (",(0,a.kt)("em",{parentName:"p"},"decodedToken.id")," is undefined), error status code ",(0,a.kt)("a",{parentName:"p",href:"https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.4.2"},"401 unauthorized")," is returned and the reason for the failure is explained in the response body. "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"if (!decodedToken.id) {\n  return response.status(401).json({\n    error: 'token missing or invalid'\n  })\n}\n")),(0,a.kt)("p",null,"When the identity of the maker of the request is resolved, the execution continues as before. "),(0,a.kt)("p",null,"A new note can now be created using Postman if the ",(0,a.kt)("i",null,"authorization")," header is given the correct value, the string ",(0,a.kt)("i",null,"bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ"),", where the second value is the token returned by the ",(0,a.kt)("i",null,"login")," operation. "),(0,a.kt)("p",null,"Using Postman this looks as follows: "),(0,a.kt)("p",null,(0,a.kt)("img",{loading:"lazy",src:n(4021).Z,width:"1580",height:"382"})),(0,a.kt)("p",null,"and with Visual Studio Code REST client"),(0,a.kt)("p",null,(0,a.kt)("img",{loading:"lazy",src:n(6713).Z,width:"1700",height:"708"})),(0,a.kt)("h3",{id:"error-handling"},"Error handling"),(0,a.kt)("p",null,"Token verification can also cause a ",(0,a.kt)("i",null,"JsonWebTokenError"),". If we for example remove a few characters from the token and try creating a new note, this happens: "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"JsonWebTokenError: invalid signature\n    at /Users/mluukkai/opetus/_2019fullstack-koodit/osa3/notes-backend/node_modules/jsonwebtoken/verify.js:126:19\n    at getSecret (/Users/mluukkai/opetus/_2019fullstack-koodit/osa3/notes-backend/node_modules/jsonwebtoken/verify.js:80:14)\n    at Object.module.exports [as verify] (/Users/mluukkai/opetus/_2019fullstack-koodit/osa3/notes-backend/node_modules/jsonwebtoken/verify.js:84:10)\n    at notesRouter.post (/Users/mluukkai/opetus/_2019fullstack-koodit/osa3/notes-backend/controllers/notes.js:40:30)\n")),(0,a.kt)("p",null,"There are many possible reasons for a decoding error. The token can be faulty (like in our example), falsified, or expired. Let's extend our errorHandler middleware to take into account the different decoding errors. "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"const unknownEndpoint = (request, response) => {\n  response.status(404).send({ error: 'unknown endpoint' })\n}\n\nconst errorHandler = (error, request, response, next) => {\n  if (error.name === 'CastError') {\n    return response.status(400).send({\n      error: 'malformatted id'\n    })\n  } else if (error.name === 'ValidationError') {\n    return response.status(400).json({\n      error: error.message \n    })\n  } else if (error.name === 'JsonWebTokenError') {  // highlight-line\n    return response.status(401).json({ // highlight-line\n      error: 'invalid token' // highlight-line\n    }) // highlight-line\n  }\n\n  logger.error(error.message)\n\n  next(error)\n}\n")),(0,a.kt)("p",null,"Current application code can be found on ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/fullstack-hy/part3-notes-backend/tree/part4-9"},"Github"),", branch ",(0,a.kt)("i",null,"part4-9"),"."),(0,a.kt)("p",null,"If the application has multiple interfaces requiring identification, JWT's validation should be separated into its own middleware. Some existing library like ",(0,a.kt)("a",{parentName:"p",href:"https://www.npmjs.com/package/express-jwt"},"express-jwt")," could also be used. "),(0,a.kt)("h3",{id:"problems-of-token-based-authentication"},"Problems of Token-based authentication"),(0,a.kt)("p",null,"Token authentication is pretty easy to implement, but it contains one problem. Once the API user, eg. a React app gets a token, the API has a blind trust to the token holder. What if the access rights of the token holder should be revoked?"),(0,a.kt)("p",null,"There are two solutions to the problem. Easier one is to limit the validity period of a token:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"loginRouter.post('/', async (request, response) => {\n  const { username, password } = request.body\n\n  const user = await User.findOne({ username })\n  const passwordCorrect = user === null\n    ? false\n    : await bcrypt.compare(password, user.passwordHash)\n\n  if (!(user && passwordCorrect)) {\n    return response.status(401).json({\n      error: 'invalid username or password'\n    })\n  }\n\n  const userForToken = {\n    username: user.username,\n    id: user._id,\n  }\n\n  // token expires in 60*60 seconds, that is, in one hour\n  // highlight-start\n  const token = jwt.sign(\n    userForToken, \n    process.env.SECRET,\n    { expiresIn: 60*60 }\n  )\n  // highlight-end\n\n  response\n    .status(200)\n    .send({ token, username: user.username, name: user.name })\n})\n")),(0,a.kt)("p",null,"Once the token expires, the client app needs to get a new token. Usually this happens by forcing the user to relogin to the app."),(0,a.kt)("p",null,"The error handling middleware should be extended to give a proper error in the case of a expired token:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"const errorHandler = (error, request, response, next) => {\n  logger.error(error.message)\n\n  if (error.name === 'CastError') {\n    return response.status(400).send({ error: 'malformatted id' })\n  } else if (error.name === 'ValidationError') {\n    return response.status(400).json({ error: error.message })\n  } else if (error.name === 'JsonWebTokenError') {\n    return response.status(401).json({\n      error: 'invalid token'\n    })\n  // highlight-start  \n  } else if (error.name === 'TokenExpiredError') {\n    return response.status(401).json({\n      error: 'token expired'\n    })\n  }\n  // highlight-end\n\n  next(error)\n}\n")),(0,a.kt)("p",null,"The shorter the expiration time, the more safe the solution is. So if the token gets into wrong hands, or the user access to the system needs to be revoked, the token is usable only a limited amount of time. On the other hand, a short expiration time forces a potential pain to a user, one must login to the system more frequently."),(0,a.kt)("p",null,"The other solution is to save info about each token to backend database and to check for each API request if the access right corresponding to the token is still valid. With this scheme, the access rights can be revoked at any time. This kind of solution is often called a ",(0,a.kt)("i",null,"server side session"),"."),(0,a.kt)("p",null,"The negative aspect of server side sessions is the increased complexity in the backend and also the effect on performance since the token validity needs to be checked for each API request from database. A database access is considerably slower compared to checking the validity from the token itself. That is why it is a quite common to save the session corresponding to a token to a ",(0,a.kt)("i",null,"key-value-database")," such as ",(0,a.kt)("a",{parentName:"p",href:"https://redis.io/"},"Redis")," that is limited in functionality compared to eg. MongoDB or relational database but extremely fast in some usage scenarios."),(0,a.kt)("p",null,"When server side sessions are used, the token is quite often just a random string, that does not include any information about the user as it is quite often the case when jwt-tokens are used. For each API request the server fetches the relevant information about the identitity of the user from the database. It is also quite usual that instead of using Authorization-header, ",(0,a.kt)("i",null,"cookies")," are used as the mechanism for transferring the token between the client and the server."),(0,a.kt)("h3",{id:"end-notes"},"End notes"),(0,a.kt)("p",null,"There have been many changes to the code which have caused a typical problem for a fast-paced software project. "),(0,a.kt)("p",null,"Usernames, passwords and applications using token authentication must always be used over ",(0,a.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/HTTPS"},"HTTPS"),". We could use a Node ",(0,a.kt)("a",{parentName:"p",href:"https://nodejs.org/api/https.html"},"HTTPS")," server in our application instead of the ",(0,a.kt)("a",{parentName:"p",href:"https://nodejs.org/docs/latest-v8.x/api/http.html"},"HTTP")," server (it requires more configuration). On the other hand, the production version of our application is in Heroku, so our application stays secure: Heroku routes all traffic between a browser and the Heroku server over HTTPS. "),(0,a.kt)("h2",{id:"reference"},"Reference"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://fullstackopen.com"},"FullStackOpen: Part 4A-4D"))))}d.isMDXComponent=!0},9863:function(e,t,n){t.Z=n.p+"assets/images/10e-fadd4b04e1d21cd5f21b3a5e95bd93f2.png"},7795:function(e,t,n){t.Z=n.p+"assets/images/11e-1862ab6fe61cf162adc80376e7ba91d7.png"},7528:function(e,t,n){t.Z=n.p+"assets/images/12e-129f8e5a4be202c34391dfcc1a5ff001.png"},9880:function(e,t,n){t.Z=n.p+"assets/images/13ea-7c2a958ceac8ef785f09d977b441fb46.png"},1364:function(e,t,n){t.Z=n.p+"assets/images/14ea-80ff733aab2ef57ced90b234e6609893.png"},3476:function(e,t,n){t.Z=n.p+"assets/images/15ea-3fd4a6b67bce8d61dec758894a8d73f6.png"},1716:function(e,t,n){t.Z=n.p+"assets/images/16e-8fdf267aa4865fab9bab9e913f263a2a.png"},2908:function(e,t,n){t.Z=n.p+"assets/images/17e-ed23a6f6e40b35f20ed72b589cb73b6f.png"},7187:function(e,t,n){t.Z=n.p+"assets/images/18ea-5ab5270ca6ae2affe6a2edce3f74009f.png"},5382:function(e,t,n){t.Z=n.p+"assets/images/19ea-e48e8ed5b165ecb49f7f30caf5261f57.png"},4021:function(e,t,n){t.Z=n.p+"assets/images/20e-f75fd9e9ec9cdbfe8a97ff476f76ab4a.png"},6713:function(e,t,n){t.Z=n.p+"assets/images/21e-04ba6e8cbfca27daa87c1722bd066b97.png"},8861:function(e,t,n){t.Z=n.p+"assets/images/6-8ecbf0c45fc07dd4d8f75e225e85ab2c.png"},1857:function(e,t,n){t.Z=n.p+"assets/images/9-a155426e04d3e89fcae4a8adc495587a.png"}}]);