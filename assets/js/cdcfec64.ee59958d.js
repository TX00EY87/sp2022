"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[5980],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return c}});var o=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=o.createContext({}),d=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},u=function(e){var t=d(e.components);return o.createElement(l.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},p=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,l=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),p=d(n),c=a,m=p["".concat(l,".").concat(c)]||p[c]||h[c]||r;return n?o.createElement(m,s(s({ref:t},u),{},{components:n})):o.createElement(m,s({ref:t},u))}));function c(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,s=new Array(r);s[0]=p;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:a,s[1]=i;for(var d=2;d<r;d++)s[d]=n[d];return o.createElement.apply(null,s)}return o.createElement.apply(null,n)}p.displayName="MDXCreateElement"},5477:function(e,t,n){n.r(t),n.d(t,{assets:function(){return u},contentTitle:function(){return l},default:function(){return c},frontMatter:function(){return i},metadata:function(){return d},toc:function(){return h}});var o=n(7462),a=n(3366),r=(n(7294),n(3905)),s=["components"],i={title:"Post Lecture Reading",sidebar_label:"Post Lecture",pagination_next:null,pagination_prev:null,hide_table_of_contents:!1,sidebar_position:5},l="After Lecture",d={unversionedId:"lecture-13/post-lecture",id:"lecture-13/post-lecture",title:"Post Lecture Reading",description:"Recommended videos",source:"@site/docs/lecture-13/post-lecture.md",sourceDirName:"lecture-13",slug:"/lecture-13/post-lecture",permalink:"/sp2022/lecture-13/post-lecture",tags:[],version:"current",sidebarPosition:5,frontMatter:{title:"Post Lecture Reading",sidebar_label:"Post Lecture",pagination_next:null,pagination_prev:null,hide_table_of_contents:!1,sidebar_position:5},sidebar:"docs"},u={},h=[{value:"Recommended videos",id:"recommended-videos",level:2},{value:"Mongoose",id:"mongoose",level:2},{value:"Database configuration into its own module",id:"database-configuration-into-its-own-module",level:3},{value:"Using database in route handlers",id:"using-database-in-route-handlers",level:3},{value:"Verifying frontend and backend integration",id:"verifying-frontend-and-backend-integration",level:3},{value:"Error handling",id:"error-handling",level:3},{value:"Moving error handling into middleware",id:"moving-error-handling-into-middleware",level:3},{value:"The order of middleware loading",id:"the-order-of-middleware-loading",level:3},{value:"Other operations",id:"other-operations",level:3},{value:"Data Validation",id:"data-validation",level:3},{value:"Reference",id:"reference",level:2}],p={toc:h};function c(e){var t=e.components,i=(0,a.Z)(e,s);return(0,r.kt)("wrapper",(0,o.Z)({},p,i,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"after-lecture"},"After Lecture"),(0,r.kt)("h2",{id:"recommended-videos"},"Recommended videos"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://youtu.be/-PdjUx9JZ2E"},"Intro to MongoDB and Mongoose"))),(0,r.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,r.kt)("div",{parentName:"div",className:"admonition-heading"},(0,r.kt)("h5",{parentName:"div"},(0,r.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,r.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,r.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,r.kt)("div",{parentName:"div",className:"admonition-content"},(0,r.kt)("p",{parentName:"div"}," ",(0,r.kt)("strong",{parentName:"p"},"Credits"),": The post lecture material has been written by ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/mluukkai"},"Matti Luukkainen")," from ",(0,r.kt)("a",{parentName:"p",href:"https://fullstackopen.com/en/"},"University of Helsinki"),". The material is licensed under the Creative Commons BY-NC-SA 3.0 License."))),(0,r.kt)("h2",{id:"mongoose"},"Mongoose"),(0,r.kt)("h3",{id:"database-configuration-into-its-own-module"},"Database configuration into its own module"),(0,r.kt)("p",null,"Before we refactor the rest of the backend to use the database, let's extract the Mongoose specific code into its own module."),(0,r.kt)("p",null,"Let's create a new directory for the module called ",(0,r.kt)("i",null,"models"),", and add a file called ",(0,r.kt)("i",null,"note.js"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const mongoose = require('mongoose')\n\nconst url = process.env.MONGODB_URI\n\nconsole.log('connecting to', url) \n\nmongoose.connect(url)\n\n  .then(result => {\n    console.log('connected to MongoDB')\n  })\n  .catch((error) => {\n    console.log('error connecting to MongoDB:', error.message)\n  })\n\n\nconst noteSchema = new mongoose.Schema({\n  content: String,\n  date: Date,\n  important: Boolean,\n})\n\nnoteSchema.set('toJSON', {\n  transform: (document, returnedObject) => {\n    returnedObject.id = returnedObject._id.toString()\n    delete returnedObject._id\n    delete returnedObject.__v\n  }\n})\n\nmodule.exports = mongoose.model('Note', noteSchema) \n")),(0,r.kt)("p",null,"Defining Node ",(0,r.kt)("a",{parentName:"p",href:"https://nodejs.org/docs/latest-v8.x/api/modules.html"},"modules")," differs slightly from the way of defining ES6 modules."),(0,r.kt)("p",null,"The public interface of the module is defined by setting a value to the ",(0,r.kt)("em",{parentName:"p"},"module.exports")," variable. We will set the value to be the ",(0,r.kt)("i",null,"Note")," model. The other things defined inside of the module, like the variables ",(0,r.kt)("em",{parentName:"p"},"mongoose")," and ",(0,r.kt)("em",{parentName:"p"},"url")," will not be accessible or visible to users of the module."),(0,r.kt)("p",null,"Importing the module happens by adding the following line to ",(0,r.kt)("i",null,"index.js"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const Note = require('./models/note')\n")),(0,r.kt)("p",null,"This way the ",(0,r.kt)("em",{parentName:"p"},"Note")," variable will be assigned to the same object that the module defines."),(0,r.kt)("p",null,"The way that the connection is made has changed slightly:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const url = process.env.MONGODB_URI\n\nconsole.log('connecting to', url)\n\nmongoose.connect(url)\n  .then(result => {\n    console.log('connected to MongoDB')\n  })\n  .catch((error) => {\n    console.log('error connecting to MongoDB:', error.message)\n  })\n")),(0,r.kt)("p",null,"It's not a good idea to hardcode the address of the database into the code, so instead the address of the database is passed to the application via the ",(0,r.kt)("em",null,"MONGODB_URI")," environment variable."),(0,r.kt)("p",null,"The method for establishing the connection is now given functions for dealing with a successful and unsuccessful connection attempt. Both functions just log a message to the console about the success status:"),(0,r.kt)("p",null,(0,r.kt)("img",{loading:"lazy",src:n(9857).Z,width:"1582",height:"258"})),(0,r.kt)("p",null,"There are many ways to define the value of an environment variable. One way would be to define it when the application is started:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"MONGODB_URI=address_here npm run dev\n")),(0,r.kt)("p",null,"A more sophisticated way is to use the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/motdotla/dotenv#readme"},"dotenv")," library. You can install the library with the command:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"npm install dotenv\n")),(0,r.kt)("p",null,"To use the library, we create a ",(0,r.kt)("i",null,".env")," file at the root of the project. The environment variables are defined inside of the file, and it can look like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"MONGODB_URI=mongodb+srv://fullstack:<pasdsword>@cluster0.o1opl.mongodb.net/noteApp?retryWrites=true&w=majority\nPORT=3001\n")),(0,r.kt)("p",null,"We also added the hardcoded port of the server into the ",(0,r.kt)("em",null,"PORT")," environment variable."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"The ",(0,r.kt)("i",null,".env")," file should be gitignored right away, since we do not want to publish any confidential information publicly online!")),(0,r.kt)("p",null,(0,r.kt)("img",{loading:"lazy",src:n(5555).Z,width:"1490",height:"294"})),(0,r.kt)("p",null,"The environment variables defined in the ",(0,r.kt)("i",null,".env")," file can be taken into use with the expression ",(0,r.kt)("em",null,"require('dotenv').config()")," and you can reference them in your code just like you would reference normal environment variables, with the familiar ",(0,r.kt)("em",null,"process.env.MONGODB_URI")," syntax."),(0,r.kt)("p",null,"Let's change the ",(0,r.kt)("i",null,"index.js")," file in the following way:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"require('dotenv').config() \nconst express = require('express')\nconst app = express()\nconst Note = require('./models/note') \n\n// ..\n\nconst PORT = process.env.PORT \napp.listen(PORT, () => {\n  console.log(`Server running on port ${PORT}`)\n})\n")),(0,r.kt)("p",null,"It's important that ",(0,r.kt)("i",null,"dotenv")," gets imported before the ",(0,r.kt)("i",null,"note")," model is imported. This ensures that the environment variables from the ",(0,r.kt)("i",null,".env")," file are available globally before the code from the other modules is imported."),(0,r.kt)("p",null,"Once the file .env has been gitignored, Heroku does not get the database url from the repository, so you have to set it yourself. That can be done throught the heroku dasboard as follows:"),(0,r.kt)("p",null,(0,r.kt)("img",{loading:"lazy",src:n(9365).Z,width:"935",height:"294"})),(0,r.kt)("p",null,"or from command line with the command:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"heroku config:set MONGODB_URI='mongodb+srv://fullstack:<password>@cluster0.o1opl.mongodb.net/noteApp?retryWrites=true&w=majority'\n")),(0,r.kt)("h3",{id:"using-database-in-route-handlers"},"Using database in route handlers"),(0,r.kt)("p",null,"Next, let's change the rest of the backend functionality to use the database."),(0,r.kt)("p",null,"Creating a new note is accomplished like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"app.post('/api/notes', (request, response) => {\n  const body = request.body\n\n  if (body.content === undefined) {\n    return response.status(400).json({ error: 'content missing' })\n  }\n\n  const note = new Note({\n    content: body.content,\n    important: body.important || false,\n    date: new Date(),\n  })\n\n  note.save().then(savedNote => {\n    response.json(savedNote)\n  })\n})\n")),(0,r.kt)("p",null,"The note objects are created with the ",(0,r.kt)("em",{parentName:"p"},"Note")," constructor function. The response is sent inside of the callback function for the ",(0,r.kt)("em",{parentName:"p"},"save")," operation. This ensures that the response is sent only if the operation succeeded. We will discuss error handling a little bit later."),(0,r.kt)("p",null,"The ",(0,r.kt)("em",{parentName:"p"},"savedNote")," parameter in the callback function is the saved and newly created note. The data sent back in the response is the formatted version created with the ",(0,r.kt)("em",{parentName:"p"},"toJSON")," method:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"response.json(savedNote)\n")),(0,r.kt)("p",null,"Using Mongoose's ",(0,r.kt)("a",{parentName:"p",href:"https://mongoosejs.com/docs/api.html#model_Model.findById"},"findById")," method, fetching an individual note gets changed into the following:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"app.get('/api/notes/:id', (request, response) => {\n  Note.findById(request.params.id).then(note => {\n    response.json(note)\n  })\n})\n")),(0,r.kt)("h3",{id:"verifying-frontend-and-backend-integration"},"Verifying frontend and backend integration"),(0,r.kt)("p",null,"When the backend gets expanded, it's a good idea to test the backend first with ",(0,r.kt)("strong",{parentName:"p"},"the browser, Postman or the VS Code REST client"),". Next, let's try creating a new note after taking the database into use:"),(0,r.kt)("p",null,(0,r.kt)("img",{loading:"lazy",src:n(856).Z,width:"1902",height:"940"})),(0,r.kt)("p",null,"Only once everything has been verified to work in the backend, is it a good idea to test that the frontend works with the backend. It is highly inefficient to test things exclusively through the frontend."),(0,r.kt)("p",null,"It's probably a good idea to integrate the frontend and backend one functionality at a time. First, we could implement fetching all of the notes from the database and test it through the backend endpoint in the browser. After this, we could verify that the frontend works with the new backend. Once everything seems to work, we would move onto the next feature."),(0,r.kt)("p",null,"Once we introduce a database into the mix, it is useful to inspect the state persisted in the database, e.g. from the control panel in MongoDB Atlas. Quite often little Node helper programs like the ",(0,r.kt)("i",null,"mongo.js")," program we wrote earlier can be very helpful during development."),(0,r.kt)("p",null,"You can find the code for our current application in its entirety in the ",(0,r.kt)("i",null,"part3-4")," branch of ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/fullstack-hy2020/part3-notes-backend/tree/part3-4"},"this Github repository"),"."),(0,r.kt)("h3",{id:"error-handling"},"Error handling"),(0,r.kt)("p",null,"If we try to visit the URL of a note with an id that does not actually exist e.g. ",(0,r.kt)("a",{parentName:"p",href:"http://localhost:3001/api/notes/5c41c90e84d891c15dfa3431"},"http://localhost:3001/api/notes/5c41c90e84d891c15dfa3431")," where ",(0,r.kt)("i",null,"5c41c90e84d891c15dfa3431")," is not an id stored in the database, then the response will be ",(0,r.kt)("em",{parentName:"p"},"null"),"."),(0,r.kt)("p",null,"Let's change this behavior so that if note with the given id doesn't exist, the server will respond to the request with the HTTP status code 404 not found. In addition let's implement a simple ",(0,r.kt)("em",null,"catch")," block to handle cases where the promise returned by the ",(0,r.kt)("em",null,"findById")," method is ",(0,r.kt)("i",null,"rejected"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"app.get('/api/notes/:id', (request, response) => {\n  Note.findById(request.params.id)\n    .then(note => {\n     \n      if (note) {\n        response.json(note)\n      } else {\n        response.status(404).end()\n      }\n      \n    })\n  \n    .catch(error => {\n      console.log(error)\n      response.status(500).end()\n    })\n   \n})\n")),(0,r.kt)("p",null,"If no matching object is found in the database, the value of ",(0,r.kt)("em",{parentName:"p"},"note")," will be ",(0,r.kt)("em",{parentName:"p"},"null")," and the ",(0,r.kt)("em",{parentName:"p"},"else")," block is executed. This results in a response with the status code ",(0,r.kt)("i",null,"404 not found"),". If promise returned by the ",(0,r.kt)("em",null,"findById")," method is rejected, the response will have the status code ",(0,r.kt)("i",null,"500 internal server error"),". The console displays more detailed information about the error."),(0,r.kt)("p",null,"On top of the non-existing note, there's one more error situation needed to be handled. In this situation, we are trying to fetch a note with a wrong kind of ",(0,r.kt)("em",{parentName:"p"},"id"),", meaning an ",(0,r.kt)("em",{parentName:"p"},"id")," that doesn't match the mongo identifier format."),(0,r.kt)("p",null,"If we make the following request, we will get the error message shown below:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},'Method: GET\nPath:   /api/notes/someInvalidId\nBody:   {}\n\n CastError: Cast to ObjectId failed for value "someInvalidId" at path "_id"\n    at CastError (/Users/mluukkai/opetus/_fullstack/osa3-muisiinpanot/node_modules/mongoose/lib/error/cast.js:27:11)\n    at ObjectId.cast (/Users/mluukkai/opetus/_fullstack/osa3-muisiinpanot/node_modules/mongoose/lib/schema/objectid.js:158:13)\n')),(0,r.kt)("p",null,"Given malformed id as an argument, the ",(0,r.kt)("em",null,"findById")," method will throw an error causing the returned promise to be rejected. This will cause the callback function defined in the ",(0,r.kt)("em",null,"catch")," block to be called. "),(0,r.kt)("p",null,"Let's make some small adjustments to the response in the ",(0,r.kt)("em",null,"catch")," block:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"app.get('/api/notes/:id', (request, response) => {\n  Note.findById(request.params.id)\n    .then(note => {\n      if (note) {\n        response.json(note)\n      } else {\n        response.status(404).end() \n      }\n    })\n    .catch(error => {\n      console.log(error)\n      response.status(400).send({ error: 'malformatted id' }) \n    })\n})\n")),(0,r.kt)("p",null,"If the format of the id is incorrect, then we will end up in the error handler defined in the ",(0,r.kt)("em",{parentName:"p"},"catch")," block. The appropriate status code for the situation is ",(0,r.kt)("a",{parentName:"p",href:"https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.4.1"},"400 Bad Request"),", because the situation fits the description perfectly:"),(0,r.kt)("blockquote",null,(0,r.kt)("i",null,"The request could not be understood by the server due to malformed syntax. The client SHOULD NOT repeat the request without modifications.")),(0,r.kt)("p",null,"We have also added some data to the response to shed some light on the cause of the error."),(0,r.kt)("p",null,"When dealing with Promises, it's almost always a good idea to add error and exception handling, because otherwise you will find yourself dealing with strange bugs."),(0,r.kt)("p",null,"It's never a bad idea to print the object that caused the exception to the console in the error handler:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},".catch(error => {\n  console.log(error)  \n  response.status(400).send({ error: 'malformatted id' })\n})\n")),(0,r.kt)("p",null,"The reason the error handler gets called might be something completely different than what you had anticipated. If you log the error to the console, you may save yourself from long and frustrating debugging sessions. Moreover, most modern services to where you deploy your application support some form of logging system that you can use to check these logs. As mentioned, Heroku is one."),(0,r.kt)("p",null,"Every time you're working on a project with a backend, ",(0,r.kt)("i",null,"it is critical to keep an eye on the console output of the backend"),". If you are working on a small screen, it is enough to just see a tiny slice of the output in the background. Any error messages will catch your attention even when the console is far back in the background:"),(0,r.kt)("p",null,(0,r.kt)("img",{loading:"lazy",src:n(3309).Z,width:"2050",height:"884"})),(0,r.kt)("h3",{id:"moving-error-handling-into-middleware"},"Moving error handling into middleware"),(0,r.kt)("p",null,"We have written the code for the error handler among the rest of our code. This can be a reasonable solution at times, but there are cases where it is better to implement all error handling in a single place. This can be particularly useful if we later on want to report data related to errors to an external error tracking system like ",(0,r.kt)("a",{parentName:"p",href:"https://sentry.io/welcome/"},"Sentry"),"."),(0,r.kt)("p",null,"Let's change the handler for the ",(0,r.kt)("i",null,"/api/notes/:id")," route, so that it passes the error forward with the ",(0,r.kt)("em",null,"next")," function. The next function is passed to the handler as the third parameter:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"app.get('/api/notes/:id', (request, response, next) => { \n  Note.findById(request.params.id)\n    .then(note => {\n      if (note) {\n        response.json(note)\n      } else {\n        response.status(404).end()\n      }\n    })\n    .catch(error => next(error)) \n})\n")),(0,r.kt)("p",null,"The error that is passed forwards is given to the ",(0,r.kt)("em",null,"next")," function as a parameter. If ",(0,r.kt)("em",null,"next")," was called without a parameter, then the execution would simply move onto the next route or middleware. If the ",(0,r.kt)("em",null,"next")," function is called with a parameter, then the execution will continue to the ",(0,r.kt)("i",null,"error handler middleware"),"."),(0,r.kt)("p",null,"Express ",(0,r.kt)("a",{parentName:"p",href:"https://expressjs.com/en/guide/error-handling.html"},"error handlers")," are middleware that are defined with a function that accepts ",(0,r.kt)("i",null,"four parameters"),". Our error handler looks like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const errorHandler = (error, request, response, next) => {\n  console.error(error.message)\n\n  if (error.name === 'CastError') {\n    return response.status(400).send({ error: 'malformatted id' })\n  } \n\n  next(error)\n}\n\n// this has to be the last loaded middleware.\napp.use(errorHandler)\n")),(0,r.kt)("p",null,"The error handler checks if the error is a ",(0,r.kt)("i",null,"CastError")," exception, in which case we know that the error was caused by an invalid object id for Mongo. In this situation the error handler will send a response to the browser with the response object passed as a parameter. In all other error situations, the middleware passes the error forward to the default Express error handler. "),(0,r.kt)("p",null,"Note that the error handling middleware has to be the last loaded middleware!"),(0,r.kt)("h3",{id:"the-order-of-middleware-loading"},"The order of middleware loading"),(0,r.kt)("p",null,"The execution order of middleware is the same as the order that they are loaded into express with the ",(0,r.kt)("em",{parentName:"p"},"app.use")," function. For this reason it is important to be careful when defining middleware."),(0,r.kt)("p",null,"The correct order is the following:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"app.use(express.static('build'))\napp.use(express.json())\napp.use(requestLogger)\n\napp.post('/api/notes', (request, response) => {\n  const body = request.body\n  // ...\n})\n\nconst unknownEndpoint = (request, response) => {\n  response.status(404).send({ error: 'unknown endpoint' })\n}\n\n// handler of requests with unknown endpoint\napp.use(unknownEndpoint)\n\nconst errorHandler = (error, request, response, next) => {\n  // ...\n}\n\n// handler of requests with result to errors\napp.use(errorHandler)\n")),(0,r.kt)("p",null,"The json-parser middleware should be among the very first middleware loaded into Express. If the order was the following:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"app.use(requestLogger) // request.body is undefined!\n\napp.post('/api/notes', (request, response) => {\n  // request.body is undefined!\n  const body = request.body\n  // ...\n})\n\napp.use(express.json())\n")),(0,r.kt)("p",null,"Then the JSON data sent with the HTTP requests would not be available for the logger middleware or the POST route handler, since the ",(0,r.kt)("em",{parentName:"p"},"request.body")," would be ",(0,r.kt)("em",{parentName:"p"},"undefined")," at that point."),(0,r.kt)("p",null,"It's also important that the middleware for handling unsupported routes is next to the last middleware that is loaded into Express, just before the error handler."),(0,r.kt)("p",null,"For example, the following loading order would cause an issue:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const unknownEndpoint = (request, response) => {\n  response.status(404).send({ error: 'unknown endpoint' })\n}\n\n// handler of requests with unknown endpoint\napp.use(unknownEndpoint)\n\napp.get('/api/notes', (request, response) => {\n  // ...\n})\n")),(0,r.kt)("p",null,"Now the handling of unknown endpoints is ordered ",(0,r.kt)("i",null,"before the HTTP request handler"),". Since the unknown endpoint handler responds to all requests with ",(0,r.kt)("i",null,"404 unknown endpoint"),", no routes or middleware will be called after the response has been sent by unknown endpoint middleware. The only exception to this is the error handler which needs to come at the very end, after the unknown endpoints handler."),(0,r.kt)("h3",{id:"other-operations"},"Other operations"),(0,r.kt)("p",null,"Let's add some missing functionality to our application, including deleting and updating an individual note."),(0,r.kt)("p",null,"The easiest way to delete a note from the database is with the ",(0,r.kt)("a",{parentName:"p",href:"https://mongoosejs.com/docs/api.html#model_Model.findByIdAndRemove"},"findByIdAndRemove")," method:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"app.delete('/api/notes/:id', (request, response, next) => {\n  Note.findByIdAndRemove(request.params.id)\n    .then(result => {\n      response.status(204).end()\n    })\n    .catch(error => next(error))\n})\n")),(0,r.kt)("p",null,'In both of the "successful" cases of deleting a resource, the backend responds with the status code ',(0,r.kt)("i",null,"204 no content"),". The two different cases are deleting a note that exists, and deleting a note that does not exist in the database. The ",(0,r.kt)("em",{parentName:"p"},"result")," callback parameter could be used for checking if a resource actually was deleted, and we could use that information for returning different status codes for the two cases if we deemed it necessary. Any exception that occurs is passed onto the error handler."),(0,r.kt)("p",null,"The toggling of the importance of a note can be easily accomplished with the ",(0,r.kt)("a",{parentName:"p",href:"https://mongoosejs.com/docs/api.html#model_Model.findByIdAndUpdate"},"findByIdAndUpdate")," method."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"app.put('/api/notes/:id', (request, response, next) => {\n  const body = request.body\n\n  const note = {\n    content: body.content,\n    important: body.important,\n  }\n\n  Note.findByIdAndUpdate(request.params.id, note, { new: true })\n    .then(updatedNote => {\n      response.json(updatedNote)\n    })\n    .catch(error => next(error))\n})\n")),(0,r.kt)("p",null,"In the code above, we also allow the content of the note to be edited. However, we will not support changing the creation date for obvious reasons."),(0,r.kt)("p",null,"Notice that the ",(0,r.kt)("em",null,"findByIdAndUpdate")," method receives a regular JavaScript object as its parameter, and not a new note object created with the ",(0,r.kt)("em",null,"Note")," constructor function."),(0,r.kt)("p",null,"There is one important detail regarding the use of the ",(0,r.kt)("em",null,"findByIdAndUpdate")," method. By default, the ",(0,r.kt)("em",null,"updatedNote")," parameter of the event handler receives the original document ",(0,r.kt)("a",{parentName:"p",href:"https://mongoosejs.com/docs/api.html#model_Model.findByIdAndUpdate"},"without the modifications"),". We added the optional ",(0,r.kt)("code",null,"{ new: true }")," parameter, which will cause our event handler to be called with the new modified document instead of the original."),(0,r.kt)("p",null,"After testing the backend directly with Postman and the VS Code REST client, we can verify that it seems to work. The frontend also appears to work with the backend using the database. "),(0,r.kt)("p",null,"You can find the code for our current application in its entirety in the ",(0,r.kt)("i",null,"part3-5")," branch of ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/fullstack-hy2020/part3-notes-backend/tree/part3-5"},"this github repository"),"."),(0,r.kt)("h3",{id:"data-validation"},"Data Validation"),(0,r.kt)("p",null,"There are usually constraints that we want to apply to the data that is stored in our application's database. Our application shouldn't accept notes that have a missing or empty ",(0,r.kt)("i",null,"content")," property. The validity of the note is checked in the route handler:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"app.post('/api/notes', (request, response) => {\n  const body = request.body\n\n  if (body.content === undefined) {\n    return response.status(400).json({ error: 'content missing' })\n  }\n\n  // ...\n})\n")),(0,r.kt)("p",null,"If the note does not have the ",(0,r.kt)("i",null,"content")," property, we respond to the request with the status code ",(0,r.kt)("i",null,"400 bad request"),"."),(0,r.kt)("p",null,"One smarter way of validating the format of the data before it is stored in the database, is to use the ",(0,r.kt)("a",{parentName:"p",href:"https://mongoosejs.com/docs/validation.html"},"validation")," functionality available in Mongoose."),(0,r.kt)("p",null,"We can define specific validation rules for each field in the schema:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const noteSchema = new mongoose.Schema({\n  content: {\n    type: String,\n    minLength: 5,\n    required: true\n  },\n  date: { \n    type: Date,\n    required: true\n  },\n  important: Boolean\n})\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("i",null,"content")," field is now required to be at least five characters long. The ",(0,r.kt)("i",null,"date")," field is set as required, meaning that it can not be missing. The same constraint is also applied to the ",(0,r.kt)("i",null,"content")," field, since the minimum length constraint allows the field to be missing. We have not added any constraints to the ",(0,r.kt)("i",null,"important")," field, so its definition in the schema has not changed."),(0,r.kt)("p",null,"The ",(0,r.kt)("i",null,"minLength")," and ",(0,r.kt)("i",null,"required")," validators are ",(0,r.kt)("a",{parentName:"p",href:"https://mongoosejs.com/docs/validation.html#built-in-validators"},"built-in")," and provided by Mongoose. The Mongoose ",(0,r.kt)("a",{parentName:"p",href:"https://mongoosejs.com/docs/validation.html#custom-validators"},"custom validator")," functionality allows us to create new validators, if none of the built-in ones cover our needs."),(0,r.kt)("p",null,"If we try to store an object in the database that breaks one of the constraints, the operation will throw an exception. Let's change our handler for creating a new note so that it passes any potential exceptions to the error handler middleware:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"app.post('/api/notes', (request, response, next) => { \n  const body = request.body\n\n  const note = new Note({\n    content: body.content,\n    important: body.important || false,\n    date: new Date(),\n  })\n\n  note.save()\n    .then(savedNote => {\n      response.json(savedNote)\n    })\n    .catch(error => next(error)) \n})\n")),(0,r.kt)("p",null,"Let's expand the error handler to deal with these validation errors:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const errorHandler = (error, request, response, next) => {\n  console.error(error.message)\n\n  if (error.name === 'CastError') {\n    return response.status(400).send({ error: 'malformatted id' })\n  } else if (error.name === 'ValidationError') { \n    return response.status(400).json({ error: error.message }) \n  }\n\n  next(error)\n}\n")),(0,r.kt)("p",null,"When validating an object fails, we return the following default error message from Mongoose:"),(0,r.kt)("p",null,(0,r.kt)("img",{loading:"lazy",src:n(4714).Z,width:"1670",height:"818"})),(0,r.kt)("p",null,"We notice that the backend has now a problem: validations are not done when editing a note.\nThe ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/blakehaswell/mongoose-unique-validator#find--updates"},"documentation")," explains what is the problem, validations are not run by default when ",(0,r.kt)("i",null,"findOneAndUpdate")," is executed."),(0,r.kt)("p",null,"The fix is easy. Let us also reformulate the route code a bit:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"app.put('/api/notes/:id', (request, response, next) => {\n  const { content, important } = request.body \n\n  Note.findByIdAndUpdate(\n    request.params.id, \n    { content, important }, \n    { new: true, runValidators: true, context: 'query' } \n  ) \n    .then(updatedNote => {\n      response.json(updatedNote)\n    })\n    .catch(error => next(error))\n})\n")),(0,r.kt)("h2",{id:"reference"},"Reference"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://fullstackopen.com"},"FullStackOpen: Part 3C, 3D"))))}c.isMDXComponent=!0},3309:function(e,t,n){t.Z=n.p+"assets/images/15b-b8b73c6bc442201b0144fa72bcdada07.png"},5555:function(e,t,n){t.Z=n.p+"assets/images/45ae-805eada19a00c11de0864c6312dbd017.png"},9857:function(e,t,n){t.Z=n.p+"assets/images/45e-7ed0c5cfd839ce205009dffe0d59d6ce.png"},856:function(e,t,n){t.Z=n.p+"assets/images/46e-40426fb280b60a26665ef625b1309d37.png"},4714:function(e,t,n){t.Z=n.p+"assets/images/50-e6f2501bd8ea7feee297ecdfea4d9b31.png"},9365:function(e,t,n){t.Z=n.p+"assets/images/herokuConfig-9f4a2ded5b70a33767825f342224dfc6.png"}}]);