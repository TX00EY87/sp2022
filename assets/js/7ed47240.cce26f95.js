"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[6361],{3905:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return p}});var o=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},s=Object.keys(e);for(o=0;o<s.length;o++)n=s[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(o=0;o<s.length;o++)n=s[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=o.createContext({}),u=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=u(e.components);return o.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},h=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,s=e.originalType,l=e.parentName,d=r(e,["components","mdxType","originalType","parentName"]),h=u(n),p=a,f=h["".concat(l,".").concat(p)]||h[p]||c[p]||s;return n?o.createElement(f,i(i({ref:t},d),{},{components:n})):o.createElement(f,i({ref:t},d))}));function p(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var s=n.length,i=new Array(s);i[0]=h;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r.mdxType="string"==typeof e?e:a,i[1]=r;for(var u=2;u<s;u++)i[u]=n[u];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}h.displayName="MDXCreateElement"},9695:function(e,t,n){n.r(t),n.d(t,{assets:function(){return d},contentTitle:function(){return l},default:function(){return p},frontMatter:function(){return r},metadata:function(){return u},toc:function(){return c}});var o=n(7462),a=n(3366),s=(n(7294),n(3905)),i=["components"],r={title:"Lecture",sidebar_label:"Lecture",pagination_next:null,pagination_prev:null,hide_table_of_contents:!1},l="Lecture",u={unversionedId:"lecture-16/lecture",id:"lecture-16/lecture",title:"Lecture",description:"Lecture Slides will be in OMA after the session.",source:"@site/docs/lecture-16/lecture.md",sourceDirName:"lecture-16",slug:"/lecture-16/lecture",permalink:"/sp2022/lecture-16/lecture",tags:[],version:"current",frontMatter:{title:"Lecture",sidebar_label:"Lecture",pagination_next:null,pagination_prev:null,hide_table_of_contents:!1},sidebar:"docs"},d={},c=[{value:"Group Presentations",id:"group-presentations",level:2},{value:"Testing",id:"testing",level:2},{value:"Introduction",id:"introduction",level:3},{value:"How does testing work?",id:"how-does-testing-work",level:3},{value:"What to test and when?",id:"what-to-test-and-when",level:4},{value:"Unit tests",id:"unit-tests",level:3},{value:"Integration tests",id:"integration-tests",level:3},{value:"End-to-end tests",id:"end-to-end-tests",level:3},{value:"Testing HTTP APIs",id:"testing-http-apis",level:4},{value:"Testing GUIs",id:"testing-guis",level:4},{value:"Testing techniques",id:"testing-techniques",level:2},{value:"Test suites",id:"test-suites",level:3},{value:"Mocks, stubs, and spies",id:"mocks-stubs-and-spies",level:3},{value:"Choosing what to test",id:"choosing-what-to-test",level:3},{value:"Code coverage",id:"code-coverage",level:3},{value:"Backend vs Frontend",id:"backend-vs-frontend",level:2},{value:"Testing backend applications",id:"testing-backend-applications",level:3},{value:"Testing frontend applications",id:"testing-frontend-applications",level:3},{value:"TDD",id:"tdd",level:2},{value:"Three-step process",id:"three-step-process",level:3},{value:"Bottom-up vs Top-down",id:"bottom-up-vs-top-down",level:3},{value:"TDD environment",id:"tdd-environment",level:3},{value:"BDD",id:"bdd",level:2},{value:"Ref",id:"ref",level:2}],h={toc:c};function p(e){var t=e.components,r=(0,a.Z)(e,i);return(0,s.kt)("wrapper",(0,o.Z)({},h,r,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"lecture"},"Lecture"),(0,s.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,s.kt)("div",{parentName:"div",className:"admonition-heading"},(0,s.kt)("h5",{parentName:"div"},(0,s.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,s.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,s.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),(0,s.kt)("div",{parentName:"div",className:"admonition-content"},(0,s.kt)("p",{parentName:"div"},"Lecture Slides will be in OMA after the session."))),(0,s.kt)("h2",{id:"group-presentations"},"Group Presentations"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Unit Testing"),(0,s.kt)("li",{parentName:"ul"},"Testing React App"),(0,s.kt)("li",{parentName:"ul"},"Testing the backend"),(0,s.kt)("li",{parentName:"ul"},"End to End testing")),(0,s.kt)("h2",{id:"testing"},"Testing"),(0,s.kt)("h3",{id:"introduction"},"Introduction"),(0,s.kt)("p",null,"Automated tests are programs that automate the task of testing your software. These tests will interact with your application and compare its actual output to the expected output. They will pass when the output is correct and provide you with meaningful feedback when it isn\u2019t."),(0,s.kt)("p",null,"Tests that never fail are useless. The goal of having tests is for them to fail when the application misbehaves."),(0,s.kt)("p",null,"You can\u2019t prove your software works. You can prove only it doesn\u2019t. Tests show that particular bugs are no longer present\u2014not that there are no bugs. An almost infinite number of possible inputs could be given to your application, and it\u2019s not feasible to test all of them. Tests tend to cover bugs you\u2019ve seen before or particular kinds of situations you want to ensure will work."),(0,s.kt)("p",null,"Automated tests reduce the distance between the act of writing code and getting feedback. Therefore, they make your development process more structured and reduce the number of surprises. A predictable development process makes it easier to estimate tasks and allows developers to revisit their work less often."),(0,s.kt)("p",null,"Automated tests always follow the exact same series of steps. They don\u2019t forget or make mistakes. They ensure that test cases are followed thoroughly and make it easier to reproduce bugs."),(0,s.kt)("p",null,"When tests are automated, rework and communication overhead decrease. On their own, developers can immediately verify other people\u2019s work and ensure they haven\u2019t broken other parts of the application."),(0,s.kt)("p",null,"Well-written tests are the best documentation a developer can have. Because tests need to pass, they must always be up-to-date. They demonstrate the usage of an API and help others understand how the codebase works."),(0,s.kt)("p",null,"Automated tests are helpful because they drive up profits by helping developers deliver higher-quality software faster. However, when writing tests, you pay a big price up-front by investing extra time in creating them. You get value back in dividends. The more often a test runs, the more time it has saved you. Therefore, the longer the life cycle of a project, the more critical tests become as illustrated below."),(0,s.kt)("p",null,(0,s.kt)("img",{loading:"lazy",src:n(1980).Z,width:"462",height:"334"})),(0,s.kt)("h3",{id:"how-does-testing-work"},"How does testing work?"),(0,s.kt)("p",null,"Testing in Node.js applications has three major parts: the real code (written by you), the testing code (written by you), and the test runner (e.g Jest, Mocha):"),(0,s.kt)("p",null,"The real code is whatever you want to test. This might be a function, or a database model, or an Express server. In a Node.js context, this is anything that assigns something to module.exports."),(0,s.kt)("p",null,"The test code tests your real code. This will require whatever you want to test and then start asking questions about it. Does the function return what it should return? Do your objects behave as they should?"),(0,s.kt)("p",null,'The test runner is an executable that runs on your computer. It looks at your test code and runs it. Test runners commonly print out things like "These tests succeeded, these tests failed, and here\u2019s how" or "The tests took 100 milliseconds to run." '),(0,s.kt)("h4",{id:"what-to-test-and-when"},"What to test and when?"),(0,s.kt)("p",null,"All tests follow a similar formula: they set up a scenario, trigger an action, and check the results produced. This pattern is easy to remember by using the three ",(0,s.kt)("inlineCode",{parentName:"p"},"A")," mnemonic: arrange, act, and assert."),(0,s.kt)("p",null,"Test runners are tools we use to write tests. They provide helpful and concise ways for you to organize tests and obtain readable and meaningful output from them. Some test runners, like Jest, also ship with assertion libraries, which help us compare the actual output of an action with what was expected."),(0,s.kt)("p",null,"To facilitate the setup and teardown process of tests, Jest provides you with hooks that can run at different stages of the testing process. You can use beforeEach to run a function before each test, beforeAll to run it once before all tests, afterEach to run it after each test, and afterAll to run it once after all tests."),(0,s.kt)("p",null,"The testing pyramid is a visual metaphor that helps us separate types into different categories based on how often they should run, how many of them should exist, how big their scope is, and how strong the quality guarantees they produce are. As we ascend the pyramid, tests get scarcer, more valuable, cover a broader scope, and run less frequently as illustrated in the figure below.."),(0,s.kt)("p",null,(0,s.kt)("img",{loading:"lazy",src:n(6679).Z,width:"486",height:"313"})),(0,s.kt)("h3",{id:"unit-tests"},"Unit tests"),(0,s.kt)("p",null,"Unit tests are designed to run against functions. They are essential to assert the quality of your software at the most granular level possible, providing quick and precise feedback. These tests import your functions, feed them input, and check the output against what you expected as illustrated in the figure below.."),(0,s.kt)("p",null,(0,s.kt)("img",{loading:"lazy",src:n(9375).Z,width:"548",height:"286"})),(0,s.kt)("p",null,"Considering that unit tests are numerous and inexpensive, and run quickly and frequently, we place these tests at the bottom of the testing pyramid. They\u2019re the foundation other tests will build upon."),(0,s.kt)("p",null,(0,s.kt)("img",{loading:"lazy",src:n(9131).Z,width:"520",height:"267"})),(0,s.kt)("h3",{id:"integration-tests"},"Integration tests"),(0,s.kt)("p",null,"Integration tests are written to ensure that different parts of an application can work together. They verify whether you are using third-party libraries appropriately, such as database adapters. These tests act through your own software, but they may need access to external components, like a database or the filesystem, to set up a scenario and to check whether your application produced the desired result."),(0,s.kt)("p",null,(0,s.kt)("img",{loading:"lazy",src:n(3736).Z,width:"521",height:"290"})),(0,s.kt)("p",null,"You should write integration tests whenever it is fundamental to ensure that multiple parts of your program can work together or that they integrate correctly with third-party software.Considering the characteristics of Integration tests, they\u2019d go in the middle of the pyramid."),(0,s.kt)("p",null,(0,s.kt)("img",{loading:"lazy",src:n(2106).Z,width:"503",height:"267"})),(0,s.kt)("h3",{id:"end-to-end-tests"},"End-to-end tests"),(0,s.kt)("p",null,"End-to-end tests run against all layers of a program. Instead of directly calling functions, they interact with your application as a user would: by using a browser or sending HTTP requests, for example. They consider the application to be a \u201cblack box.\u201d These tests produce the strongest quality guarantees since they most closely resemble real use-case scenarios."),(0,s.kt)("p",null,(0,s.kt)("img",{loading:"lazy",src:n(8190).Z,width:"521",height:"290"})),(0,s.kt)("p",null,"End-to-end tests  are placed at the top of the pyramid. This tells us that they\u2019re very valuable and that you need a smaller quantity of them. Just a few can already cover large parts of your application. In contrast, unit tests focus on a single function and, therefore, need to be more frequent."),(0,s.kt)("p",null,(0,s.kt)("img",{loading:"lazy",src:n(7837).Z,width:"444",height:"267"})),(0,s.kt)("h4",{id:"testing-http-apis"},"Testing HTTP APIs"),(0,s.kt)("p",null,"Tests for RESTful APIs require only a client capable of performing HTTP requests and inspecting responses, therefore we can write them within Jest. These tests will cover the entire backend of your application, as well as the HTTP API it exposes, as shown below:"),(0,s.kt)("p",null,(0,s.kt)("img",{loading:"lazy",src:n(2901).Z,width:"568",height:"352"})),(0,s.kt)("p",null,"The scope of tests for HTTP APIs is broad, but it is still narrower than the scope of tests that target GUIs. Tests that comprise GUIs examine the entire application, whereas tests for HTTP APIs only probe its backend. Because of this difference in scope, we will subdivide the area for end-to-end tests in the testing pyramid and place HTTP API tests below GUI tests, as you can see in figure below:"),(0,s.kt)("p",null,(0,s.kt)("img",{loading:"lazy",src:n(1379).Z,width:"515",height:"270"})),(0,s.kt)("h4",{id:"testing-guis"},"Testing GUIs"),(0,s.kt)("p",null,"GUI tests cover your entire application. They will use its client to interact with your backend, therefore, touching every single piece of your stack, as illustrates below:"),(0,s.kt)("p",null,(0,s.kt)("img",{loading:"lazy",src:n(3272).Z,width:"542",height:"352"})),(0,s.kt)("p",null,"Writing end-to-end tests for GUIs involves particular requirements and, therefore, requires special tools."),(0,s.kt)("p",null,"Tools for end-to-end testing GUIs need to be capable of interacting with a web page\u2019s elements, like buttons and forms. Because of these demands, they need to be able to control a real browser. Otherwise, the tests will not simulate the user\u2019s actions precisely."),(0,s.kt)("p",null,"At the moment, the most popular tools for UI testing are Cypress, and Selenium. It\u2019s possible to use these tools to make a browser interact with your application by using JavaScript to control them."),(0,s.kt)("p",null,"The overall structure of UI tests is similar to other types of tests. UI tests still require you to set up a scenario, perform actions, and then do assertions. The main difference between UI tests and other types of tests is that instead of merely calling functions or performing requests, your actions happen through the browser and assertions depend on a web page\u2019s content."),(0,s.kt)("p",null,"GUI tests also bring to light many new concerns, mostly related to the irregularity of how a real browser behaves. Waiting for pages to load, for text to render, for elements to be ready for interaction, or for a web page to perform HTTP requests and update itself are examples of actions that are usually troublesome. They tend to be unpredictable, and different machines can take different times to complete them."),(0,s.kt)("p",null,"Because these tests cover all parts of your application, they have the highest place in the testing pyramid, as shown in below. They take the longest to run, but they also provide the strongest possible guarantees."),(0,s.kt)("p",null,(0,s.kt)("img",{loading:"lazy",src:n(812).Z,width:"485",height:"270"})),(0,s.kt)("p",null,"Tests, just like code, have maintenance costs associated to them. The more often you have to update tests, the more expensive they are. You can reduce tests\u2019 costs by keeping code readable, avoiding duplication, decreasing coupling between tests and application code, and separating your verifications into multiple tests to create transitive guarantees."),(0,s.kt)("h2",{id:"testing-techniques"},"Testing techniques"),(0,s.kt)("h3",{id:"test-suites"},"Test suites"),(0,s.kt)("p",null,"To create different groups of tests within a file, you can nest them within a describe block. Nesting your tests into multiple blocks enables you to encapsulate variables, functions, and even hooks, which become relative to the block of tests in which they are placed. For a cart Controller module, for example, your test file could look as follows."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},'describe("addItemToCart", () => {                  \u2776\n    test("add an available item to cart", () => {\n        // ...\n    });\n \n    test("add unavailable item to cart", () => {\n        // ...\n    });\n \n    test("add multiple items to cart", () => {\n        // ...\n    });\n});\n \ndescribe("removeFromCart", () => {                \u2777\n    test("remove item from cart", () => {\n        // ...\n    });\n});\n')),(0,s.kt)("h3",{id:"mocks-stubs-and-spies"},"Mocks, stubs, and spies"),(0,s.kt)("p",null,"Mocks, stubs, and spies are objects used to modify and replace parts of your application to ease or enable testing."),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Spies record data related to the usage of a function without interfering in its implementation."),(0,s.kt)("li",{parentName:"ul"},"Stubs record data associated with the usage of a function and change its behavior, either by providing an alternative implementation or return value."),(0,s.kt)("li",{parentName:"ul"},"Mocks change a function\u2019s behavior, but instead of just recording information about its usage, they have expectations preprogrammed.")),(0,s.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,s.kt)("div",{parentName:"div",className:"admonition-heading"},(0,s.kt)("h5",{parentName:"div"},(0,s.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,s.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,s.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),(0,s.kt)("div",{parentName:"div",className:"admonition-content"},(0,s.kt)("p",{parentName:"div"},"Engineers often conflate the terms mocks, stubs, and spies, even though, formally, these terms have different definitions."),(0,s.kt)("p",{parentName:"div"},"Especially in the context of Jest, you will frequently see people referring to stubs and spies as mocks. This confusion happens because Jest\u2019s API and documentation tends to use the name mock for every kind of test double."))),(0,s.kt)("h3",{id:"choosing-what-to-test"},"Choosing what to test"),(0,s.kt)("p",null,"Having a large number of tests is helpful to create reliable quality guarantees, but they can be burdensome to update. Therefore, it\u2019s as crucial to determine what to test as it is to determine what not to."),(0,s.kt)("p",null,"Avoid testing third-party software. That\u2019s the responsibility of the third-party software\u2019s authors. If you want to add tests for it, contribute to the library\u2019s repository instead, so that everyone benefits from it, including you, who won\u2019t have to maintain those tests on your own."),(0,s.kt)("p",null," More mocking makes tests less similar to reality and, therefore, less valuable. If mocking is too difficult, or if it will cause your test not to be valuable because it touches very few parts of your application, avoid mocking."),(0,s.kt)("p",null,"Different kinds of tests can generate a significant amount of overlap. If you have to choose only one type of test, it\u2019s better to choose an integration test. Integration tests run reasonably quickly, tend to be easy to write, and provide reliable quality guarantees."),(0,s.kt)("h3",{id:"code-coverage"},"Code coverage"),(0,s.kt)("p",null,"Code coverage is a metric that indicates how much of your code is executed when you run tests."),(0,s.kt)("p",null,"By measuring code coverage, you can understand which parts of your code you\u2019ve forgotten to test and, therefore, add the necessary validations for them."),(0,s.kt)("p",null,"Code coverage can be measured against statements, branches, functions, or lines."),(0,s.kt)("p",null,"Having a high percentage of code coverage does not mean your tests are good. It\u2019s possible to have 100% of your code covered and still let bugs slip through, because code coverage doesn\u2019t take into account all the possible inputs that can be passed to your program or all the possible combinations of its execution branches."),(0,s.kt)("p",null,"You should use code coverage reports to understand which pieces of code you\u2019ve forgotten to test and to guarantee your team is committing tests and progressing toward more coverage, not to determine the quality of your tests. "),(0,s.kt)("h2",{id:"backend-vs-frontend"},"Backend vs Frontend"),(0,s.kt)("h3",{id:"testing-backend-applications"},"Testing backend applications"),(0,s.kt)("p",null,"To ease testing HTTP endpoints and avoid bloat, you can use supertest, which bundles together a flexible API for performing requests and asserting on their content. With supertest, you can avoid performing complicated and repetitive assertions, and you won\u2019t have to write your own wrappers on top of HTTP request libraries."),(0,s.kt)("p",null,"SuperTest spools up your Express server and sends requests to it. Once the requests come back, you can make assertions about the response. For example, you might want to make sure that you get an HTTP 200 status code when you send a GET request to the homepage. SuperTest will send that GET request to the homepage and then, when you get the response, make sure it has 200 as its HTTP status code. You can use this to test the middleware or routes that you define in your application."),(0,s.kt)("p",null,"When dealing with databases, your testing pipeline must ensure that they will be available. By using global setup and teardown scripts, you can guarantee that their schema will be up-to-date and that the necessary seed data will be present."),(0,s.kt)("h3",{id:"testing-frontend-applications"},"Testing frontend applications"),(0,s.kt)("p",null,"Browsers react to complex user interactions, like typing, clicking, and scrolling. To deal with those interactions, browsers depend on events. Because tests are more reliable when they accurately simulate what happens at run time, your tests should simulate events as precisely as possible."),(0,s.kt)("p",null,"One way to accurately reproduce events is to use the fireEvent function from dom-testing-library or the utilities provided by user-event, another library under the testing-library organization."),(0,s.kt)("p",null,"You can test events and their handlers at different levels of integration. If you want more granular feedback as you write code, you can test your handlers by directly invoking them. If you would like to trade granular feedback for more reliable guarantees, you can dispatch real events instead."),(0,s.kt)("p",null,"If your application uses Web APIs like the History or Web Storage API, you can use their JSDOM implementations in your tests. Remember that you should not test these APIs themselves; you should test whether your application interacts adequately with them."),(0,s.kt)("p",null,"To test your React applications, you can use react-testing-library which addresses React-specific concerns straight out of the box. These concerns include automatically unmounting components, returning queries scoped to the component\u2019s wrapper, and wrapping interactions into act to make sure that updates were processed and applied to the DOM."),(0,s.kt)("p",null,"When testing React applications, it\u2019s interesting to think of the testing pyramid as a continuous spectrum, rather than a discrete set of categories. Because of how thin the integration layer between React and your tests is, you would put tests that involve a single component into the bottom part of the pyramid, even though they don\u2019t stub React itself. The more components and different pieces of code a test involves, the higher it goes in the pyramid."),(0,s.kt)("h2",{id:"tdd"},"TDD"),(0,s.kt)("p",null,"Test-driven development (TDD) is a software development methodology that uses tests to help you iteratively produce correct code."),(0,s.kt)("h3",{id:"three-step-process"},"Three-step process"),(0,s.kt)("p",null,'When performing test-driven development, you\u2019ll follow a three-step process, which you can repeat as many times as you need until you reach a final working implementation. You\u2019ll write a failing test first, then you\u2019ll write the code necessary to make the test pass, and finally, you\u2019ll refactor the code you\u2019ve written. These three steps are also known as "red, green, refactor".'),(0,s.kt)("p",null,(0,s.kt)("img",{loading:"lazy",src:n(223).Z,width:"454",height:"166"})," "),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"The red step. Because it\u2019s TDD, you write your tests first. When you write these tests before you write any of the real code, none of your tests will pass\u2014how could they when no real code has been written? During the red step, you write all of your tests and run them to watch them all fail. This step is so named for the red color that you usually see when you have a failing test."),(0,s.kt)("li",{parentName:"ul"},"The green step. Now that you\u2019ve written all of your tests, you begin to fill in the real code to satisfy all the tests. As you make progress, your tests will slowly go from red (failing) to green (passing). Like the previous step, it\u2019s called the green step because you typically see green for a passing test. Once you\u2019re all green (all of your tests pass), you\u2019re ready for the step 3."),(0,s.kt)("li",{parentName:"ul"},"The refactor step. If all of your tests are green, that means all of your code works, but it might not be perfect. Perhaps one of your functions is slow or you\u2019ve chosen bad variable names. Like a writer cleaning up a draft of a book, you go back and clean up the code. Because you have all of your tests, you can refactor without worrying that you\u2019re breaking some unforeseen part of your code."),(0,s.kt)("li",{parentName:"ul"},"Repeat the process. You probably haven\u2019t written all of your code for the project, so go back to step 1 and write tests for the next part.")),(0,s.kt)("p",null,"In a test-driven workflow, the more confident you are, the bigger your steps should be. If you\u2019re feeling confident about the code you need to write, you can start with bigger tests and implement larger chunks of code at a time. If not, you can begin with tiny tests and write smaller pieces of code at a time."),(0,s.kt)("p",null,(0,s.kt)("img",{loading:"lazy",src:n(6413).Z,width:"666",height:"150"})," "),(0,s.kt)("p",null,"Test-driven development reduces costs because it helps you detect mistakes earlier in the development process. The sooner your tests detect bugs, the fewer places there will be for them to hide, and the fewer lines of code you\u2019ll have to undo. Additionally, catching bugs during development prevents them from affecting customers and impacting your costs or revenue."),(0,s.kt)("p",null,"By taking an iterative approach to writing code, you tighten your feedback loop, and your confidence builds as you write code. This tight feedback loop reduces anxiety and guides you through the development process."),(0,s.kt)("p",null,"Because in test-driven development you\u2019ll see your tests failing before writing the necessary code, you\u2019ll be more confident that your tests can detect flaws in your software."),(0,s.kt)("h3",{id:"bottom-up-vs-top-down"},"Bottom-up vs Top-down"),(0,s.kt)("p",null,"Taking a bottom-up approach to your tests mean testing smaller pieces of software first and moving up toward higher layers of abstraction. "),(0,s.kt)("p",null,(0,s.kt)("img",{loading:"lazy",src:n(3235).Z,width:"886",height:"266"})," "),(0,s.kt)("p",null,"A top-down approach consists of testing higher layers of abstraction first, so that you can also cover the underlying pieces of software upon which they depend."),(0,s.kt)("p",null,(0,s.kt)("img",{loading:"lazy",src:n(9249).Z,width:"894",height:"265"})," "),(0,s.kt)("p",null,"A bottom-up approach to testing allows you to take smaller steps and help you build confidence as you iterate. When you\u2019re not feeling confident about the code you need to write, you should adopt this approach. The problem with a bottom-up testing strategy is that it\u2019s slow when compared to a top-down approach. It also creates an overlap between your tests, increasing your maintenance costs."),(0,s.kt)("p",null,"A top-down approach to testing will force you to write bigger chunks of code at a time, which results in a more loose feedback loop. Because this loose feedback loop will make it more difficult for you to find bugs, you should adopt it only when you\u2019re feeling confident. The advantage of using a top-down testing strategy is that it allows you to iterate more quickly and creates less overlap between tests, reducing maintenance costs."),(0,s.kt)("p",null,"Creating code demands that you focus on correctness and iteration speed over maintenance costs. To decide whether you should take a bottom-up or top-down approach to your tests during your unit under test\u2019s implementation phase, you should take into account how confident you feel and adjust the size of your steps accordingly. If you\u2019re feeling confident, adopt a top-down approach; otherwise, try testing from the bottom up."),(0,s.kt)("p",null,"When maintaining code, you can turn the granular tests you\u2019ve created when taking a bottom-up approach into more coarse tests, whose scope is bigger and quality guarantees are more reliable. During the maintenance phase of your unit under test, you can spend more time to reduce your tests\u2019 overlap and, therefore, their costs."),(0,s.kt)("h3",{id:"tdd-environment"},"TDD environment"),(0,s.kt)("p",null,"To create an environment in which test-driven development can flourish, you need your whole team to embrace it. When an entire team adopts a test-driven workflow, developers will build each new feature upon solid foundations and will have automated checks to help them produce code with more confidence."),(0,s.kt)("p",null,"When bundling tests and code deliveries, communication is facilitated because the tests demonstrate how to use the software, serving as documentation for the units under test."),(0,s.kt)("p",null,"Especially when adopting a test-driven workflow, try to keep engineers working on distinct parts of the code. By working on different parts of the software, engineers will be more efficient, because they\u2019ll need to interrupt each other less often and will have fewer conflicts to fix."),(0,s.kt)("p",null,(0,s.kt)("img",{loading:"lazy",src:n(4514).Z,width:"493",height:"188"})," "),(0,s.kt)("p",null,"Pairing is an excellent alternative to avoid having engineers simultaneously working in conflicting pieces of code. It can be especially productive when combined with a test-driven workflow, because test-driven development makes pairing sessions more interactive and makes it easier for engineers to agree on the result they want to achieve."),(0,s.kt)("p",null,(0,s.kt)("img",{loading:"lazy",src:n(1214).Z,width:"407",height:"313"})," "),(0,s.kt)("h2",{id:"bdd"},"BDD"),(0,s.kt)("p",null,"Behavior-driven development (BDD) is a software development practice that facilitates the communication between the technical and nontechnical stakeholders of a project by creating a collaborative process in which members of different teams express requirements in a shared language."),(0,s.kt)("p",null,"By writing requirements in a language that\u2019s shared between multiple members of different teams, engineers can deliver precisely what the business needs. Additionally, edge cases can be exposed and solved earlier, without the need for rework."),(0,s.kt)("p",null,"When taking a behavior-driven approach to software development, the business requirements are translated into automated tests that match the specification\u2019s language, resulting in tests that validate the software\u2019s functional requirements."),(0,s.kt)("h2",{id:"ref"},"Ref"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Testing JavaScript Applications, Lucas Fernandes da Costas"),(0,s.kt)("li",{parentName:"ul"},"Express in Action, Evan Hahn")))}p.isMDXComponent=!0},1980:function(e,t,n){t.Z=n.p+"assets/images/tdd1-22808f3fd14b3a65920d913ce254d5fa.png"},1379:function(e,t,n){t.Z=n.p+"assets/images/tdd10-a4b6af1473ab8d96d22abb5f22fac260.png"},3272:function(e,t,n){t.Z=n.p+"assets/images/tdd11-c43480bb37964b2fc5ad769c947ff657.png"},812:function(e,t,n){t.Z=n.p+"assets/images/tdd12-9e227eededc81cc57dffd3978d915878.png"},223:function(e,t,n){t.Z=n.p+"assets/images/tdd13-d52f6244d1c0b66f47e91ce58d52ef9f.png"},6413:function(e,t,n){t.Z=n.p+"assets/images/tdd14-95d9ae9984a437f5433876c7d638d4a6.png"},3235:function(e,t,n){t.Z=n.p+"assets/images/tdd15-01b6f11d657984c2a1a979ed46a4ed7a.png"},9249:function(e,t,n){t.Z=n.p+"assets/images/tdd16-c4be1269d93095aec4a19e65cc626568.png"},4514:function(e,t,n){t.Z=n.p+"assets/images/tdd17-f21412207d89e43cafcd943bae45fe1d.png"},1214:function(e,t,n){t.Z=n.p+"assets/images/tdd18-8b4b06877d6bd4d4b984e4d87c94ef39.png"},6679:function(e,t,n){t.Z=n.p+"assets/images/tdd2-1188158eb535b4ed8db38403fa496598.png"},9375:function(e,t,n){t.Z=n.p+"assets/images/tdd3-b0c0267afa52b26408c6bb26bae6c07e.png"},9131:function(e,t,n){t.Z=n.p+"assets/images/tdd4-b3bd8f58b37bae4feb9d272167fadea5.png"},3736:function(e,t,n){t.Z=n.p+"assets/images/tdd5-9e8cd02c0c56b09add4847acb4aa92e8.png"},2106:function(e,t,n){t.Z=n.p+"assets/images/tdd6-a236ad8c1802b6100015c507d088b576.png"},8190:function(e,t,n){t.Z=n.p+"assets/images/tdd7-789b70e04b352684ea74c4ac42a0edac.png"},7837:function(e,t,n){t.Z=n.p+"assets/images/tdd8-68d5a5a58334233d10ce9a33a7e2d517.png"},2901:function(e,t,n){t.Z=n.p+"assets/images/tdd9-510de28a7038fae0e2e69bd08022c4c9.png"}}]);