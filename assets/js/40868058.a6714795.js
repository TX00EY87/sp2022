"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[7255],{3905:function(e,n,t){t.d(n,{Zo:function(){return c},kt:function(){return d}});var a=t(7294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var l=a.createContext({}),u=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},c=function(e){var n=u(e.components);return a.createElement(l.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},h=a.forwardRef((function(e,n){var t=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),h=u(t),d=o,m=h["".concat(l,".").concat(d)]||h[d]||p[d]||r;return t?a.createElement(m,s(s({ref:n},c),{},{components:t})):a.createElement(m,s({ref:n},c))}));function d(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var r=t.length,s=new Array(r);s[0]=h;var i={};for(var l in n)hasOwnProperty.call(n,l)&&(i[l]=n[l]);i.originalType=e,i.mdxType="string"==typeof e?e:o,s[1]=i;for(var u=2;u<r;u++)s[u]=t[u];return a.createElement.apply(null,s)}return a.createElement.apply(null,t)}h.displayName="MDXCreateElement"},5591:function(e,n,t){t.r(n),t.d(n,{assets:function(){return c},contentTitle:function(){return l},default:function(){return d},frontMatter:function(){return i},metadata:function(){return u},toc:function(){return p}});var a=t(7462),o=t(3366),r=(t(7294),t(3905)),s=["components"],i={title:"Lecture",sidebar_label:"Lecture",pagination_next:null,pagination_prev:null,hide_table_of_contents:!1},l="Lecture",u={unversionedId:"lecture-05/lecture",id:"lecture-05/lecture",title:"Lecture",description:"Lecture Slides will be in OMA after the session.",source:"@site/docs/lecture-05/lecture.md",sourceDirName:"lecture-05",slug:"/lecture-05/lecture",permalink:"/sp2022/lecture-05/lecture",tags:[],version:"current",frontMatter:{title:"Lecture",sidebar_label:"Lecture",pagination_next:null,pagination_prev:null,hide_table_of_contents:!1},sidebar:"docs"},c={},p=[{value:"Arrow functions",id:"arrow-functions",level:2},{value:"Basic syntax",id:"basic-syntax",level:3},{value:"Function body",id:"function-body",level:3},{value:"Returning object literals",id:"returning-object-literals",level:3},{value:"Line breaks",id:"line-breaks",level:3},{value:"Asynchronous programming",id:"asynchronous-programming",level:2},{value:"Synchronous programming",id:"synchronous-programming",level:3},{value:"A long-running synchronous function",id:"a-long-running-synchronous-function",level:3},{value:"The trouble with long-running synchronous functions",id:"the-trouble-with-long-running-synchronous-functions",level:4},{value:"Event handlers",id:"event-handlers",level:3},{value:"Callbacks",id:"callbacks",level:3},{value:"Promises",id:"promises",level:2},{value:"Using the fetch() API",id:"using-the-fetch-api",level:3},{value:"Chaining promises",id:"chaining-promises",level:3},{value:"Catching errors",id:"catching-errors",level:3},{value:"Promise terminology",id:"promise-terminology",level:3},{value:"Conclusion",id:"conclusion",level:3},{value:"Ref",id:"ref",level:2}],h={toc:p};function d(e){var n=e.components,t=(0,o.Z)(e,s);return(0,r.kt)("wrapper",(0,a.Z)({},h,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"lecture"},"Lecture"),(0,r.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,r.kt)("div",{parentName:"div",className:"admonition-heading"},(0,r.kt)("h5",{parentName:"div"},(0,r.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,r.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,r.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),(0,r.kt)("div",{parentName:"div",className:"admonition-content"},(0,r.kt)("p",{parentName:"div"},"Lecture Slides will be in OMA after the session."))),(0,r.kt)("h2",{id:"arrow-functions"},"Arrow functions"),(0,r.kt)("p",null,"Arrow functions are a useful new feature of ES6. With arrow functions, you can create functions without using the function keyword. You also often do not have to use the return keyword. The example\xa0below shows the traditional function syntax."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Note: arrow function expressions are best suited for non-method functions.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"// Traditional Anonymous Function\nfunction (a){\n  return a + 100;\n}\n")),(0,r.kt)("p",null,"With an arrow function, we can simplify the syntax tremendously, as shown:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"// arrow function\na => a + 100;\n")),(0,r.kt)("p",null,'Let\'s decompose a "traditional anonymous function" down to the simplest "arrow function" step-by-step:'),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Note:"),' Each step along the way is a valid "arrow function".')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'// Traditional Anonymous Function\nfunction (a){\n  return a + 100;\n}\n\n// Arrow Function Break Down\n\n// 1. Remove the word "function" and place arrow between the argument and opening body bracket\n(a) => {\n  return a + 100;\n}\n\n// 2. Remove the body braces and word "return" -- the return is implied.\n(a) => a + 100;\n\n// 3. Remove the argument parentheses\na => a + 100;\n')),(0,r.kt)("p",null,'The { braces } and ( parentheses ) and "return" are required in some cases.'),(0,r.kt)("p",null,"For example, if you have ",(0,r.kt)("strong",{parentName:"p"},"multiple arguments")," or ",(0,r.kt)("strong",{parentName:"p"},"no\narguments"),", you'll need to re-introduce parentheses around the arguments:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"// Traditional Anonymous Function\nfunction (a, b){\n  return a + b + 100;\n}\n\n// Arrow Function\n(a, b) => a + b + 100;\n\n// Traditional Anonymous Function (no arguments)\nlet a = 4;\nlet b = 2;\nfunction (){\n  return a + b + 100;\n}\n\n// Arrow Function (no arguments)\nlet a = 4;\nlet b = 2;\n() => a + b + 100;\n")),(0,r.kt)("p",null,"Likewise, if the body requires ",(0,r.kt)("strong",{parentName:"p"},"additional lines")," of processing, you'll\nneed to re-introduce braces ",(0,r.kt)("strong",{parentName:"p"},'PLUS the "return"'),' (arrow functions do not\nmagically guess what or when you want to "return"):'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"// Traditional Anonymous Function\nfunction (a, b){\n  let chuck = 42;\n  return a + b + chuck;\n}\n\n// Arrow Function\n(a, b) => {\n  let chuck = 42;\n  return a + b + chuck;\n}\n")),(0,r.kt)("p",null,"And finally, for ",(0,r.kt)("strong",{parentName:"p"},"named functions")," we treat arrow expressions like\nvariables:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"// Traditional Function\nfunction bob (a){\n  return a + 100;\n}\n\n// Arrow Function\nlet bob = a => a + 100;\n")),(0,r.kt)("h3",{id:"basic-syntax"},"Basic syntax"),(0,r.kt)("p",null,"One param. With simple expression return is not needed:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"param => expression\n")),(0,r.kt)("p",null,"Multiple params require parentheses. With simple\nexpression return is not needed:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"(param1, paramN) => expression\n")),(0,r.kt)("p",null,"Multiline statements require body braces and return:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"param => {\n  let a = 1;\n  return a + param;\n}\n")),(0,r.kt)("p",null,"Multiple params require parentheses. Multiline statements\nrequire body braces and return:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"(param1, paramN) => {\n   let a = 1;\n   return a + param1 + paramN;\n}\n")),(0,r.kt)("h3",{id:"function-body"},"Function body"),(0,r.kt)("p",null,'Arrow functions can have either a "concise body" or the usual "block body".'),(0,r.kt)("p",null,"In a concise body, only an expression is specified, which becomes the implicit return\nvalue. In a block body, you must use an explicit ",(0,r.kt)("inlineCode",{parentName:"p"},"return")," statement."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'var func = x => x * x;\n// concise body syntax, implied "return"\n\nvar func = (x, y) => { return x + y; };\n// with block body, explicit "return" needed\n')),(0,r.kt)("h3",{id:"returning-object-literals"},"Returning object literals"),(0,r.kt)("p",null,"Keep in mind that returning object literals using the concise body syntax\n",(0,r.kt)("inlineCode",{parentName:"p"},"params => {object:literal}")," will not work as expected."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"var func = () => { foo: 1 };\n// Calling func() returns undefined!\n\nvar func = () => { foo: function() {} };\n// SyntaxError: function statement requires a name\n")),(0,r.kt)("p",null,"This is because the code inside braces ({}) is parsed as a sequence of statements (i.e.\n",(0,r.kt)("inlineCode",{parentName:"p"},"foo")," is treated like a label, not a key in an object literal)."),(0,r.kt)("p",null,"You must wrap the object literal in parentheses:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"var func = () => ({ foo: 1 });\n")),(0,r.kt)("h3",{id:"line-breaks"},"Line breaks"),(0,r.kt)("p",null,"An arrow function cannot contain a line break between its parameters and its arrow."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"var func = (a, b, c)\n  => 1;\n// SyntaxError: expected expression, got '=>'\n")),(0,r.kt)("p",null,"However, this can be amended by putting the line break after the arrow or using\nparentheses/braces as seen below to ensure that the code stays pretty and fluffy. You\ncan also put line breaks between arguments."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"var func = (a, b, c) =>\n  1;\n\nvar func = (a, b, c) => (\n  1\n);\n\nvar func = (a, b, c) => {\n  return 1\n};\n\nvar func = (\n  a,\n  b,\n  c\n) => 1;\n\n// no SyntaxError thrown\n")),(0,r.kt)("h2",{id:"asynchronous-programming"},"Asynchronous programming"),(0,r.kt)("p",null,"We'll explain what asynchronous programming is, why we need it, and briefly discuss some of the ways asynchronous functions have historically been implemented in JavaScript."),(0,r.kt)("p",null,"Asynchronous programming is a technique that enables your program to start a potentially long-running task, and then rather than having to wait until that task has finished, to be able to continue to be responsive to other events while the task runs. Once the task is completed, your program is presented with the result."),(0,r.kt)("p",null,"Many functions provided by browsers, and especially the most interesting ones, can potentially take a long time, and are therefore asynchronous. For example making HTTP requests with fetch()"),(0,r.kt)("p",null,"So even though you may not have to ",(0,r.kt)("em",{parentName:"p"},"implement")," your own asynchronous functions very often, you are very likely to need to ",(0,r.kt)("em",{parentName:"p"},"use")," them correctly."),(0,r.kt)("p",null,"We'll start by looking at the problem with long-running synchronous functions, which make asynchronous programming a necessity."),(0,r.kt)("h3",{id:"synchronous-programming"},"Synchronous programming"),(0,r.kt)("p",null,"Consider the following code:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const name = 'Miriam';\nconst greeting = `Hello, my name is ${name}!`;\nconsole.log(greeting);\n// \"Hello, my name is Miriam!\"\n")),(0,r.kt)("p",null,"This code:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"declares a string called ",(0,r.kt)("inlineCode",{parentName:"li"},"name")),(0,r.kt)("li",{parentName:"ol"},"declares another string called ",(0,r.kt)("inlineCode",{parentName:"li"},"greeting"),", that uses ",(0,r.kt)("inlineCode",{parentName:"li"},"name")),(0,r.kt)("li",{parentName:"ol"},"logs the greeting to the JavaScript console.")),(0,r.kt)("p",null,"What we should note here is that the browser effectively steps through the program one line at a time, in the order we wrote it, and at each point it waits for the line to finish its work, before going on to the next line. It has to do this, because each line depends on the work that was done in the preceding lines."),(0,r.kt)("p",null,"That makes this a ",(0,r.kt)("strong",{parentName:"p"},"synchronous program"),". It would still be synchronous if we called out to a separate function, like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"function makeGreeting(name) {\n  return `Hello, my name is ${name}!`;\n}\n\nconst name = 'Miriam';\nconst greeting = makeGreeting(name);\nconsole.log(greeting);\n// \"Hello, my name is Miriam!\"\n")),(0,r.kt)("p",null,"Here ",(0,r.kt)("inlineCode",{parentName:"p"},"makeGreeting()")," is a ",(0,r.kt)("strong",{parentName:"p"},"synchronous function"),", because the caller has to wait for the function to finish its work before the function returns."),(0,r.kt)("h3",{id:"a-long-running-synchronous-function"},"A long-running synchronous function"),(0,r.kt)("p",null,"What if the synchronous function takes a long time?"),(0,r.kt)("p",null,'This program generates a number of large prime numbers, using a very inefficient algorithm, when the user clicks the "Generate primes" button. You can control the number of primes to generate, which of course affects how long the operation will take.'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-html"},'<label for="quota">Number of primes:</label>\n<input type="text" id="quota" name="quota" value="1000000">\n\n<button id="generate">Generate primes</button>\n<button id="reload">Reload</button>\n\n<div id="output"></div>\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"function generatePrimes(quota) {\n\n  function isPrime(n) {\n    for (let c = 2; c <= Math.sqrt(n); ++c) {\n      if (n % c === 0) {\n          return false;\n       }\n    }\n    return true;\n  }\n\n  const primes = [];\n  const maximum = 1000000;\n\n  while (primes.length < quota) {\n    const candidate = Math.floor(Math.random() * (maximum + 1));\n    if (isPrime(candidate)) {\n      primes.push(candidate);\n    }\n  }\n\n  return primes;\n}\n\ndocument.querySelector('#generate').addEventListener('click', () => {\n  const quota = document.querySelector('#quota').value;\n  const primes = generatePrimes(quota);\n  document.querySelector('#output').textContent = `Finished generating ${quota} primes!`;\n});\n\ndocument.querySelector('#reload').addEventListener('click', () => {\n  document.location.reload()\n});\n")),(0,r.kt)("p",null,'Try clicking "Generate primes". Depending on how fast your computer is, it will probably take a few seconds before the program displays the "Finished!" message.'),(0,r.kt)("h4",{id:"the-trouble-with-long-running-synchronous-functions"},"The trouble with long-running synchronous functions"),(0,r.kt)("p",null,'The next example is just like the last one, except we added a text box for you to type in. This time, try clicking "Generate primes", then typing in the text box.'),(0,r.kt)("p",null,"You'll find that while our ",(0,r.kt)("inlineCode",{parentName:"p"},"generatePrimes()")," function is running, our program is completely unresponsive: the user can't type anything, or click anything, or do anything else."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-html",metastring:"hidden",hidden:!0},'<label for="quota">Number of primes:</label>\n<input type="text" id="quota" name="quota" value="1000000">\n\n<button id="generate">Generate primes</button>\n<button id="reload">Reload</button>\n\n<textarea id="user-input" rows="5" cols="62">\nTry typing in here immediately after pressing "Generate primes"\n</textarea>\n\n<div id="output"></div>\n\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-css",metastring:"hidden",hidden:!0},"textarea {\n  display: block;\n  margin: 1rem 0;\n}\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js",metastring:"hidden",hidden:!0},"function generatePrimes(quota) {\n\n  function isPrime(n) {\n    for (let c = 2; c <= Math.sqrt(n); ++c) {\n      if (n % c === 0) {\n          return false;\n       }\n    }\n    return true;\n  }\n\n  const primes = [];\n  const maximum = 1000000;\n\n  while (primes.length < quota) {\n    const candidate = Math.floor(Math.random() * (maximum + 1));\n    if (isPrime(candidate)) {\n      primes.push(candidate);\n    }\n  }\n\n  return primes;\n}\n\ndocument.querySelector('#generate').addEventListener('click', () => {\n  const quota = document.querySelector('#quota').value;\n  const primes = generatePrimes(quota);\n  document.querySelector('#output').textContent = `Finished generating ${quota} primes!`;\n});\n\ndocument.querySelector('#reload').addEventListener('click', () => {\n  document.querySelector('#user-input').value = 'Try typing in here immediately after pressing \"Generate primes\"';\n  document.location.reload();\n});\n")),(0,r.kt)("p",null,"This is the basic problem with long-running synchronous functions. What we would like here is a way that our program can:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"start a long-running operation by calling a function"),(0,r.kt)("li",{parentName:"ul"},"have the function start the operation and return right away, so our program can still be responsive to other events"),(0,r.kt)("li",{parentName:"ul"},"be notified with the result of the operation, when it eventually completes.")),(0,r.kt)("p",null,"That's what an asynchronous function offers us, and the rest of this module explains how they are implemented in JavaScript."),(0,r.kt)("h3",{id:"event-handlers"},"Event handlers"),(0,r.kt)("p",null,'The description we just saw of asynchronous functions might remind you of event handlers, and if it does, you\'d be right. Event handlers are really a form of asynchronous programming: you provide a function (the event handler) that will be called, not right away, but whenever the event happens. If "the event" is "the asynchronous operation has completed", then you could see how an event could be used to notify the caller about the result of an asynchronous function call.'),(0,r.kt)("p",null,"Some early asynchronous APIs used events in just this way. The XMLHttpRequest API enables you to make HTTP requests to a remote server using JavaScript. Since this can take a long time, it's an asynchronous API, and you get notified about the progress and eventual completion of a request by attaching event listeners to the ",(0,r.kt)("inlineCode",{parentName:"p"},"XMLHttpRequest")," object."),(0,r.kt)("p",null,'The following example shows this in action. Press "Click to start request" to send a request. We create a new XMLHttpRequest and listen for its loadend event. The handler logs a "Finished!" message along with the status code.'),(0,r.kt)("p",null,'After adding the event listener we send the request. Note that after this, we can log "Started XHR request": that is, our program can continue to run while the request is going on, and our event handler will be called when the request is complete.'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-html"},'<button id="xhr">Click to start request</button>\n<button id="reload">Reload</button>\n\n<pre readonly class="event-log"></pre>\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-css",metastring:"hidden",hidden:!0},"pre {\n  display: block;\n  margin: 1rem 0;\n}\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const log = document.querySelector('.event-log');\n\ndocument.querySelector('#xhr').addEventListener('click', () => {\n  log.textContent = '';\n\n  const xhr = new XMLHttpRequest();\n\n  xhr.addEventListener('loadend', () => {\n    log.textContent = `${log.textContent}Finished with status: ${xhr.status}`;\n  });\n\n  xhr.open('GET', 'https://raw.githubusercontent.com/mdn/content/main/files/en-us/_wikihistory.json');\n  xhr.send();\n  log.textContent = `${log.textContent}Started XHR request\\n`;});\n\ndocument.querySelector('#reload').addEventListener('click', () => {\n  log.textContent = '';\n  document.location.reload();\n});\n")),(0,r.kt)("p",null,"This is just like the event handlers, except that instead of the event being a user action, like the user clicking a button, the event is a change in some object's state."),(0,r.kt)("h3",{id:"callbacks"},"Callbacks"),(0,r.kt)("p",null,"An event handler is a particular type of callback. A callback is just a function that's passed into another function, with the expectation that the callback will be called at the appropriate time. As we just saw: callbacks used to be the main way asynchronous functions were implemented in JavaScript."),(0,r.kt)("p",null,"However, callback-based code can get hard to understand when the callback itself has to call functions that accept a callback. This is a common situation if you need to perform some operation that breaks down into a series of asynchronous functions. For example, consider the following:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"function doStep1(init) {\n  return init + 1;\n}\n\nfunction doStep2(init) {\n  return init + 2;\n}\n\nfunction doStep3(init) {\n  return init + 3;\n}\n\nfunction doOperation() {\n  let result = 0;\n  result = doStep1(result);\n  result = doStep2(result);\n  result = doStep3(result);\n  console.log(`result: ${result}`);\n}\n\ndoOperation();\n")),(0,r.kt)("p",null,"Here we have a single operation that's split into three steps, where each step depends on the last step. In our example the first step adds 1 to the input, the second adds 2, and the third adds 3. Starting with an input of 0, the end result is 6 (0 + 1 + 2 + 3). As synchronous code this is very straightforward. But what if we implemented the steps using callbacks?"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"function doStep1(init, callback) {\n  const result = init + 1;\n  callback(result);\n}\n\nfunction doStep2(init, callback) {\n  const result = init + 2;\n  callback(result);\n}\n\nfunction doStep3(init, callback) {\n  const result = init + 3;\n  callback(result);\n}\n\nfunction doOperation() {\n  doStep1(0, result1 => {\n    doStep2(result1, result2 => {\n      doStep3(result2, result3 => {\n        console.log(`result: ${result3}`);\n      });\n    });\n  });\n\n}\n\ndoOperation();\n")),(0,r.kt)("p",null,"Because we have to call callbacks inside callbacks, we get a deeply nested ",(0,r.kt)("inlineCode",{parentName:"p"},"doOperation()"),' function, which is much harder to read and debug. This is sometimes called "callback hell" or the "pyramid of doom" (because the indentation looks like a pyramid on its side).'),(0,r.kt)("p",null,'When we nest callbacks like this, it can also get very hard to handle errors: often you have to handle errors at each level of the "pyramid", instead of having error handling once at the top level.'),(0,r.kt)("p",null,"For these reasons, most modern asynchronous APIs don't use callbacks. Instead, the foundation of asynchronous programming in JavaScript is the {{jsxref(\"Promise\")}}, and that's the subject of the next article."),(0,r.kt)("h2",{id:"promises"},"Promises"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Promises")," are the foundation of asynchronous programming in modern JavaScript. A promise is an object returned by an asynchronous function, which represents the current state of the operation. At the time the promise is returned to the caller, the operation often isn't finished, but the promise object provides methods to handle the eventual success or failure of the operation."),(0,r.kt)("p",null,"In the last section we talked about the use of callbacks to implement asynchronous functions. With that design, you call the asynchronous function, passing in your callback function. The function returns immediately and calls your callback when the operation is finished."),(0,r.kt)("p",null,"With a promise-based API, the asynchronous function starts the operation and returns a Promise object. You can then attach handlers to this promise object, and these handlers will be executed when the operation has succeeded or failed."),(0,r.kt)("h3",{id:"using-the-fetch-api"},"Using the fetch() API"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Note:")," In this article we will explore promises by copying code samples from the page into your browser's JavaScript console. To get set up for this:"),(0,r.kt)("ol",{parentName:"blockquote"},(0,r.kt)("li",{parentName:"ol"},"open a browser tab and visit ",(0,r.kt)("a",{parentName:"li",href:"https://example.org"},"https://example.org")),(0,r.kt)("li",{parentName:"ol"},"in that tab, open the JavaScript console in your browser's developer tools"),(0,r.kt)("li",{parentName:"ol"},"when we show an example, copy it into the console. You will have to reload the page each time you enter a new example, or the console will complain that you have redeclared ",(0,r.kt)("inlineCode",{parentName:"li"},"fetchPromise"),"."))),(0,r.kt)("p",null,"In this example we'll download the JSON file from ",(0,r.kt)("a",{parentName:"p",href:"https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json"},"https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json"),", and log some information about it."),(0,r.kt)("p",null,"To do this we'll make an ",(0,r.kt)("strong",{parentName:"p"},"HTTP request")," to the server. In an HTTP request, we send a request message to a remote server, and it sends us back a response. In this case we'll send a request to get a JSON file from the server. Remember in the last article, where we made HTTP requests using the {{domxref(\"XMLHttpRequest\")}} API? Well, in this article we'll use the fetch() API, which is the modern, promise-based replacement for ",(0,r.kt)("inlineCode",{parentName:"p"},"XMLHttpRequest"),"."),(0,r.kt)("p",null,"Copy this into your browser's JavaScript console:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const fetchPromise = fetch('https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json');\n\nconsole.log(fetchPromise);\n\nfetchPromise.then( response => {\n  console.log(`Received response: ${response.status} ${response.statusText}`);\n});\n\nconsole.log(\"Started request...\");\n")),(0,r.kt)("p",null,"Here we are:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"calling the ",(0,r.kt)("inlineCode",{parentName:"li"},"fetch()")," API, and assigning the return value to the ",(0,r.kt)("inlineCode",{parentName:"li"},"fetchPromise")," variable"),(0,r.kt)("li",{parentName:"ol"},"immediately after, logging the ",(0,r.kt)("inlineCode",{parentName:"li"},"fetchPromise")," variable. This should output something like: ",(0,r.kt)("inlineCode",{parentName:"li"},'Promise { <state>: "pending" }'),", telling us that we have a ",(0,r.kt)("inlineCode",{parentName:"li"},"Promise")," object, and it has a ",(0,r.kt)("inlineCode",{parentName:"li"},"state")," whose value is ",(0,r.kt)("inlineCode",{parentName:"li"},'"pending"'),".  The ",(0,r.kt)("inlineCode",{parentName:"li"},'"pending"')," state means that the fetch operation is still going on."),(0,r.kt)("li",{parentName:"ol"},"passing a handler function into the Promise's ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"strong"},"then()")),' method. When (and if) the fetch operation succeeds, the promise will call our handler, passing in a {{domxref("Response")}} object, which contains the server\'s response.'),(0,r.kt)("li",{parentName:"ol"},"Logging a message that we have started the request.")),(0,r.kt)("p",null,"The complete output should be something like:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'Promise { <state>: "pending" }\nStarted request...\nReceived response: 200 OK\n')),(0,r.kt)("p",null,"Note that ",(0,r.kt)("inlineCode",{parentName:"p"},"Started request...")," is logged before we receive the response. Unlike a synchronous function, ",(0,r.kt)("inlineCode",{parentName:"p"},"fetch()")," returns while the request is still going on, enabling our program to stay responsive."),(0,r.kt)("p",null,'This probably seems a lot like the example in the last article, where we added event handlers to the {{domxref("XMLHttpRequest")}} object. Instead of that, we\'re passing a handler into the ',(0,r.kt)("inlineCode",{parentName:"p"},"then()")," method of the returned promise."),(0,r.kt)("h3",{id:"chaining-promises"},"Chaining promises"),(0,r.kt)("p",null,"With the ",(0,r.kt)("inlineCode",{parentName:"p"},"fetch()")," API, once you get a ",(0,r.kt)("inlineCode",{parentName:"p"},"Response"),' object, you need to call another function to get the response data. In this case we want to get the response data as JSON, so we would call the {{domxref("Response/json", "json()")}} method of the ',(0,r.kt)("inlineCode",{parentName:"p"},"Response")," object. It turns out that ",(0,r.kt)("inlineCode",{parentName:"p"},"json()")," is also asynchronous. So this is a case where we have to call two successive asynchronous functions."),(0,r.kt)("p",null,"Try this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const fetchPromise = fetch('https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json');\n\nfetchPromise.then( response => {\n  const jsonPromise = response.json();\n  jsonPromise.then( json => {\n    console.log(json[0].name);\n  });\n});\n")),(0,r.kt)("p",null,"In this example, as before, we add a ",(0,r.kt)("inlineCode",{parentName:"p"},"then()")," handler to the promise returned by ",(0,r.kt)("inlineCode",{parentName:"p"},"fetch()"),". But this time our handler calls ",(0,r.kt)("inlineCode",{parentName:"p"},"response.json()"),", and then passes a new ",(0,r.kt)("inlineCode",{parentName:"p"},"then()")," handler into the promise returned by ",(0,r.kt)("inlineCode",{parentName:"p"},"response.json()"),"."),(0,r.kt)("p",null,'This should log "baked beans" (the name of the first product inside "products.json").'),(0,r.kt)("p",null,'But wait! Remember the last article, where we said that by calling a callback inside another callback, we got successively more nested levels of code? And we said that this "callback hell" made our code hard to understand? Isn\'t this just the same, only with ',(0,r.kt)("inlineCode",{parentName:"p"},"then()")," calls?"),(0,r.kt)("p",null,"It is, of course. But the elegant feature of promises is that: ",(0,r.kt)("em",{parentName:"p"},(0,r.kt)("inlineCode",{parentName:"em"},"then()")," itself returns a promise, which will be completed with the result of the function that was passed to it"),". This means that we can (and certainly should) rewrite the above code like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const fetchPromise = fetch('https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json');\n\nfetchPromise\n  .then( response => {\n    return response.json();\n  })\n  .then( json => {\n    console.log(json[0].name);\n  });\n")),(0,r.kt)("p",null,"Instead of calling the second ",(0,r.kt)("inlineCode",{parentName:"p"},"then()")," inside the handler for the first ",(0,r.kt)("inlineCode",{parentName:"p"},"then()"),", we can ",(0,r.kt)("em",{parentName:"p"},"return")," the promise returned by ",(0,r.kt)("inlineCode",{parentName:"p"},"json()"),", and call the second ",(0,r.kt)("inlineCode",{parentName:"p"},"then()")," on that return value. This is called ",(0,r.kt)("strong",{parentName:"p"},"promise chaining")," and means we can avoid ever-increasing levels of indentation when we need to make consecutive asynchronous function calls."),(0,r.kt)("p",null,"Before we move on to the next step, there's one more piece to add. We need to check that the server accepted and was able to handle the request, before we try to read it. We'll do this by checking the status code in the response and throwing an error if it wasn't \"OK\":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const fetchPromise = fetch('https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json');\n\nfetchPromise\n  .then( response => {\n    if (!response.ok) {\n      throw new Error(`HTTP error: ${response.status}`);\n    }\n    return response.json();\n  })\n  .then( json => {\n    console.log(json[0].name);\n  });\n")),(0,r.kt)("h3",{id:"catching-errors"},"Catching errors"),(0,r.kt)("p",null,"This brings us to the last piece: how do we handle errors? The ",(0,r.kt)("inlineCode",{parentName:"p"},"fetch()")," API can throw an error for many reasons (for example, because there was no network connectivity or the URL was malformed in some way) and we are throwing an error ourselves if the server returned an error."),(0,r.kt)("p",null,"In the last article, we saw that error handling can get very difficult with nested callbacks, making us handle errors at every nesting level."),(0,r.kt)("p",null,"To support error handling, ",(0,r.kt)("inlineCode",{parentName:"p"},"Promise"),' objects provide a {{jsxref("Promise/catch", "catch()")}} method. This is a lot like ',(0,r.kt)("inlineCode",{parentName:"p"},"then()"),": you call it and pass in a handler function. However, while the handler passed to ",(0,r.kt)("inlineCode",{parentName:"p"},"then()")," is called when the asynchronous operation ",(0,r.kt)("em",{parentName:"p"},"succeeds"),", the handler passed to ",(0,r.kt)("inlineCode",{parentName:"p"},"catch()")," is called when the asynchronous operation ",(0,r.kt)("em",{parentName:"p"},"fails"),"."),(0,r.kt)("p",null,"If you add ",(0,r.kt)("inlineCode",{parentName:"p"},"catch()")," to the end of a promise chain, then it will be called when any of the asynchronous function calls fails. So you can implement an operation as several consecutive asynchronous function calls, and have a single place to handle all errors."),(0,r.kt)("p",null,"Try this version of our ",(0,r.kt)("inlineCode",{parentName:"p"},"fetch()")," code. We've added an error handler using ",(0,r.kt)("inlineCode",{parentName:"p"},"catch()"),", and also modified the URL so the request will fail."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const fetchPromise = fetch('bad-scheme://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json');\n\nfetchPromise\n  .then( response => {\n    if (!response.ok) {\n      throw new Error(`HTTP error: ${response.status}`);\n    }\n    return response.json();\n  })\n  .then( json => {\n    console.log(json[0].name);\n  })\n  .catch( error => {\n    console.error(`Could not get products: ${error}`);\n  });\n")),(0,r.kt)("p",null,"Try running this version: you should see the error logged by our ",(0,r.kt)("inlineCode",{parentName:"p"},"catch()")," handler."),(0,r.kt)("h3",{id:"promise-terminology"},"Promise terminology"),(0,r.kt)("p",null,"Promises come with some quite specific terminology that it's worth getting clear about."),(0,r.kt)("p",null,"First, a promise can be in one of three states:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"pending"),": the promise has been created, and the asynchronous function it's associated with has not succeeded or failed yet. This is the state your promise is in when it's returned from a call to ",(0,r.kt)("inlineCode",{parentName:"p"},"fetch()"),", and the request is still being made.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"fulfilled"),": the asynchronous function has succeeded. When a promise is fulfilled, its ",(0,r.kt)("inlineCode",{parentName:"p"},"then()")," handler is called.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"rejected"),": the asynchronous function has failed. When a promise is rejected, its ",(0,r.kt)("inlineCode",{parentName:"p"},"catch()")," handler is called."),(0,r.kt)("p",{parentName:"li"},'Note that what "succeeded" or "failed" means here is up to the API in question: for example, ',(0,r.kt)("inlineCode",{parentName:"p"},"fetch()")," considers a request successful if the server returned an error like 404 Not Found, but not if a network error prevented the request being sent."))),(0,r.kt)("p",null,"Sometimes we use the term ",(0,r.kt)("strong",{parentName:"p"},"settled")," to cover both ",(0,r.kt)("strong",{parentName:"p"},"fulfilled")," and ",(0,r.kt)("strong",{parentName:"p"},"rejected"),"."),(0,r.kt)("p",null,"A promise is ",(0,r.kt)("strong",{parentName:"p"},"resolved"),' if it is settled, or if it has been "locked in" to follow the state of another promise.'),(0,r.kt)("p",null,"The article ",(0,r.kt)("a",{parentName:"p",href:"https://thenewtoys.dev/blog/2021/02/08/lets-talk-about-how-to-talk-about-promises/"},"Let's talk about how to talk about promises")," gives a great explanation of the details of this terminology."),(0,r.kt)("h3",{id:"conclusion"},"Conclusion"),(0,r.kt)("p",null,"Promises are the foundation of asynchronous programming in modern JavaScript. They make it easier to express and reason about sequences of asynchronous operations without deeply nested callbacks, and they support a style of error handling that is similar to the synchronous ",(0,r.kt)("inlineCode",{parentName:"p"},"try...catch")," statement."),(0,r.kt)("h2",{id:"ref"},"Ref"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions"},"developer.mozilla.org")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Introducing"},"developer.mozilla.org")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Promises"},"developer.mozilla.org"))))}d.isMDXComponent=!0}}]);