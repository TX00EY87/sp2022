"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[299],{3905:function(e,n,t){t.d(n,{Zo:function(){return p},kt:function(){return d}});var i=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,i,a=function(e,n){if(null==e)return{};var t,i,a={},o=Object.keys(e);for(i=0;i<o.length;i++)t=o[i],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)t=o[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var s=i.createContext({}),u=function(e){var n=i.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},p=function(e){var n=u(e.components);return i.createElement(s.Provider,{value:n},e.children)},c={inlineCode:"code",wrapper:function(e){var n=e.children;return i.createElement(i.Fragment,{},n)}},m=i.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),m=u(t),d=a,f=m["".concat(s,".").concat(d)]||m[d]||c[d]||o;return t?i.createElement(f,r(r({ref:n},p),{},{components:t})):i.createElement(f,r({ref:n},p))}));function d(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,r=new Array(o);r[0]=m;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,r[1]=l;for(var u=2;u<o;u++)r[u]=t[u];return i.createElement.apply(null,r)}return i.createElement.apply(null,t)}m.displayName="MDXCreateElement"},3411:function(e,n,t){t.r(n),t.d(n,{assets:function(){return p},contentTitle:function(){return s},default:function(){return d},frontMatter:function(){return l},metadata:function(){return u},toc:function(){return c}});var i=t(7462),a=t(3366),o=(t(7294),t(3905)),r=["components"],l={title:"Conditional chains, Equality comparisons and sameness",sidebar_label:"Equality comparisons",pagination_next:null,pagination_prev:null,hide_table_of_contents:!1},s="Conditional chains, Equality comparisons and sameness",u={unversionedId:"extra/equality",id:"extra/equality",title:"Conditional chains, Equality comparisons and sameness",description:"Conditional chains",source:"@site/docs/extra/equality.md",sourceDirName:"extra",slug:"/extra/equality",permalink:"/sp2022/extra/equality",tags:[],version:"current",frontMatter:{title:"Conditional chains, Equality comparisons and sameness",sidebar_label:"Equality comparisons",pagination_next:null,pagination_prev:null,hide_table_of_contents:!1},sidebar:"docs"},p={},c=[{value:"Conditional chains",id:"conditional-chains",level:2},{value:"Equality comparisons and sameness",id:"equality-comparisons-and-sameness",level:2}],m={toc:c};function d(e){var n=e.components,t=(0,a.Z)(e,r);return(0,o.kt)("wrapper",(0,i.Z)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"conditional-chains-equality-comparisons-and-sameness"},"Conditional chains, Equality comparisons and sameness"),(0,o.kt)("h2",{id:"conditional-chains"},"Conditional chains"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Example:")," Conditional chains"),(0,o.kt)("p",null,'The ternary operator is right-associative, which means it can be "chained" in the following way, similar to an ',(0,o.kt)("inlineCode",{parentName:"p"},"if \u2026 else if \u2026 else if \u2026 else")," chain:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"function example(\u2026) {\n    return condition1 ? value1\n         : condition2 ? value2\n         : condition3 ? value3\n         : value4;\n}\n\n// Equivalent to:\n\nfunction example(\u2026) {\n    if (condition1) { return value1; }\n    else if (condition2) { return value2; }\n    else if (condition3) { return value3; }\n    else { return value4; }\n}\n")),(0,o.kt)("h2",{id:"equality-comparisons-and-sameness"},"Equality comparisons and sameness"),(0,o.kt)("p",null,"JavaScript provides three different value-comparison operations:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"double equals (",(0,o.kt)("inlineCode",{parentName:"li"},"=="),") will perform a type conversion when comparing two things, and will handle ",(0,o.kt)("inlineCode",{parentName:"li"},"NaN"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"-0"),", and ",(0,o.kt)("inlineCode",{parentName:"li"},"+0")," specially to conform to IEEE 754 (so ",(0,o.kt)("inlineCode",{parentName:"li"},"NaN != NaN"),", and ",(0,o.kt)("inlineCode",{parentName:"li"},"-0 == +0"),");"),(0,o.kt)("li",{parentName:"ul"},"triple equals (",(0,o.kt)("inlineCode",{parentName:"li"},"==="),") will do the same comparison as double equals (including the special handling for ",(0,o.kt)("inlineCode",{parentName:"li"},"NaN"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"-0"),", and ",(0,o.kt)("inlineCode",{parentName:"li"},"+0"),") but without type conversion; if the types differ, ",(0,o.kt)("inlineCode",{parentName:"li"},"false")," is returned."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"Object.is")," does no type conversion and no special handling for ",(0,o.kt)("inlineCode",{parentName:"li"},"NaN"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"-0"),", and ",(0,o.kt)("inlineCode",{parentName:"li"},"+0")," (giving it the same behavior as ",(0,o.kt)("inlineCode",{parentName:"li"},"===")," except on those special numeric values).")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Example:")," Strict equality using ",(0,o.kt)("inlineCode",{parentName:"p"},"===")),(0,o.kt)("p",null,"Strict equality compares two values for equality. Neither value is implicitly converted to some other value before being compared. If the values have different types, the values are considered unequal. If the values have the same type, are not numbers, and have the same value, they're considered equal. Finally, if both values are numbers, they're considered equal if they're both not ",(0,o.kt)("inlineCode",{parentName:"p"},"NaN")," and are the same value, or if one is ",(0,o.kt)("inlineCode",{parentName:"p"},"+0")," and one is ",(0,o.kt)("inlineCode",{parentName:"p"},"-0"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"var num = 0;\nvar obj = new String('0');\nvar str = '0';\n\nconsole.log(num === num); // true\nconsole.log(obj === obj); // true\nconsole.log(str === str); // true\n\nconsole.log(num === obj); // false\nconsole.log(num === str); // false\nconsole.log(obj === str); // false\nconsole.log(null === undefined); // false\nconsole.log(obj === null); // false\nconsole.log(obj === undefined); // false\n")),(0,o.kt)("p",null,"Strict equality is almost always the correct comparison operation to use. For all values except numbers, it uses the obvious semantics: a value is only equal to itself. For numbers it uses slightly different semantics to gloss over two different edge cases. The first is that floating point zero is either positively or negatively signed. This is useful in representing certain mathematical solutions, but as most situations don't care about the difference between ",(0,o.kt)("inlineCode",{parentName:"p"},"+0")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"-0"),", strict equality treats them as the same value. The second is that floating point includes the concept of a not-a-number value, ",(0,o.kt)("inlineCode",{parentName:"p"},"NaN"),", to represent the solution to certain ill-defined mathematical problems: negative infinity added to positive infinity, for example. Strict equality treats ",(0,o.kt)("inlineCode",{parentName:"p"},"NaN")," as unequal to every other value -- including itself. (The only case in which ",(0,o.kt)("inlineCode",{parentName:"p"},"(x !== x)")," is ",(0,o.kt)("inlineCode",{parentName:"p"},"true")," is when ",(0,o.kt)("inlineCode",{parentName:"p"},"x")," is ",(0,o.kt)("inlineCode",{parentName:"p"},"NaN"),".)"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Example:")," Loose equality using =="),(0,o.kt)("p",null,"The behavior for performing loose equality using ",(0,o.kt)("inlineCode",{parentName:"p"},"==")," is as follows:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Loose equality compares two values for equality ",(0,o.kt)("em",{parentName:"li"},"after")," converting both values to a common type. After conversions (one or both sides may undergo conversions), the final equality comparison is performed exactly as ",(0,o.kt)("inlineCode",{parentName:"li"},"===")," performs it."),(0,o.kt)("li",{parentName:"ul"},"Loose equality is ",(0,o.kt)("em",{parentName:"li"},"symmetric"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"A == B")," always has identical semantics to ",(0,o.kt)("inlineCode",{parentName:"li"},"B == A")," for any values of ",(0,o.kt)("inlineCode",{parentName:"li"},"A")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"B")," (except for the order of applied conversions)."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"undefined")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"null")," are loosely equal; that is, ",(0,o.kt)("inlineCode",{parentName:"li"},"undefined == null")," is true, and ",(0,o.kt)("inlineCode",{parentName:"li"},"null == undefined")," is true")),(0,o.kt)("p",null,"The following example demonstrates loose equality comparisons involving the number primitive ",(0,o.kt)("inlineCode",{parentName:"p"},"0"),", the bigint primitive ",(0,o.kt)("inlineCode",{parentName:"p"},"0n"),", the string primitive ",(0,o.kt)("inlineCode",{parentName:"p"},"'0'"),", and an object whose ",(0,o.kt)("inlineCode",{parentName:"p"},"toString()")," value is ",(0,o.kt)("inlineCode",{parentName:"p"},"'0'"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const num = 0;\nconst big = 0n;\nconst str = '0';\nconst obj = new String('0');\n\nconsole.log(num == str); // true\nconsole.log(big == num); // true\nconsole.log(str == big); // true\n\nconsole.log(num == obj); // true\nconsole.log(big == obj); // true\nconsole.log(str == obj); // true\n")))}d.isMDXComponent=!0}}]);